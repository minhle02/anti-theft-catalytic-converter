
/Users/francis-hung/Documents/Code/avr-iot/Code/build/Code.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	01 c1       	rjmp	.+514    	; 0x204 <__dtors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	35 c1       	rjmp	.+618    	; 0x270 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	33 c1       	rjmp	.+614    	; 0x270 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	31 c1       	rjmp	.+610    	; 0x270 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	2f c1       	rjmp	.+606    	; 0x270 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	2d c1       	rjmp	.+602    	; 0x270 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	0c 94 df 08 	jmp	0x11be	; 0x11be <__vector_6>
../../../../crt1/gcrt1.S:73
      1c:	29 c1       	rjmp	.+594    	; 0x270 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	de c5       	rjmp	.+3004   	; 0xbde <__vector_8>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	25 c1       	rjmp	.+586    	; 0x270 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	23 c1       	rjmp	.+582    	; 0x270 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	21 c1       	rjmp	.+578    	; 0x270 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	1f c1       	rjmp	.+574    	; 0x270 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	1d c1       	rjmp	.+570    	; 0x270 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	1b c1       	rjmp	.+566    	; 0x270 <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	19 c1       	rjmp	.+562    	; 0x270 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	17 c1       	rjmp	.+558    	; 0x270 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	15 c1       	rjmp	.+554    	; 0x270 <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	c9 c6       	rjmp	.+3474   	; 0xddc <__vector_18>
      4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
      4c:	11 c1       	rjmp	.+546    	; 0x270 <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	0f c1       	rjmp	.+542    	; 0x270 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	0d c1       	rjmp	.+538    	; 0x270 <__bad_interrupt>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	0b c1       	rjmp	.+534    	; 0x270 <__bad_interrupt>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	09 c1       	rjmp	.+530    	; 0x270 <__bad_interrupt>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	b5 c5       	rjmp	.+2922   	; 0xbcc <__vector_24>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	05 c1       	rjmp	.+522    	; 0x270 <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	03 c1       	rjmp	.+518    	; 0x270 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	01 c1       	rjmp	.+514    	; 0x270 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	ff c0       	rjmp	.+510    	; 0x270 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	fd c0       	rjmp	.+506    	; 0x270 <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	ac c5       	rjmp	.+2904   	; 0xbd2 <__vector_30>
      7a:	00 00       	nop
../../../../crt1/gcrt1.S:97
      7c:	85 c5       	rjmp	.+2826   	; 0xb88 <__vector_31>
      7e:	00 00       	nop
../../../../crt1/gcrt1.S:98
      80:	09 c7       	rjmp	.+3602   	; 0xe94 <__vector_32>
      82:	00 00       	nop
../../../../crt1/gcrt1.S:99
      84:	d4 c6       	rjmp	.+3496   	; 0xe2e <__vector_33>
      86:	00 00       	nop
../../../../crt1/gcrt1.S:100
      88:	f3 c0       	rjmp	.+486    	; 0x270 <__bad_interrupt>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	99 c5       	rjmp	.+2866   	; 0xbc0 <__vector_35>
      8e:	00 00       	nop
../../../../crt1/gcrt1.S:102
      90:	ef c0       	rjmp	.+478    	; 0x270 <__bad_interrupt>
      92:	00 00       	nop
../../../../crt1/gcrt1.S:103
      94:	ed c0       	rjmp	.+474    	; 0x270 <__bad_interrupt>
      96:	00 00       	nop
../../../../crt1/gcrt1.S:104
      98:	eb c0       	rjmp	.+470    	; 0x270 <__bad_interrupt>
      9a:	00 00       	nop
../../../../crt1/gcrt1.S:105
      9c:	e9 c0       	rjmp	.+466    	; 0x270 <__bad_interrupt>
      9e:	00 00       	nop
../../../../crt1/gcrt1.S:106
      a0:	e7 c0       	rjmp	.+462    	; 0x270 <__bad_interrupt>
      a2:	00 00       	nop
../../../../crt1/gcrt1.S:107
      a4:	e5 c0       	rjmp	.+458    	; 0x270 <__bad_interrupt>
      a6:	00 00       	nop
../../../../crt1/gcrt1.S:108
      a8:	70 c6       	rjmp	.+3296   	; 0xd8a <__vector_42>
      aa:	00 00       	nop
../../../../crt1/gcrt1.S:109
      ac:	e1 c0       	rjmp	.+450    	; 0x270 <__bad_interrupt>
      ae:	00 00       	nop
../../../../crt1/gcrt1.S:110
      b0:	df c0       	rjmp	.+446    	; 0x270 <__bad_interrupt>
      b2:	00 00       	nop
../../../../crt1/gcrt1.S:111
      b4:	91 c5       	rjmp	.+2850   	; 0xbd8 <__vector_45>
      b6:	00 00       	nop
../../../../crt1/gcrt1.S:112
      b8:	86 c5       	rjmp	.+2828   	; 0xbc6 <__vector_46>
      ba:	00 00       	nop
../../../../crt1/gcrt1.S:113
      bc:	d9 c0       	rjmp	.+434    	; 0x270 <__bad_interrupt>
      be:	00 00       	nop
../../../../crt1/gcrt1.S:114
      c0:	d7 c0       	rjmp	.+430    	; 0x270 <__bad_interrupt>
      c2:	00 00       	nop
../../../../crt1/gcrt1.S:115
      c4:	d5 c0       	rjmp	.+426    	; 0x270 <__bad_interrupt>
      c6:	00 00       	nop
../../../../crt1/gcrt1.S:116
      c8:	d3 c0       	rjmp	.+422    	; 0x270 <__bad_interrupt>
      ca:	00 00       	nop
../../../../crt1/gcrt1.S:117
      cc:	d1 c0       	rjmp	.+418    	; 0x270 <__bad_interrupt>
      ce:	00 00       	nop
../../../../crt1/gcrt1.S:118
      d0:	cf c0       	rjmp	.+414    	; 0x270 <__bad_interrupt>
      d2:	00 00       	nop
../../../../crt1/gcrt1.S:119
      d4:	d8 c5       	rjmp	.+2992   	; 0xc86 <__vector_53>
      d6:	00 00       	nop
../../../../crt1/gcrt1.S:120
      d8:	d0 c5       	rjmp	.+2976   	; 0xc7a <__vector_54>
      da:	00 00       	nop
../../../../crt1/gcrt1.S:121
      dc:	da c5       	rjmp	.+2996   	; 0xc92 <__vector_55>
      de:	00 00       	nop
../../../../crt1/gcrt1.S:122
      e0:	c7 c0       	rjmp	.+398    	; 0x270 <__bad_interrupt>
      e2:	00 00       	nop
../../../../crt1/gcrt1.S:123
      e4:	c5 c0       	rjmp	.+394    	; 0x270 <__bad_interrupt>
      e6:	00 00       	nop
../../../../crt1/gcrt1.S:124
      e8:	c3 c0       	rjmp	.+390    	; 0x270 <__bad_interrupt>
      ea:	00 00       	nop
../../../../crt1/gcrt1.S:125
      ec:	c1 c0       	rjmp	.+386    	; 0x270 <__bad_interrupt>
      ee:	00 00       	nop
../../../../crt1/gcrt1.S:126
      f0:	bf c0       	rjmp	.+382    	; 0x270 <__bad_interrupt>
	...

000000f4 <__trampolines_end>:
__trampolines_start():
      f4:	6e 61       	ori	r22, 0x1E	; 30
      f6:	6e 00       	.word	0x006e	; ????

000000f8 <__c.2228>:
      f8:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     108:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     118:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     128:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     138:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     148:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     158:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     168:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     178:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     188:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     198:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1a8:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1b8:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     1c8:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     1d8:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     1e8:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

000001f6 <_usart3_pins>:
     1f6:	00 08 0a 40 0c ff c0 00 c0 00                       ...@......

00000200 <__ctors_start>:
__ctors_start():
     200:	57 0c       	add	r5, r7

00000202 <__ctors_end>:
__dtors_start():
     202:	d6 0e       	add	r13, r22

00000204 <__dtors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     204:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     206:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     208:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     20a:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     20c:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
     20e:	de bf       	out	0x3e, r29	; 62

00000210 <_initThreeStuff()>:
init_reset_flags():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/main.cpp:103

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
     210:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/main.cpp:104
    RSTCTRL.RSTFR = flags;
     214:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/main.cpp:105
    if (flags == 0) {
     218:	81 11       	cpse	r24, r1
     21a:	05 c0       	rjmp	.+10     	; 0x226 <_initThreeStuff()+0x16>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/main.cpp:106
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
     21c:	98 ed       	ldi	r25, 0xD8	; 216
     21e:	21 e0       	ldi	r18, 0x01	; 1
     220:	94 bf       	out	0x34, r25	; 52
     222:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7e0041>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/main.cpp:108
    }
    GPIOR0 = flags;
     226:	8c bb       	out	0x1c, r24	; 28

00000228 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     228:	28 e4       	ldi	r18, 0x48	; 72
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     22a:	ae e6       	ldi	r26, 0x6E	; 110
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     22c:	b1 e4       	ldi	r27, 0x41	; 65
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     22e:	01 c0       	rjmp	.+2      	; 0x232 <.do_clear_bss_start>

00000230 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     230:	1d 92       	st	X+, r1

00000232 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     232:	aa 3d       	cpi	r26, 0xDA	; 218
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     234:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     236:	e1 f7       	brne	.-8      	; 0x230 <.do_clear_bss_loop>

00000238 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2373
     238:	11 e4       	ldi	r17, 0x41	; 65
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2374
     23a:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2375
     23c:	b0 e4       	ldi	r27, 0x40	; 64
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2376
     23e:	e6 e4       	ldi	r30, 0x46	; 70
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2377
     240:	f5 e2       	ldi	r31, 0x25	; 37
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2378
     242:	00 e0       	ldi	r16, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2379
     244:	0b bf       	out	0x3b, r16	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2380
     246:	02 c0       	rjmp	.+4      	; 0x24c <__do_copy_data+0x14>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2382
     248:	07 90       	elpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2383
     24a:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2385
     24c:	ae 36       	cpi	r26, 0x6E	; 110
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2386
     24e:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2387
     250:	d9 f7       	brne	.-10     	; 0x248 <__do_copy_data+0x10>

00000252 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     252:	11 e0       	ldi	r17, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     254:	c1 e0       	ldi	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     256:	d1 e0       	ldi	r29, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     258:	04 c0       	rjmp	.+8      	; 0x262 <__do_global_ctors+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     25a:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     25c:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     25e:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     262:	c0 30       	cpi	r28, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     264:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     266:	c9 f7       	brne	.-14     	; 0x25a <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     268:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <main>
../../../../crt1/gcrt1.S:315
     26c:	0c 94 97 12 	jmp	0x252e	; 0x252e <__do_global_dtors>

00000270 <__bad_interrupt>:
__vector_38():
../../../../crt1/gcrt1.S:209
     270:	c7 ce       	rjmp	.-626    	; 0x0 <__vectors>

00000272 <printf_putchar(char, __file*)>:
printf_putchar():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:25
#error "INCOMPATIBLE_DEVICE_SELECTED"
#endif
#endif

int16_t printf_putchar(char c, FILE* fp) {
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
     272:	fb 01       	movw	r30, r22
     274:	a4 85       	ldd	r26, Z+12	; 0x0c
     276:	b5 85       	ldd	r27, Z+13	; 0x0d
     278:	ed 91       	ld	r30, X+
     27a:	fc 91       	ld	r31, X
     27c:	11 97       	sbiw	r26, 0x01	; 1
     27e:	01 90       	ld	r0, Z+
     280:	f0 81       	ld	r31, Z
     282:	e0 2d       	mov	r30, r0
     284:	68 2f       	mov	r22, r24
     286:	cd 01       	movw	r24, r26
     288:	09 95       	icall
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:27
    return 0;
}
     28a:	90 e0       	ldi	r25, 0x00	; 0
     28c:	80 e0       	ldi	r24, 0x00	; 0
     28e:	08 95       	ret

00000290 <printf_putchar(char, __file*)>:
_ZL14printf_putcharcP6__file():
     290:	f0 cf       	rjmp	.-32     	; 0x272 <printf_putchar(char, __file*)>

00000292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>:
_Z14__pinconfigurehj.part.0():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:34
  checkCore(1);
}
#endif
void __pinconfigure(const uint8_t digital_pin, uint16_t pin_config) {

  uint8_t bit_mask = digitalPinToBitMask(digital_pin);
     292:	90 e0       	ldi	r25, 0x00	; 0
     294:	fc 01       	movw	r30, r24
     296:	ef 56       	subi	r30, 0x6F	; 111
     298:	ff 4b       	sbci	r31, 0xBF	; 191
     29a:	30 81       	ld	r19, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:35
  if(bit_mask == NOT_A_PIN || !pin_config) { // Return if digital pin is invalid or the other parameters or out to zero
     29c:	3f 3f       	cpi	r19, 0xFF	; 255
     29e:	69 f1       	breq	.+90     	; 0x2fa <__pinconfigure(unsigned char, unsigned int) [clone .part.0]+0x68>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:38
    return;
  }
  uint8_t bit_pos  = digitalPinToBitPosition(digital_pin);
     2a0:	fc 01       	movw	r30, r24
     2a2:	e8 59       	subi	r30, 0x98	; 152
     2a4:	ff 4b       	sbci	r31, 0xBF	; 191
     2a6:	20 81       	ld	r18, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:39
  volatile uint8_t *portbase = (volatile uint8_t*) digitalPinToPortStruct(digital_pin);
     2a8:	81 5c       	subi	r24, 0xC1	; 193
     2aa:	9f 4b       	sbci	r25, 0xBF	; 191
     2ac:	dc 01       	movw	r26, r24
     2ae:	ec 91       	ld	r30, X
     2b0:	b0 e2       	ldi	r27, 0x20	; 32
     2b2:	eb 9f       	mul	r30, r27
     2b4:	f0 01       	movw	r30, r0
     2b6:	11 24       	eor	r1, r1
     2b8:	fc 5f       	subi	r31, 0xFC	; 252
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:42

  // Write to selected pin direction register
  uint8_t setting = pin_config & 0x03; // Mask out direction bits (DIR, DIRSET, DIRCLR, DIRTGL)
     2ba:	a6 2f       	mov	r26, r22
     2bc:	a3 70       	andi	r26, 0x03	; 3
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:43
  if(setting)
     2be:	21 f0       	breq	.+8      	; 0x2c8 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]+0x36>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:44
    *(portbase + setting) = bit_mask;
     2c0:	ae 0f       	add	r26, r30
     2c2:	bf 2f       	mov	r27, r31
     2c4:	b1 1d       	adc	r27, r1
     2c6:	3c 93       	st	X, r19
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:47

  // Write to selected output register
  pin_config >>= 2;
     2c8:	cb 01       	movw	r24, r22
     2ca:	96 95       	lsr	r25
     2cc:	87 95       	ror	r24
     2ce:	96 95       	lsr	r25
     2d0:	87 95       	ror	r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:54
  if(setting) {
    *(portbase + 4 + setting) = bit_mask;
  }

  // Return if there is nothing more to configure
  if(!(pin_config & 0x3FFC)) {
     2d2:	89 2b       	or	r24, r25
     2d4:	91 f0       	breq	.+36     	; 0x2fa <__pinconfigure(unsigned char, unsigned int) [clone .part.0]+0x68>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:64
   * For this we need to disable interrupts
   * (for efficiency) we only read the register once
   * modify that value, then write it back at the end.
   */

  uint8_t oldSREG = SREG;             // Store SREG
     2d6:	3f b7       	in	r19, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:65
  cli();
     2d8:	f8 94       	cli
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:67
  pin_config >>= 2;
  uint8_t pinncfg = *(portbase + 0x10 + bit_pos);
     2da:	82 2f       	mov	r24, r18
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	40 96       	adiw	r24, 0x10	; 16
     2e0:	e8 0f       	add	r30, r24
     2e2:	f9 1f       	adc	r31, r25
     2e4:	80 81       	ld	r24, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:66
   * modify that value, then write it back at the end.
   */

  uint8_t oldSREG = SREG;             // Store SREG
  cli();
  pin_config >>= 2;
     2e6:	94 e0       	ldi	r25, 0x04	; 4
     2e8:	76 95       	lsr	r23
     2ea:	67 95       	ror	r22
     2ec:	9a 95       	dec	r25
     2ee:	e1 f7       	brne	.-8      	; 0x2e8 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]+0x56>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:69
  uint8_t pinncfg = *(portbase + 0x10 + bit_pos);
  // Input sense configuration (ISC)
  if (pin_config & 0x08) {
     2f0:	67 2b       	or	r22, r23
     2f2:	09 f0       	breq	.+2      	; 0x2f6 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]+0x64>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:70
    pinncfg = (pinncfg & 0xF8) | (pin_config & PORT_ISC_gm);
     2f4:	88 7f       	andi	r24, 0xF8	; 248
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:116
      pinncfg &= ~(PORT_INVEN_bm);    // Clear INVEN
    else
      pinncfg |= PORT_INVEN_bm;       // Set INVEN
  }
  // Write to PINnCTRL register
  *(portbase + 0x10 + bit_pos) = pinncfg;
     2f6:	80 83       	st	Z, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:119

  // Restore SREG
  SREG = oldSREG;
     2f8:	3f bf       	out	0x3f, r19	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_extra.cpp:120
}
     2fa:	08 95       	ret

000002fc <micros>:
micros():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:467
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     2fc:	9f b7       	in	r25, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:468
      cli(); /* INTERRUPTS OFF */
     2fe:	f8 94       	cli
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:484
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
     300:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7e0b2a>
     304:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7e0b2b>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:485
        flags = _timer->INTFLAGS;
     308:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:493
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
     30c:	20 91 c9 44 	lds	r18, 0x44C9	; 0x8044c9 <timingStruct>
     310:	30 91 ca 44 	lds	r19, 0x44CA	; 0x8044ca <timingStruct+0x1>
     314:	40 91 cb 44 	lds	r20, 0x44CB	; 0x8044cb <timingStruct+0x2>
     318:	50 91 cc 44 	lds	r21, 0x44CC	; 0x8044cc <timingStruct+0x3>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:498
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
     31c:	9f bf       	out	0x3f, r25	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:508
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     31e:	80 ff       	sbrs	r24, 0
     320:	08 c0       	rjmp	.+16     	; 0x332 <micros+0x36>
     322:	cf 01       	movw	r24, r30
     324:	88 27       	eor	r24, r24
     326:	89 2b       	or	r24, r25
     328:	21 f4       	brne	.+8      	; 0x332 <micros+0x36>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:513
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
     32a:	2f 5f       	subi	r18, 0xFF	; 255
     32c:	3f 4f       	sbci	r19, 0xFF	; 255
     32e:	4f 4f       	sbci	r20, 0xFF	; 255
     330:	5f 4f       	sbci	r21, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:662
         * 57 replaced with 30 save 27 clocks @ 12 = 2 us saved
         * 67 replaced with 32 save 35 clocks @ 24 = 1.5us saved
         * 77 replaced with 34 save 43 clocks @ 48 = 1 us saved
         */
        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          __asm__ __volatile__(
     332:	0f 01       	movw	r0, r30
     334:	16 94       	lsr	r1
     336:	07 94       	ror	r0
     338:	16 94       	lsr	r1
     33a:	07 94       	ror	r0
     33c:	16 94       	lsr	r1
     33e:	07 94       	ror	r0
     340:	16 94       	lsr	r1
     342:	07 94       	ror	r0
     344:	f0 01       	movw	r30, r0
     346:	16 94       	lsr	r1
     348:	07 94       	ror	r0
     34a:	e0 0d       	add	r30, r0
     34c:	f1 1d       	adc	r31, r1
     34e:	16 94       	lsr	r1
     350:	07 94       	ror	r0
     352:	10 2c       	mov	r1, r0
     354:	16 94       	lsr	r1
     356:	01 18       	sub	r0, r1
     358:	16 94       	lsr	r1
     35a:	01 0c       	add	r0, r1
     35c:	16 94       	lsr	r1
     35e:	01 18       	sub	r0, r1
     360:	16 94       	lsr	r1
     362:	01 0c       	add	r0, r1
     364:	16 94       	lsr	r1
     366:	01 18       	sub	r0, r1
     368:	16 94       	lsr	r1
     36a:	16 94       	lsr	r1
     36c:	01 0c       	add	r0, r1
     36e:	11 24       	eor	r1, r1
     370:	e0 19       	sub	r30, r0
     372:	f1 09       	sbc	r31, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:707
            "add r0,r1"     "\n\t"  // + ticks >> 9
            "eor r1,r1"     "\n\t"  // clear out r1
            "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
            "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.
     374:	a8 ee       	ldi	r26, 0xE8	; 232
     376:	b3 e0       	ldi	r27, 0x03	; 3
     378:	0e 94 57 10 	call	0x20ae	; 0x20ae <__muluhisi3>
     37c:	6e 0f       	add	r22, r30
     37e:	7f 1f       	adc	r23, r31
     380:	81 1d       	adc	r24, r1
     382:	91 1d       	adc	r25, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:877
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
     384:	08 95       	ret

00000386 <delay>:
delay():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:939

#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
     386:	cf 92       	push	r12
     388:	df 92       	push	r13
     38a:	ef 92       	push	r14
     38c:	ff 92       	push	r15
     38e:	cf 93       	push	r28
     390:	df 93       	push	r29
     392:	6b 01       	movw	r12, r22
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:940
    uint16_t start = (uint16_t)micros();
     394:	7c 01       	movw	r14, r24
     396:	b2 df       	rcall	.-156    	; 0x2fc <micros>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:944
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
     398:	eb 01       	movw	r28, r22
     39a:	b0 df       	rcall	.-160    	; 0x2fc <micros>
     39c:	6c 1b       	sub	r22, r28
     39e:	7d 0b       	sbc	r23, r29
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:945
      if (us_passed >= 1000) {
     3a0:	68 3e       	cpi	r22, 0xE8	; 232
     3a2:	73 40       	sbci	r23, 0x03	; 3
     3a4:	d0 f3       	brcs	.-12     	; 0x39a <delay+0x14>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:946
        ms--;
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	c8 1a       	sub	r12, r24
     3aa:	d1 08       	sbc	r13, r1
     3ac:	e1 08       	sbc	r14, r1
     3ae:	f1 08       	sbc	r15, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:947
        start += 1000;
     3b0:	c8 51       	subi	r28, 0x18	; 24
     3b2:	dc 4f       	sbci	r29, 0xFC	; 252
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:942
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
     3b4:	c1 14       	cp	r12, r1
     3b6:	d1 04       	cpc	r13, r1
     3b8:	e1 04       	cpc	r14, r1
     3ba:	f1 04       	cpc	r15, r1
     3bc:	71 f7       	brne	.-36     	; 0x39a <delay+0x14>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:950
      if (us_passed >= 1000) {
        ms--;
        start += 1000;
      }
    }
  }
     3be:	df 91       	pop	r29
     3c0:	cf 91       	pop	r28
     3c2:	ff 90       	pop	r15
     3c4:	ef 90       	pop	r14
     3c6:	df 90       	pop	r13
     3c8:	cf 90       	pop	r12
     3ca:	08 95       	ret

000003cc <Print::write(unsigned char const*, unsigned int)>:
write():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     3cc:	af 92       	push	r10
     3ce:	bf 92       	push	r11
     3d0:	cf 92       	push	r12
     3d2:	df 92       	push	r13
     3d4:	ef 92       	push	r14
     3d6:	ff 92       	push	r15
     3d8:	0f 93       	push	r16
     3da:	1f 93       	push	r17
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	6c 01       	movw	r12, r24
     3e2:	7b 01       	movw	r14, r22
     3e4:	8b 01       	movw	r16, r22
     3e6:	04 0f       	add	r16, r20
     3e8:	15 1f       	adc	r17, r21
     3ea:	eb 01       	movw	r28, r22
     3ec:	5e 01       	movw	r10, r28
     3ee:	ae 18       	sub	r10, r14
     3f0:	bf 08       	sbc	r11, r15
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     3f2:	c0 17       	cp	r28, r16
     3f4:	d1 07       	cpc	r29, r17
     3f6:	59 f0       	breq	.+22     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:32
    if (write(*buffer++)) {
     3f8:	69 91       	ld	r22, Y+
     3fa:	d6 01       	movw	r26, r12
     3fc:	ed 91       	ld	r30, X+
     3fe:	fc 91       	ld	r31, X
     400:	01 90       	ld	r0, Z+
     402:	f0 81       	ld	r31, Z
     404:	e0 2d       	mov	r30, r0
     406:	c6 01       	movw	r24, r12
     408:	09 95       	icall
     40a:	89 2b       	or	r24, r25
     40c:	79 f7       	brne	.-34     	; 0x3ec <Print::write(unsigned char const*, unsigned int)+0x20>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     40e:	c5 01       	movw	r24, r10
     410:	df 91       	pop	r29
     412:	cf 91       	pop	r28
     414:	1f 91       	pop	r17
     416:	0f 91       	pop	r16
     418:	ff 90       	pop	r15
     41a:	ef 90       	pop	r14
     41c:	df 90       	pop	r13
     41e:	cf 90       	pop	r12
     420:	bf 90       	pop	r11
     422:	af 90       	pop	r10
     424:	08 95       	ret

00000426 <HardwareSerial::availableForWrite()>:
availableForWrite():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:727
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
     426:	fc 01       	movw	r30, r24
     428:	51 89       	ldd	r21, Z+17	; 0x11
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:728
          tail = _tx_buffer_tail;
     42a:	42 89       	ldd	r20, Z+18	; 0x12
     42c:	25 2f       	mov	r18, r21
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	84 2f       	mov	r24, r20
     432:	90 e0       	ldi	r25, 0x00	; 0
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:731
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     434:	82 1b       	sub	r24, r18
     436:	93 0b       	sbc	r25, r19
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:730

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
     438:	54 17       	cp	r21, r20
     43a:	10 f0       	brcs	.+4      	; 0x440 <HardwareSerial::availableForWrite()+0x1a>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:731
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     43c:	cf 96       	adiw	r24, 0x3f	; 63
     43e:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:733
        }
        return tail - head - 1;
     440:	01 97       	sbiw	r24, 0x01	; 1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:734
      }
     442:	08 95       	ret

00000444 <HardwareSerial::read()>:
read():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:711
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
     444:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:713
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
     446:	97 85       	ldd	r25, Z+15	; 0x0f
     448:	80 89       	ldd	r24, Z+16	; 0x10
     44a:	98 17       	cp	r25, r24
     44c:	61 f0       	breq	.+24     	; 0x466 <HardwareSerial::read()+0x22>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:716
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
     44e:	a0 89       	ldd	r26, Z+16	; 0x10
     450:	ae 0f       	add	r26, r30
     452:	bf 2f       	mov	r27, r31
     454:	b1 1d       	adc	r27, r1
     456:	53 96       	adiw	r26, 0x13	; 19
     458:	8c 91       	ld	r24, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:717
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     45a:	90 89       	ldd	r25, Z+16	; 0x10
     45c:	9f 5f       	subi	r25, 0xFF	; 255
     45e:	9f 73       	andi	r25, 0x3F	; 63
     460:	90 8b       	std	Z+16, r25	; 0x10
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:718
        return c;
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:714
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     466:	8f ef       	ldi	r24, 0xFF	; 255
     468:	9f ef       	ldi	r25, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:720
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
     46a:	08 95       	ret

0000046c <HardwareSerial::peek()>:
peek():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:703

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
     46c:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:704
      if (_rx_buffer_head == _rx_buffer_tail) {
     46e:	97 85       	ldd	r25, Z+15	; 0x0f
     470:	80 89       	ldd	r24, Z+16	; 0x10
     472:	98 17       	cp	r25, r24
     474:	31 f0       	breq	.+12     	; 0x482 <HardwareSerial::peek()+0x16>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:707
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
     476:	80 89       	ldd	r24, Z+16	; 0x10
     478:	e8 0f       	add	r30, r24
     47a:	f1 1d       	adc	r31, r1
     47c:	83 89       	ldd	r24, Z+19	; 0x13
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:705
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     482:	8f ef       	ldi	r24, 0xFF	; 255
     484:	9f ef       	ldi	r25, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:709
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
     486:	08 95       	ret

00000488 <HardwareSerial::available()>:
available():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:699
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
     488:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:700
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
     48a:	97 85       	ldd	r25, Z+15	; 0x0f
     48c:	20 89       	ldd	r18, Z+16	; 0x10
     48e:	89 2f       	mov	r24, r25
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	80 5c       	subi	r24, 0xC0	; 192
     494:	9f 4f       	sbci	r25, 0xFF	; 255
     496:	82 1b       	sub	r24, r18
     498:	91 09       	sbc	r25, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:701
    }
     49a:	8f 73       	andi	r24, 0x3F	; 63
     49c:	99 27       	eor	r25, r25
     49e:	08 95       	ret

000004a0 <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:426
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
     4a0:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:427
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     4a2:	0f b6       	in	r0, 0x3f	; 63
     4a4:	07 fe       	sbrs	r0, 7
     4a6:	04 c0       	rjmp	.+8      	; 0x4b0 <HardwareSerial::_poll_tx_data_empty()+0x10>
     4a8:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7e0111>
     4ac:	88 23       	and	r24, r24
     4ae:	a1 f0       	breq	.+40     	; 0x4d8 <_poll_dre_done>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:444
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     4b0:	a0 85       	ldd	r26, Z+8	; 0x08
     4b2:	b1 85       	ldd	r27, Z+9	; 0x09
     4b4:	14 96       	adiw	r26, 0x04	; 4
     4b6:	8c 91       	ld	r24, X
     4b8:	14 97       	sbiw	r26, 0x04	; 4
     4ba:	85 ff       	sbrs	r24, 5
     4bc:	0d c0       	rjmp	.+26     	; 0x4d8 <_poll_dre_done>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:445
          if (_tx_buffer_head == _tx_buffer_tail) {
     4be:	91 89       	ldd	r25, Z+17	; 0x11
     4c0:	82 89       	ldd	r24, Z+18	; 0x12
     4c2:	98 13       	cpse	r25, r24
     4c4:	07 c0       	rjmp	.+14     	; 0x4d4 <HardwareSerial::_poll_tx_data_empty()+0x34>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:447
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     4c6:	15 96       	adiw	r26, 0x05	; 5
     4c8:	8c 91       	ld	r24, X
     4ca:	15 97       	sbiw	r26, 0x05	; 5
     4cc:	8f 7d       	andi	r24, 0xDF	; 223
     4ce:	15 96       	adiw	r26, 0x05	; 5
     4d0:	8c 93       	st	X, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:465
      #else
                    "rjmp _poll_dre"    "\n\t"
      #endif
                    "_poll_dre_done:"    "\n"
                    ::"z"((uint16_t)thisSerial)
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
     4d2:	08 95       	ret
     4d4:	e8 94       	clt
     4d6:	ea c3       	rjmp	.+2004   	; 0xcac <_poll_dre>

000004d8 <_poll_dre_done>:
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:474
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
     4d8:	08 95       	ret

000004da <HardwareSerial::write(unsigned char)>:
write():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:767
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
     4da:	0f 93       	push	r16
     4dc:	1f 93       	push	r17
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	ec 01       	movw	r28, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:768
        _state |= 1; // Record that we have written to serial since it was begun.
     4e4:	8e 85       	ldd	r24, Y+14	; 0x0e
     4e6:	81 60       	ori	r24, 0x01	; 1
     4e8:	8e 87       	std	Y+14, r24	; 0x0e
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:773
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     4ea:	99 89       	ldd	r25, Y+17	; 0x11
     4ec:	8a 89       	ldd	r24, Y+18	; 0x12
     4ee:	98 13       	cpse	r25, r24
     4f0:	0b c0       	rjmp	.+22     	; 0x508 <HardwareSerial::write(unsigned char)+0x2e>
     4f2:	e8 85       	ldd	r30, Y+8	; 0x08
     4f4:	f9 85       	ldd	r31, Y+9	; 0x09
     4f6:	84 81       	ldd	r24, Z+4	; 0x04
     4f8:	85 ff       	sbrs	r24, 5
     4fa:	06 c0       	rjmp	.+12     	; 0x508 <HardwareSerial::write(unsigned char)+0x2e>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:774
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     4fc:	8e 85       	ldd	r24, Y+14	; 0x0e
     4fe:	81 fd       	sbrc	r24, 1
     500:	0d c0       	rjmp	.+26     	; 0x51c <HardwareSerial::write(unsigned char)+0x42>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:781
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     502:	80 e4       	ldi	r24, 0x40	; 64
     504:	84 83       	std	Z+4, r24	; 0x04
     506:	12 c0       	rjmp	.+36     	; 0x52c <HardwareSerial::write(unsigned char)+0x52>
     508:	06 2f       	mov	r16, r22
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:802
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     50a:	19 89       	ldd	r17, Y+17	; 0x11
     50c:	1f 5f       	subi	r17, 0xFF	; 255
     50e:	1f 73       	andi	r17, 0x3F	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:806

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
     510:	8a 89       	ldd	r24, Y+18	; 0x12
     512:	81 13       	cpse	r24, r17
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:807
          _poll_tx_data_empty();
     514:	15 c0       	rjmp	.+42     	; 0x540 <HardwareSerial::write(unsigned char)+0x66>
     516:	ce 01       	movw	r24, r28
     518:	c3 df       	rcall	.-122    	; 0x4a0 <HardwareSerial::_poll_tx_data_empty()>
     51a:	fa cf       	rjmp	.-12     	; 0x510 <HardwareSerial::write(unsigned char)+0x36>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:775
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
     51c:	85 81       	ldd	r24, Z+5	; 0x05
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:776
            ctrla &= ~USART_RXCIE_bm;
     51e:	8f 77       	andi	r24, 0x7F	; 127
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:777
            ctrla |=  USART_TXCIE_bm;
     520:	80 64       	ori	r24, 0x40	; 64
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:778
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     522:	90 e4       	ldi	r25, 0x40	; 64
     524:	94 83       	std	Z+4, r25	; 0x04
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:779
            (*_hwserial_module).CTRLA = ctrla;
     526:	e8 85       	ldd	r30, Y+8	; 0x08
     528:	f9 85       	ldd	r31, Y+9	; 0x09
     52a:	85 83       	std	Z+5, r24	; 0x05
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:784
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
     52c:	e8 85       	ldd	r30, Y+8	; 0x08
     52e:	f9 85       	ldd	r31, Y+9	; 0x09
     530:	62 83       	std	Z+2, r22	; 0x02
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:822
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	df 91       	pop	r29
     538:	cf 91       	pop	r28
     53a:	1f 91       	pop	r17
     53c:	0f 91       	pop	r16
     53e:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:809
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
     540:	e9 89       	ldd	r30, Y+17	; 0x11
     542:	ec 0f       	add	r30, r28
     544:	fd 2f       	mov	r31, r29
     546:	f1 1d       	adc	r31, r1
     548:	ed 5a       	subi	r30, 0xAD	; 173
     54a:	ff 4f       	sbci	r31, 0xFF	; 255
     54c:	00 83       	st	Z, r16
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:810
        _tx_buffer_head = i;
     54e:	19 8b       	std	Y+17, r17	; 0x11
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:811
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     550:	8e 85       	ldd	r24, Y+14	; 0x0e
     552:	e8 85       	ldd	r30, Y+8	; 0x08
     554:	f9 85       	ldd	r31, Y+9	; 0x09
     556:	81 ff       	sbrs	r24, 1
     558:	09 c0       	rjmp	.+18     	; 0x56c <HardwareSerial::write(unsigned char)+0x92>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:812
          uint8_t ctrla = (*_hwserial_module).CTRLA;
     55a:	85 81       	ldd	r24, Z+5	; 0x05
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:813
          ctrla &= ~USART_RXCIE_bm;
     55c:	8f 77       	andi	r24, 0x7F	; 127
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:814
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     55e:	80 66       	ori	r24, 0x60	; 96
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:815
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
     560:	90 e4       	ldi	r25, 0x40	; 64
     562:	94 83       	std	Z+4, r25	; 0x04
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:816
          (*_hwserial_module).CTRLA = ctrla;
     564:	e8 85       	ldd	r30, Y+8	; 0x08
     566:	f9 85       	ldd	r31, Y+9	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:819
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     568:	85 83       	std	Z+5, r24	; 0x05
     56a:	e3 cf       	rjmp	.-58     	; 0x532 <HardwareSerial::write(unsigned char)+0x58>
     56c:	85 81       	ldd	r24, Z+5	; 0x05
     56e:	80 62       	ori	r24, 0x20	; 32
     570:	fb cf       	rjmp	.-10     	; 0x568 <HardwareSerial::write(unsigned char)+0x8e>

00000572 <HardwareSerial::flush()>:
flush():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:736
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
     572:	cf 93       	push	r28
     574:	df 93       	push	r29
     576:	ec 01       	movw	r28, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:740
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
     578:	8e 85       	ldd	r24, Y+14	; 0x0e
     57a:	88 23       	and	r24, r24
     57c:	59 f0       	breq	.+22     	; 0x594 <HardwareSerial::flush()+0x22>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:755
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     57e:	e8 85       	ldd	r30, Y+8	; 0x08
     580:	f9 85       	ldd	r31, Y+9	; 0x09
     582:	85 81       	ldd	r24, Z+5	; 0x05
     584:	85 fd       	sbrc	r24, 5
     586:	03 c0       	rjmp	.+6      	; 0x58e <HardwareSerial::flush()+0x1c>
     588:	84 81       	ldd	r24, Z+4	; 0x04
     58a:	86 fd       	sbrc	r24, 6
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:760

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
     58c:	03 c0       	rjmp	.+6      	; 0x594 <HardwareSerial::flush()+0x22>
     58e:	ce 01       	movw	r24, r28
     590:	87 df       	rcall	.-242    	; 0x4a0 <HardwareSerial::_poll_tx_data_empty()>
     592:	f5 cf       	rjmp	.-22     	; 0x57e <HardwareSerial::flush()+0xc>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:764
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	08 95       	ret

0000059a <popSleep>:
popSleep():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:678
  #endif
}

void popSleep() {
  #if defined(TWI_USING_WIRE1)
    uint8_t sleepStackLoc = sleepStack;
     59a:	80 91 c7 44 	lds	r24, 0x44C7	; 0x8044c7 <sleepStack>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:679
    if (sleepStackLoc > 0) {      // only do something if sleep was enabled
     59e:	88 23       	and	r24, r24
     5a0:	29 f0       	breq	.+10     	; 0x5ac <popSleep+0x12>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:680
      if (sleepStackLoc > 0x10) {   // only decrement if pushed once before
     5a2:	81 31       	cpi	r24, 0x11	; 17
     5a4:	20 f0       	brcs	.+8      	; 0x5ae <popSleep+0x14>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:681
        sleepStackLoc = (sleepStackLoc - 0x10);   // upper nibble
     5a6:	80 51       	subi	r24, 0x10	; 16
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:686
      } else {                    // at 0 we are about to put sleep back
        SLPCTRL.CTRLA = sleepStackLoc;  // restore sleep
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
     5a8:	80 93 c7 44 	sts	0x44C7, r24	; 0x8044c7 <sleepStack>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:691
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
  #endif
}
     5ac:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:683
    uint8_t sleepStackLoc = sleepStack;
    if (sleepStackLoc > 0) {      // only do something if sleep was enabled
      if (sleepStackLoc > 0x10) {   // only decrement if pushed once before
        sleepStackLoc = (sleepStackLoc - 0x10);   // upper nibble
      } else {                    // at 0 we are about to put sleep back
        SLPCTRL.CTRLA = sleepStackLoc;  // restore sleep
     5ae:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7e0050>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:684
        sleepStackLoc = 0;              // reset everything
     5b2:	80 e0       	ldi	r24, 0x00	; 0
     5b4:	f9 cf       	rjmp	.-14     	; 0x5a8 <popSleep+0xe>

000005b6 <TWI_HandleSlaveIRQ>:
TWI_HandleSlaveIRQ():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:513
 *@param      struct twiData *_data is a pointer to the structure that holds the Wire variables
 *
 *@return     void
 */

void TWI_HandleSlaveIRQ(struct twiData *_data) {
     5b6:	1f 93       	push	r17
     5b8:	cf 93       	push	r28
     5ba:	df 93       	push	r29
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:521
  // used as a frame pointer and the compiler avoids using it. So, using it comes with a price of pushing/popping
  // r28/r29, as well as ldi the address of the struct into those, so it only makes sense in a few cases like this.
  // Since the Y register is not call-clobbered, it can be considered persistent in this function and has not to
  // be restored after the icall to the user callbacks, unlike Z (which is used for _module and icall).

  _fastPtr_y(_data,_data);  // force _data into Y and instruct to not change Y
     5bc:	ec 01       	movw	r28, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:559
      rxBuffer =   _data->_rxBuffer;
    #endif
  #endif

  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
     5be:	9a 81       	ldd	r25, Y+2	; 0x02
     5c0:	91 60       	ori	r25, 0x01	; 1
     5c2:	9a 83       	std	Y+2, r25	; 0x02
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:563
  #endif

  uint8_t action = 0;
  uint8_t clientStatus = _data->_module->SSTATUS;
     5c4:	a8 81       	ld	r26, Y
     5c6:	b9 81       	ldd	r27, Y+1	; 0x01
     5c8:	1b 96       	adiw	r26, 0x0b	; 11
     5ca:	8c 91       	ld	r24, X
     5cc:	1b 97       	sbiw	r26, 0x0b	; 11
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:565

  if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
     5ce:	86 ff       	sbrs	r24, 6
     5d0:	49 c0       	rjmp	.+146    	; 0x664 <TWI_HandleSlaveIRQ+0xae>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:566
    if (clientStatus & TWI_AP_bm) {    // Address bit set
     5d2:	80 ff       	sbrs	r24, 0
     5d4:	39 c0       	rjmp	.+114    	; 0x648 <TWI_HandleSlaveIRQ+0x92>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:567
      uint8_t payload = _data->_module->SDATA;  // read address from data register
     5d6:	1d 96       	adiw	r26, 0x0d	; 13
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:568
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
     5d8:	1c 91       	ld	r17, X
     5da:	81 ff       	sbrs	r24, 1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:569
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
     5dc:	28 c0       	rjmp	.+80     	; 0x62e <TWI_HandleSlaveIRQ+0x78>
     5de:	8a 85       	ldd	r24, Y+10	; 0x0a
     5e0:	88 23       	and	r24, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:570
          popSleep();                           // (have to treat REPSTART as another pop for sleep)
     5e2:	41 f0       	breq	.+16     	; 0x5f4 <TWI_HandleSlaveIRQ+0x3e>
     5e4:	da df       	rcall	.-76     	; 0x59a <popSleep>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:571
          if (_data->user_onReceive != NULL) {  // so when a Master Read occurs after a Master write
     5e6:	ee 85       	ldd	r30, Y+14	; 0x0e
     5e8:	ff 85       	ldd	r31, Y+15	; 0x0f
     5ea:	30 97       	sbiw	r30, 0x00	; 0
     5ec:	19 f0       	breq	.+6      	; 0x5f4 <TWI_HandleSlaveIRQ+0x3e>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:572
            _data->user_onReceive((*rxHead));   // issue a call to the user callback first
     5ee:	8a 85       	ldd	r24, Y+10	; 0x0a
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	09 95       	icall
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:575
          }
        }
        (*address) = payload;                   // saving address to expose to the user sketch
     5f4:	19 87       	std	Y+9, r17	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:576
        (*txHead) = 0;                          // reset buffer positions so the Master can start writing at zero.
     5f6:	1a 86       	std	Y+10, r1	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:577
        (*txTail) = 0;
     5f8:	1b 86       	std	Y+11, r1	; 0x0b
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:579

        if (_data->user_onRequest != NULL) {
     5fa:	ec 85       	ldd	r30, Y+12	; 0x0c
     5fc:	fd 85       	ldd	r31, Y+13	; 0x0d
     5fe:	30 97       	sbiw	r30, 0x00	; 0
     600:	09 f0       	breq	.+2      	; 0x604 <TWI_HandleSlaveIRQ+0x4e>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:580
          _data->user_onRequest();
     602:	09 95       	icall
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:582
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
     604:	8a 85       	ldd	r24, Y+10	; 0x0a
     606:	88 23       	and	r24, r24
     608:	b1 f0       	breq	.+44     	; 0x636 <TWI_HandleSlaveIRQ+0x80>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:588
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
     60a:	83 e0       	ldi	r24, 0x03	; 3
pushSleep():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:662
 *
 *@return     void
 */
void pushSleep() {
  #if defined(TWI_USING_WIRE1)
    uint8_t sleepStackLoc = sleepStack;
     60c:	90 91 c7 44 	lds	r25, 0x44C7	; 0x8044c7 <sleepStack>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:663
    if (sleepStackLoc > 0) {                // Increment only if sleep was enabled
     610:	99 23       	and	r25, r25
     612:	99 f0       	breq	.+38     	; 0x63a <TWI_HandleSlaveIRQ+0x84>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:664
      sleepStackLoc = (sleepStackLoc + 0x10); // use upper nibble to count - max 15 pushes
     614:	90 5f       	subi	r25, 0xF0	; 240
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:669
    } else {
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
    }
    sleepStack = sleepStackLoc;
     616:	90 93 c7 44 	sts	0x44C7, r25	; 0x8044c7 <sleepStack>
TWI_HandleSlaveIRQ():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:638
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
        }
      }
    }
  }
  _data->_module->SCTRLB = action;  // using local variable (register) reduces the amount of loading _module
     61a:	e8 81       	ld	r30, Y
     61c:	f9 81       	ldd	r31, Y+1	; 0x01
     61e:	82 87       	std	Z+10, r24	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:640
  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x00;
     620:	8a 81       	ldd	r24, Y+2	; 0x02
     622:	8e 7f       	andi	r24, 0xFE	; 254
     624:	8a 83       	std	Y+2, r24	; 0x02
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:642
  #endif
}
     626:	df 91       	pop	r29
     628:	cf 91       	pop	r28
     62a:	1f 91       	pop	r17
     62c:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:589
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
        (*address) = payload;           // saving address to expose to the user sketch
     62e:	19 87       	std	Y+9, r17	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:590
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
     630:	1a 86       	std	Y+10, r1	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:591
        (*rxTail) = 0;
     632:	1b 86       	std	Y+11, r1	; 0x0b
     634:	ea cf       	rjmp	.-44     	; 0x60a <TWI_HandleSlaveIRQ+0x54>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:583

        if (_data->user_onRequest != NULL) {
          _data->user_onRequest();
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
     636:	86 e0       	ldi	r24, 0x06	; 6
     638:	e9 cf       	rjmp	.-46     	; 0x60c <TWI_HandleSlaveIRQ+0x56>
pushSleep():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:666
  #if defined(TWI_USING_WIRE1)
    uint8_t sleepStackLoc = sleepStack;
    if (sleepStackLoc > 0) {                // Increment only if sleep was enabled
      sleepStackLoc = (sleepStackLoc + 0x10); // use upper nibble to count - max 15 pushes
    } else {
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
     63a:	90 91 50 00 	lds	r25, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7e0050>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:667
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
     63e:	29 2f       	mov	r18, r25
     640:	21 70       	andi	r18, 0x01	; 1
     642:	20 93 50 00 	sts	0x0050, r18	; 0x800050 <__TEXT_REGION_LENGTH__+0x7e0050>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:595
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
        (*rxTail) = 0;
      }
      pushSleep();
    } else {                            // Stop bit set
      popSleep();
     646:	e7 cf       	rjmp	.-50     	; 0x616 <TWI_HandleSlaveIRQ+0x60>
TWI_HandleSlaveIRQ():
     648:	a8 df       	rcall	.-176    	; 0x59a <popSleep>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:596
      if (_data->user_onReceive != NULL) {
     64a:	ee 85       	ldd	r30, Y+14	; 0x0e
     64c:	ff 85       	ldd	r31, Y+15	; 0x0f
     64e:	30 97       	sbiw	r30, 0x00	; 0
     650:	29 f0       	breq	.+10     	; 0x65c <TWI_HandleSlaveIRQ+0xa6>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:597
        if ((*rxHead) > 0) {
     652:	8a 85       	ldd	r24, Y+10	; 0x0a
     654:	88 23       	and	r24, r24
     656:	11 f0       	breq	.+4      	; 0x65c <TWI_HandleSlaveIRQ+0xa6>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:598
          _data->user_onReceive((*rxHead));
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	09 95       	icall
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:602
        }
      }
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
      (*rxHead) = 0;
     65c:	1a 86       	std	Y+10, r1	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:604
      (*txHead) = 0;
      (*rxTail) = 0;
     65e:	1b 86       	std	Y+11, r1	; 0x0b
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:622
        if ((*txTail) < (*txHead)) {            // Data is available
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
          (*txTail)++;                            // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute a byte read operation followed by Acknowledge Action"
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
     660:	82 e0       	ldi	r24, 0x02	; 2
     662:	db cf       	rjmp	.-74     	; 0x61a <TWI_HandleSlaveIRQ+0x64>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:607
      (*rxHead) = 0;
      (*txHead) = 0;
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
     664:	87 ff       	sbrs	r24, 7
     666:	32 c0       	rjmp	.+100    	; 0x6cc <TWI_HandleSlaveIRQ+0x116>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:533
    txTail  = &(_data->_bytesReadWrittenS);

    rxHead   = &(_data->_bytesToReadWriteS);
    rxTail   = &(_data->_bytesReadWrittenS);

    txBuffer =   _data->_trBufferS;
     668:	9e 01       	movw	r18, r28
     66a:	2c 5e       	subi	r18, 0xEC	; 236
     66c:	3e 4f       	sbci	r19, 0xFE	; 254
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:608
      (*txHead) = 0;
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
     66e:	81 ff       	sbrs	r24, 1
     670:	1d c0       	rjmp	.+58     	; 0x6ac <TWI_HandleSlaveIRQ+0xf6>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:609
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
     672:	88 71       	andi	r24, 0x18	; 24
     674:	31 f0       	breq	.+12     	; 0x682 <TWI_HandleSlaveIRQ+0xcc>
     676:	93 ff       	sbrs	r25, 3
     678:	04 c0       	rjmp	.+8      	; 0x682 <TWI_HandleSlaveIRQ+0xcc>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:611
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
        (*txHead) = 0;                          // Abort further data writes
     67a:	1a 86       	std	Y+10, r1	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:612
        _data->_bools._ackMatters = false;      // stop checking for NACK
     67c:	97 7f       	andi	r25, 0xF7	; 247
     67e:	9a 83       	std	Y+2, r25	; 0x02
     680:	ef cf       	rjmp	.-34     	; 0x660 <TWI_HandleSlaveIRQ+0xaa>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:615
        action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
      } else {                                // RXACK bit not set, no COLL
        _data->_bytesTransmittedS++;            // increment bytes transmitted counter (for register model)
     682:	8b 81       	ldd	r24, Y+3	; 0x03
     684:	8f 5f       	subi	r24, 0xFF	; 255
     686:	8b 83       	std	Y+3, r24	; 0x03
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:616
        _data->_bools._ackMatters = true;       // start checking for NACK
     688:	8a 81       	ldd	r24, Y+2	; 0x02
     68a:	88 60       	ori	r24, 0x08	; 8
     68c:	8a 83       	std	Y+2, r24	; 0x02
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:617
        if ((*txTail) < (*txHead)) {            // Data is available
     68e:	eb 85       	ldd	r30, Y+11	; 0x0b
     690:	8a 85       	ldd	r24, Y+10	; 0x0a
     692:	e8 17       	cp	r30, r24
     694:	28 f7       	brcc	.-54     	; 0x660 <TWI_HandleSlaveIRQ+0xaa>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:618
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
     696:	e2 0f       	add	r30, r18
     698:	f3 2f       	mov	r31, r19
     69a:	f1 1d       	adc	r31, r1
     69c:	80 81       	ld	r24, Z
     69e:	1d 96       	adiw	r26, 0x0d	; 13
     6a0:	8c 93       	st	X, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:619
          (*txTail)++;                            // Increment counter for sent bytes
     6a2:	8b 85       	ldd	r24, Y+11	; 0x0b
     6a4:	8f 5f       	subi	r24, 0xFF	; 255
     6a6:	8b 87       	std	Y+11, r24	; 0x0b
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:631
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
        rxBuffer[(*rxHead)] = payload;              // save data
        (*rxHead)++;                                  // Advance Head
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
     6a8:	83 e0       	ldi	r24, 0x03	; 3
     6aa:	b7 cf       	rjmp	.-146    	; 0x61a <TWI_HandleSlaveIRQ+0x64>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:626
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
        }
      }
    } else {                                  // Master is writing
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
     6ac:	1d 96       	adiw	r26, 0x0d	; 13
     6ae:	8c 91       	ld	r24, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:627
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
     6b0:	ea 85       	ldd	r30, Y+10	; 0x0a
     6b2:	e2 38       	cpi	r30, 0x82	; 130
     6b4:	58 f4       	brcc	.+22     	; 0x6cc <TWI_HandleSlaveIRQ+0x116>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:628
        rxBuffer[(*rxHead)] = payload;              // save data
     6b6:	e2 0f       	add	r30, r18
     6b8:	f3 2f       	mov	r31, r19
     6ba:	f1 1d       	adc	r31, r1
     6bc:	80 83       	st	Z, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:629
        (*rxHead)++;                                  // Advance Head
     6be:	8a 85       	ldd	r24, Y+10	; 0x0a
     6c0:	8f 5f       	subi	r24, 0xFF	; 255
     6c2:	8a 87       	std	Y+10, r24	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:630
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
     6c4:	82 38       	cpi	r24, 0x82	; 130
     6c6:	80 f3       	brcs	.-32     	; 0x6a8 <TWI_HandleSlaveIRQ+0xf2>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:633
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                      // else buffer would overflow with next byte
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
     6c8:	86 e0       	ldi	r24, 0x06	; 6
     6ca:	a7 cf       	rjmp	.-178    	; 0x61a <TWI_HandleSlaveIRQ+0x64>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:562

  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	a5 cf       	rjmp	.-182    	; 0x61a <TWI_HandleSlaveIRQ+0x64>

000006d0 <TwoWire::flush()>:
TWI_Flush():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:130
 */
void TWI_Flush(struct twiData *_data) {
  #if defined(ERRATA_TWI_FLUSH)
    // badCall("The AVR DA-series parts are impacted by an errata that leaves the TWI peripheral in a non-functioning state when using flush.");
    // restarting TWI hardware by hand. Extra size shouldn't matter on DA series
    uint8_t temp_MCTRLA     = _data->_module->MCTRLA;
     6d0:	dc 01       	movw	r26, r24
     6d2:	18 96       	adiw	r26, 0x08	; 8
     6d4:	ed 91       	ld	r30, X+
     6d6:	fc 91       	ld	r31, X
     6d8:	93 81       	ldd	r25, Z+3	; 0x03
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:131
    uint8_t temp_SCTRLA     = _data->_module->SCTRLA;
     6da:	81 85       	ldd	r24, Z+9	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:132
    _data->_module->MCTRLA  = 0x00;
     6dc:	13 82       	std	Z+3, r1	; 0x03
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:133
    _data->_module->SCTRLA  = 0x00;
     6de:	11 86       	std	Z+9, r1	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:134
    _data->_module->MCTRLA  = temp_MCTRLA;
     6e0:	93 83       	std	Z+3, r25	; 0x03
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:135
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
     6e2:	91 e0       	ldi	r25, 0x01	; 1
     6e4:	95 83       	std	Z+5, r25	; 0x05
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/twi.c:136
    _data->_module->SCTRLA  = temp_SCTRLA;
     6e6:	81 87       	std	Z+9, r24	; 0x09
flush():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:748
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
     6e8:	08 95       	ret

000006ea <TwoWire::peek()>:
peek():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:708
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::peek(void) {
     6ea:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:712
  uint8_t *rxBuffer;
  twi_buffer_index_t *rxHead, *rxTail;
  #if defined(TWI_MANDS)                         // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
     6ec:	82 85       	ldd	r24, Z+10	; 0x0a
     6ee:	80 ff       	sbrs	r24, 0
     6f0:	0d c0       	rjmp	.+26     	; 0x70c <TwoWire::peek()+0x22>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:715
      rxHead   = &(vars._bytesToReadWriteS);
      rxTail   = &(vars._bytesReadWrittenS);
      rxBuffer =   vars._trBufferS;
     6f2:	cf 01       	movw	r24, r30
     6f4:	84 5e       	subi	r24, 0xE4	; 228
     6f6:	9e 4f       	sbci	r25, 0xFE	; 254
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:713
int TwoWire::peek(void) {
  uint8_t *rxBuffer;
  twi_buffer_index_t *rxHead, *rxTail;
  #if defined(TWI_MANDS)                         // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
      rxHead   = &(vars._bytesToReadWriteS);
     6f8:	22 89       	ldd	r18, Z+18	; 0x12
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:714
      rxTail   = &(vars._bytesReadWrittenS);
     6fa:	e3 89       	ldd	r30, Z+19	; 0x13
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:730
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     6fc:	e2 17       	cp	r30, r18
     6fe:	60 f4       	brcc	.+24     	; 0x718 <TwoWire::peek()+0x2e>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:731
    return rxBuffer[(*rxTail)];
     700:	e8 0f       	add	r30, r24
     702:	f9 2f       	mov	r31, r25
     704:	f1 1d       	adc	r31, r1
     706:	80 81       	ld	r24, Z
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:726
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     70c:	cf 01       	movw	r24, r30
     70e:	86 56       	subi	r24, 0x66	; 102
     710:	9f 4f       	sbci	r25, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:724
    #if defined(TWI_MERGE_BUFFERS)               // Same Buffers for tx/rx
      rxHead   = &(vars._bytesToReadWrite);
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
     712:	26 85       	ldd	r18, Z+14	; 0x0e
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:725
      rxTail   = &(vars._bytesRead);
     714:	e7 85       	ldd	r30, Z+15	; 0x0f
     716:	f2 cf       	rjmp	.-28     	; 0x6fc <TwoWire::peek()+0x12>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:733
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
    return rxBuffer[(*rxTail)];
  } else {      // No bytes to read
    return -1;
     718:	8f ef       	ldi	r24, 0xFF	; 255
     71a:	9f ef       	ldi	r25, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:735
  }
}
     71c:	08 95       	ret

0000071e <TwoWire::read()>:
read():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:635
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
     71e:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:639
  uint8_t *rxBuffer;
  twi_buffer_index_t *rxHead, *rxTail;
  #if defined(TWI_MANDS)                         // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
     720:	82 85       	ldd	r24, Z+10	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:641
      rxHead   = &(vars._bytesToReadWriteS);
      rxTail   = &(vars._bytesReadWrittenS);
     722:	df 01       	movw	r26, r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:639
 */
int TwoWire::read(void) {
  uint8_t *rxBuffer;
  twi_buffer_index_t *rxHead, *rxTail;
  #if defined(TWI_MANDS)                         // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
     724:	80 ff       	sbrs	r24, 0
     726:	10 c0       	rjmp	.+32     	; 0x748 <TwoWire::read()+0x2a>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:641
      rxHead   = &(vars._bytesToReadWriteS);
      rxTail   = &(vars._bytesReadWrittenS);
     728:	53 96       	adiw	r26, 0x13	; 19
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:642
      rxBuffer =   vars._trBufferS;
     72a:	9f 01       	movw	r18, r30
     72c:	24 5e       	subi	r18, 0xE4	; 228
     72e:	3e 4f       	sbci	r19, 0xFE	; 254
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:640
int TwoWire::read(void) {
  uint8_t *rxBuffer;
  twi_buffer_index_t *rxHead, *rxTail;
  #if defined(TWI_MANDS)                         // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
      rxHead   = &(vars._bytesToReadWriteS);
     730:	82 89       	ldd	r24, Z+18	; 0x12
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:641
      rxTail   = &(vars._bytesReadWrittenS);
     732:	93 89       	ldd	r25, Z+19	; 0x13
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:658
      rxBuffer =   vars._rxBuffer;
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     734:	98 17       	cp	r25, r24
     736:	78 f4       	brcc	.+30     	; 0x756 <TwoWire::read()+0x38>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:659
    uint8_t c = rxBuffer[(*rxTail)];
     738:	29 0f       	add	r18, r25
     73a:	31 1d       	adc	r19, r1
     73c:	f9 01       	movw	r30, r18
     73e:	80 81       	ld	r24, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:660
    (*rxTail)++;
     740:	9f 5f       	subi	r25, 0xFF	; 255
     742:	9c 93       	st	X, r25
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:661
    return c;
     744:	90 e0       	ldi	r25, 0x00	; 0
     746:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:652
      rxHead   = &(vars._bytesToReadWrite);
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
     748:	1f 96       	adiw	r26, 0x0f	; 15
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:653
      rxBuffer =   vars._rxBuffer;
     74a:	9f 01       	movw	r18, r30
     74c:	26 56       	subi	r18, 0x66	; 102
     74e:	3f 4f       	sbci	r19, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:651
    #if defined(TWI_MERGE_BUFFERS)               // Same Buffers for tx/rx
      rxHead   = &(vars._bytesToReadWrite);
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
     750:	86 85       	ldd	r24, Z+14	; 0x0e
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:652
      rxTail   = &(vars._bytesRead);
     752:	97 85       	ldd	r25, Z+15	; 0x0f
     754:	ef cf       	rjmp	.-34     	; 0x734 <TwoWire::read()+0x16>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:663
  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
    uint8_t c = rxBuffer[(*rxTail)];
    (*rxTail)++;
    return c;
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
     756:	8f ef       	ldi	r24, 0xFF	; 255
     758:	9f ef       	ldi	r25, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:665
  }
}
     75a:	08 95       	ret

0000075c <TwoWire::available()>:
available():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:603
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
     75c:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:606
  int rxHead;
  #if defined(TWI_MANDS)                          // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
     75e:	82 85       	ldd	r24, Z+10	; 0x0a
     760:	80 ff       	sbrs	r24, 0
     762:	07 c0       	rjmp	.+14     	; 0x772 <TwoWire::available()+0x16>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:607
      rxHead  = vars._bytesToReadWriteS - vars._bytesReadWrittenS;
     764:	92 89       	ldd	r25, Z+18	; 0x12
     766:	83 89       	ldd	r24, Z+19	; 0x13
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:614
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
     768:	29 2f       	mov	r18, r25
     76a:	28 1b       	sub	r18, r24
     76c:	33 0b       	sbc	r19, r19
     76e:	c9 01       	movw	r24, r18
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:618
    #endif
  }
  return rxHead;
}
     770:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:614
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
     772:	96 85       	ldd	r25, Z+14	; 0x0e
     774:	87 85       	ldd	r24, Z+15	; 0x0f
     776:	f8 cf       	rjmp	.-16     	; 0x768 <TwoWire::available()+0xc>

00000778 <TwoWire::write(unsigned char)>:
write():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:536
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
     778:	fc 01       	movw	r30, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:540
  uint8_t* txBuffer;
  twi_buffer_index_t *txHead;
  #if defined(TWI_MANDS)                   // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
     77a:	82 85       	ldd	r24, Z+10	; 0x0a
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:541
      txHead   = &(vars._bytesToReadWriteS);
     77c:	df 01       	movw	r26, r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:540
 */
size_t TwoWire::write(uint8_t data) {
  uint8_t* txBuffer;
  twi_buffer_index_t *txHead;
  #if defined(TWI_MANDS)                   // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
     77e:	80 ff       	sbrs	r24, 0
     780:	11 c0       	rjmp	.+34     	; 0x7a4 <TwoWire::write(unsigned char)+0x2c>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:541
      txHead   = &(vars._bytesToReadWriteS);
     782:	52 96       	adiw	r26, 0x12	; 18
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:542
      txBuffer =   vars._trBufferS;
     784:	cf 01       	movw	r24, r30
     786:	84 5e       	subi	r24, 0xE4	; 228
     788:	9e 4f       	sbci	r25, 0xFE	; 254
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:541
size_t TwoWire::write(uint8_t data) {
  uint8_t* txBuffer;
  twi_buffer_index_t *txHead;
  #if defined(TWI_MANDS)                   // Add following if host and client are split
    if (vars._bools._toggleStreamFn == 0x01) {
      txHead   = &(vars._bytesToReadWriteS);
     78a:	e2 89       	ldd	r30, Z+18	; 0x12
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:557
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
     78c:	e2 38       	cpi	r30, 0x82	; 130
     78e:	78 f4       	brcc	.+30     	; 0x7ae <TwoWire::write(unsigned char)+0x36>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:558
    txBuffer[(*txHead)] = data;             // Load data into the buffer
     790:	e8 0f       	add	r30, r24
     792:	f9 2f       	mov	r31, r25
     794:	f1 1d       	adc	r31, r1
     796:	60 83       	st	Z, r22
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:559
    (*txHead)++;                            // advancing the head
     798:	8c 91       	ld	r24, X
     79a:	8f 5f       	subi	r24, 0xFF	; 255
     79c:	8c 93       	st	X, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:560
    return 1;
     79e:	81 e0       	ldi	r24, 0x01	; 1
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:550
  {
    #if defined(TWI_MERGE_BUFFERS)         // Same Buffers for tx/rx
      txHead   = &(vars._bytesToReadWrite);
      txBuffer =   vars._trBuffer;
    #else                                  // Separate tx/rx Buffers
      txHead   = &(vars._bytesToWrite);
     7a4:	1d 96       	adiw	r26, 0x0d	; 13
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:551
      txBuffer =   vars._txBuffer;
     7a6:	cf 01       	movw	r24, r30
     7a8:	48 96       	adiw	r24, 0x18	; 24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:550
  {
    #if defined(TWI_MERGE_BUFFERS)         // Same Buffers for tx/rx
      txHead   = &(vars._bytesToReadWrite);
      txBuffer =   vars._trBuffer;
    #else                                  // Separate tx/rx Buffers
      txHead   = &(vars._bytesToWrite);
     7aa:	e5 85       	ldd	r30, Z+13	; 0x0d
     7ac:	ef cf       	rjmp	.-34     	; 0x78c <TwoWire::write(unsigned char)+0x14>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:562
  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
    txBuffer[(*txHead)] = data;             // Load data into the buffer
    (*txHead)++;                            // advancing the head
    return 1;
  } else {
    return 0;
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	80 e0       	ldi	r24, 0x00	; 0
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:564
  }
}
     7b2:	08 95       	ret

000007b4 <TwoWire::write(unsigned char const*, unsigned int)>:
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:579
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     7b4:	bf 92       	push	r11
     7b6:	cf 92       	push	r12
     7b8:	df 92       	push	r13
     7ba:	ef 92       	push	r14
     7bc:	ff 92       	push	r15
     7be:	0f 93       	push	r16
     7c0:	1f 93       	push	r17
     7c2:	cf 93       	push	r28
     7c4:	df 93       	push	r29
     7c6:	7c 01       	movw	r14, r24
     7c8:	6a 01       	movw	r12, r20
     7ca:	b6 2e       	mov	r11, r22
     7cc:	eb 01       	movw	r28, r22
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:581
  twi_buffer_index_t i = 0;
  for (; i < quantity; i++) {
     7ce:	0c 2f       	mov	r16, r28
     7d0:	0b 19       	sub	r16, r11
     7d2:	10 e0       	ldi	r17, 0x00	; 0
     7d4:	0c 15       	cp	r16, r12
     7d6:	1d 05       	cpc	r17, r13
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:582
    if (TwoWire::write(*(data++)) == 0)
     7d8:	28 f4       	brcc	.+10     	; 0x7e4 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
     7da:	69 91       	ld	r22, Y+
     7dc:	c7 01       	movw	r24, r14
     7de:	cc df       	rcall	.-104    	; 0x778 <TwoWire::write(unsigned char)>
     7e0:	89 2b       	or	r24, r25
     7e2:	a9 f7       	brne	.-22     	; 0x7ce <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:587
      break;   // break if buffer full
  }

  return i;
}
     7e4:	c8 01       	movw	r24, r16
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	1f 91       	pop	r17
     7ec:	0f 91       	pop	r16
     7ee:	ff 90       	pop	r15
     7f0:	ef 90       	pop	r14
     7f2:	df 90       	pop	r13
     7f4:	cf 90       	pop	r12
     7f6:	bf 90       	pop	r11
     7f8:	08 95       	ret

000007fa <Print::availableForWrite()>:
availableForWrite():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	80 e0       	ldi	r24, 0x00	; 0
     7fe:	08 95       	ret

00000800 <Print::printf(char const*, ...) [clone .constprop.28]>:
printf():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:193
static int16_t printf_putchar(char c, FILE *fp) {
  ((class Print *)(fdev_get_udata(fp)))->write((uint8_t)c);
  return 0;
}

int16_t Print::printf(const char *format, ...) {
     800:	cf 93       	push	r28
     802:	df 93       	push	r29
     804:	cd b7       	in	r28, 0x3d	; 61
     806:	de b7       	in	r29, 0x3e	; 62
     808:	2e 97       	sbiw	r28, 0x0e	; 14
     80a:	cd bf       	out	0x3d, r28	; 61
     80c:	de bf       	out	0x3e, r29	; 62
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:197
  FILE f;
  va_list ap;

  fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
     80e:	88 e4       	ldi	r24, 0x48	; 72
     810:	91 e0       	ldi	r25, 0x01	; 1
     812:	89 87       	std	Y+9, r24	; 0x09
     814:	9a 87       	std	Y+10, r25	; 0x0a
     816:	1b 86       	std	Y+11, r1	; 0x0b
     818:	1c 86       	std	Y+12, r1	; 0x0c
     81a:	82 e0       	ldi	r24, 0x02	; 2
     81c:	8c 83       	std	Y+4, r24	; 0x04
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:198
  fdev_set_udata(&f, this);
     81e:	8b 89       	ldd	r24, Y+19	; 0x13
     820:	9c 89       	ldd	r25, Y+20	; 0x14
     822:	8d 87       	std	Y+13, r24	; 0x0d
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:200
  va_start(ap, format);
  return vfprintf(&f, format, ap);
     824:	9e 87       	std	Y+14, r25	; 0x0e
     826:	ae 01       	movw	r20, r28
     828:	49 5e       	subi	r20, 0xE9	; 233
     82a:	5f 4f       	sbci	r21, 0xFF	; 255
     82c:	6e ed       	ldi	r22, 0xDE	; 222
     82e:	70 e4       	ldi	r23, 0x40	; 64
     830:	ce 01       	movw	r24, r28
     832:	01 96       	adiw	r24, 0x01	; 1
     834:	d5 d4       	rcall	.+2474   	; 0x11e0 <vfprintf>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/Print.cpp:201
}
     836:	2e 96       	adiw	r28, 0x0e	; 14
     838:	cd bf       	out	0x3d, r28	; 61
     83a:	de bf       	out	0x3e, r29	; 62
     83c:	df 91       	pop	r29
     83e:	cf 91       	pop	r28
     840:	08 95       	ret

00000842 <LogClass::info(char const*) [clone .constprop.26]>:
info():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:71
void LogClass::begin(const uint32_t baud_rate) { this->uart->begin(baud_rate); }

void LogClass::end(void) { this->uart->end(); }

void LogClass::info(const char str[]) {
    if (log_level >= LogLevel::INFO) {
     842:	20 91 c6 48 	lds	r18, 0x48C6	; 0x8048c6 <Log+0x2>
     846:	30 91 c7 48 	lds	r19, 0x48C7	; 0x8048c7 <Log+0x3>
     84a:	23 30       	cpi	r18, 0x03	; 3
     84c:	31 05       	cpc	r19, r1
     84e:	b4 f0       	brlt	.+44     	; 0x87c <LogClass::info(char const*) [clone .constprop.26]+0x3a>
print():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:30
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
    return 0;
}

void LogClass::print(const char* str, const char level[]) {
    this->uart->printf("%s%s\r\n", level, str);
     850:	9f 93       	push	r25
     852:	8f 93       	push	r24
     854:	85 ee       	ldi	r24, 0xE5	; 229
     856:	90 e4       	ldi	r25, 0x40	; 64
     858:	9f 93       	push	r25
     85a:	8f 93       	push	r24
     85c:	8e ed       	ldi	r24, 0xDE	; 222
     85e:	90 e4       	ldi	r25, 0x40	; 64
     860:	9f 93       	push	r25
     862:	8f 93       	push	r24
     864:	80 91 c5 48 	lds	r24, 0x48C5	; 0x8048c5 <Log+0x1>
     868:	8f 93       	push	r24
     86a:	80 91 c4 48 	lds	r24, 0x48C4	; 0x8048c4 <Log>
     86e:	8f 93       	push	r24
     870:	c7 df       	rcall	.-114    	; 0x800 <Print::printf(char const*, ...) [clone .constprop.28]>
     872:	8d b7       	in	r24, 0x3d	; 61
     874:	9e b7       	in	r25, 0x3e	; 62
     876:	08 96       	adiw	r24, 0x08	; 8
     878:	8d bf       	out	0x3d, r24	; 61
     87a:	9e bf       	out	0x3e, r25	; 62
info():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:74

void LogClass::info(const char str[]) {
    if (log_level >= LogLevel::INFO) {
        this->print(str, INFO_LEVEL_FMT);
    }
}
     87c:	08 95       	ret

0000087e <LogClass::errorf(char const*, ...) [clone .constprop.25]>:
errorf():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:147
    }
}

void LogClass::error(const String str) { this->error(str.c_str()); }

void LogClass::errorf(const char* format, ...) {
     87e:	cf 92       	push	r12
     880:	df 92       	push	r13
     882:	ef 92       	push	r14
     884:	ff 92       	push	r15
     886:	0f 93       	push	r16
     888:	1f 93       	push	r17
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
     892:	2e 97       	sbiw	r28, 0x0e	; 14
     894:	cd bf       	out	0x3d, r28	; 61
     896:	de bf       	out	0x3e, r29	; 62
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:163
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    }
}
     898:	ed b6       	in	r14, 0x3d	; 61
     89a:	fe b6       	in	r15, 0x3e	; 62
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:148
}

void LogClass::error(const String str) { this->error(str.c_str()); }

void LogClass::errorf(const char* format, ...) {
    if (log_level >= LogLevel::ERROR) {
     89c:	80 91 c6 48 	lds	r24, 0x48C6	; 0x8048c6 <Log+0x2>
     8a0:	90 91 c7 48 	lds	r25, 0x48C7	; 0x8048c7 <Log+0x3>
     8a4:	18 16       	cp	r1, r24
     8a6:	19 06       	cpc	r1, r25
     8a8:	d4 f5       	brge	.+116    	; 0x91e <LogClass::errorf(char const*, ...) [clone .constprop.25]+0xa0>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:161

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
     8aa:	cd b6       	in	r12, 0x3d	; 61
     8ac:	de b6       	in	r13, 0x3e	; 62
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:151

void LogClass::errorf(const char* format, ...) {
    if (log_level >= LogLevel::ERROR) {

        // Append format with [ERROR]
        char nFormat[strlen(format) + sizeof(ERR_LEVEL_FMT)] = ERR_LEVEL_FMT;
     8ae:	8d b7       	in	r24, 0x3d	; 61
     8b0:	9e b7       	in	r25, 0x3e	; 62
     8b2:	8e 97       	sbiw	r24, 0x2e	; 46
     8b4:	8d bf       	out	0x3d, r24	; 61
     8b6:	9e bf       	out	0x3e, r25	; 62
     8b8:	0d b7       	in	r16, 0x3d	; 61
     8ba:	1e b7       	in	r17, 0x3e	; 62
     8bc:	0f 5f       	subi	r16, 0xFF	; 255
     8be:	1f 4f       	sbci	r17, 0xFF	; 255
     8c0:	89 e0       	ldi	r24, 0x09	; 9
     8c2:	e3 e1       	ldi	r30, 0x13	; 19
     8c4:	f1 e4       	ldi	r31, 0x41	; 65
     8c6:	d8 01       	movw	r26, r16
     8c8:	01 90       	ld	r0, Z+
     8ca:	0d 92       	st	X+, r0
     8cc:	8a 95       	dec	r24
     8ce:	e1 f7       	brne	.-8      	; 0x8c8 <LogClass::errorf(char const*, ...) [clone .constprop.25]+0x4a>
     8d0:	ed b7       	in	r30, 0x3d	; 61
     8d2:	fe b7       	in	r31, 0x3e	; 62
     8d4:	3a 96       	adiw	r30, 0x0a	; 10
     8d6:	8d b7       	in	r24, 0x3d	; 61
     8d8:	9e b7       	in	r25, 0x3e	; 62
     8da:	8f 96       	adiw	r24, 0x2f	; 47
     8dc:	11 92       	st	Z+, r1
     8de:	8e 17       	cp	r24, r30
     8e0:	9f 07       	cpc	r25, r31
     8e2:	e1 f7       	brne	.-8      	; 0x8dc <LogClass::errorf(char const*, ...) [clone .constprop.25]+0x5e>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:152
        strcpy(nFormat + sizeof(ERR_LEVEL_FMT) - 1, format);
     8e4:	6d ee       	ldi	r22, 0xED	; 237
     8e6:	70 e4       	ldi	r23, 0x40	; 64
     8e8:	c8 01       	movw	r24, r16
     8ea:	08 96       	adiw	r24, 0x08	; 8
     8ec:	0e 94 90 12 	call	0x2520	; 0x2520 <strcpy>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:157

        FILE f;
        va_list ap;

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
     8f0:	89 e3       	ldi	r24, 0x39	; 57
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	89 87       	std	Y+9, r24	; 0x09
     8f6:	9a 87       	std	Y+10, r25	; 0x0a
     8f8:	1b 86       	std	Y+11, r1	; 0x0b
     8fa:	1c 86       	std	Y+12, r1	; 0x0c
     8fc:	82 e0       	ldi	r24, 0x02	; 2
     8fe:	8c 83       	std	Y+4, r24	; 0x04
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:158
        fdev_set_udata(&f, this->uart);
     900:	80 91 c4 48 	lds	r24, 0x48C4	; 0x8048c4 <Log>
     904:	90 91 c5 48 	lds	r25, 0x48C5	; 0x8048c5 <Log+0x1>
     908:	8d 87       	std	Y+13, r24	; 0x0d
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:160
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
     90a:	9e 87       	std	Y+14, r25	; 0x0e
     90c:	ae 01       	movw	r20, r28
     90e:	43 5e       	subi	r20, 0xE3	; 227
     910:	5f 4f       	sbci	r21, 0xFF	; 255
     912:	b8 01       	movw	r22, r16
     914:	ce 01       	movw	r24, r28
     916:	01 96       	adiw	r24, 0x01	; 1
     918:	63 d4       	rcall	.+2246   	; 0x11e0 <vfprintf>
     91a:	cd be       	out	0x3d, r12	; 61
     91c:	de be       	out	0x3e, r13	; 62
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:163
        va_end(ap);
    }
}
     91e:	ed be       	out	0x3d, r14	; 61
     920:	fe be       	out	0x3e, r15	; 62
     922:	2e 96       	adiw	r28, 0x0e	; 14
     924:	cd bf       	out	0x3d, r28	; 61
     926:	de bf       	out	0x3e, r29	; 62
     928:	df 91       	pop	r29
     92a:	cf 91       	pop	r28
     92c:	1f 91       	pop	r17
     92e:	0f 91       	pop	r16
     930:	ff 90       	pop	r15
     932:	ef 90       	pop	r14
     934:	df 90       	pop	r13
     936:	cf 90       	pop	r12
     938:	08 95       	ret

0000093a <LedCtrlClass::getLedPin(Led) [clone .constprop.24]>:
getLedPin():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:49
    this->begin();
}

uint8_t LedCtrlClass::getLedPin(Led led) {
    uint8_t targetPin = 0;
    switch (led) {
     93a:	82 30       	cpi	r24, 0x02	; 2
     93c:	91 05       	cpc	r25, r1
     93e:	19 f1       	breq	.+70     	; 0x986 <LedCtrlClass::getLedPin(Led) [clone .constprop.24]+0x4c>
     940:	c4 f4       	brge	.+48     	; 0x972 <LedCtrlClass::getLedPin(Led) [clone .constprop.24]+0x38>
     942:	00 97       	sbiw	r24, 0x00	; 0
     944:	21 f1       	breq	.+72     	; 0x98e <LedCtrlClass::getLedPin(Led) [clone .constprop.24]+0x54>
     946:	81 30       	cpi	r24, 0x01	; 1
     948:	91 05       	cpc	r25, r1
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:66
        break;
    case Led::USER:
        targetPin = LED_USER_PIN;
        break;
    default:
        Log.errorf("attempted to get invalid led pin %d\r\n", led);
     94a:	d9 f0       	breq	.+54     	; 0x982 <LedCtrlClass::getLedPin(Led) [clone .constprop.24]+0x48>
     94c:	9f 93       	push	r25
     94e:	8f 93       	push	r24
     950:	8d ee       	ldi	r24, 0xED	; 237
     952:	90 e4       	ldi	r25, 0x40	; 64
     954:	9f 93       	push	r25
     956:	8f 93       	push	r24
     958:	84 ec       	ldi	r24, 0xC4	; 196
     95a:	98 e4       	ldi	r25, 0x48	; 72
     95c:	9f 93       	push	r25
     95e:	8f 93       	push	r24
     960:	8e df       	rcall	.-228    	; 0x87e <LogClass::errorf(char const*, ...) [clone .constprop.25]>
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	0f 90       	pop	r0
     968:	0f 90       	pop	r0
     96a:	0f 90       	pop	r0
     96c:	0f 90       	pop	r0
     96e:	88 ec       	ldi	r24, 0xC8	; 200
     970:	08 95       	ret
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:49
    this->begin();
}

uint8_t LedCtrlClass::getLedPin(Led led) {
    uint8_t targetPin = 0;
    switch (led) {
     972:	83 30       	cpi	r24, 0x03	; 3
     974:	91 05       	cpc	r25, r1
     976:	49 f0       	breq	.+18     	; 0x98a <LedCtrlClass::getLedPin(Led) [clone .constprop.24]+0x50>
     978:	84 30       	cpi	r24, 0x04	; 4
     97a:	91 05       	cpc	r25, r1
     97c:	39 f7       	brne	.-50     	; 0x94c <LedCtrlClass::getLedPin(Led) [clone .constprop.24]+0x12>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:63
        break;
    case Led::ERROR:
        targetPin = LED_ERROR_PIN;
        break;
    case Led::USER:
        targetPin = LED_USER_PIN;
     97e:	8a e0       	ldi	r24, 0x0A	; 10
     980:	08 95       	ret
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:54
    switch (led) {
    case Led::CELL:
        targetPin = LED_CELL_PIN;
        break;
    case Led::CON:
        targetPin = LED_CON_PIN;
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	08 95       	ret
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:57
        break;
    case Led::DATA:
        targetPin = LED_DATA_PIN;
     986:	82 e0       	ldi	r24, 0x02	; 2
     988:	08 95       	ret
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:60
        break;
    case Led::ERROR:
        targetPin = LED_ERROR_PIN;
     98a:	83 e0       	ldi	r24, 0x03	; 3
     98c:	08 95       	ret
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:51

uint8_t LedCtrlClass::getLedPin(Led led) {
    uint8_t targetPin = 0;
    switch (led) {
    case Led::CELL:
        targetPin = LED_CELL_PIN;
     98e:	80 e0       	ldi	r24, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:71
        Log.errorf("attempted to get invalid led pin %d\r\n", led);
        return 200;
    }

    return targetPin;
}
     990:	08 95       	ret

00000992 <digitalRead>:
check_valid_digital_pin():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/Arduino.h:712
  #if !defined(NUM_TOTAL_PINS)
    #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
  #endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
     992:	90 e0       	ldi	r25, 0x00	; 0
digitalRead():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:323
}

int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     994:	fc 01       	movw	r30, r24
     996:	ef 56       	subi	r30, 0x6F	; 111
     998:	ff 4b       	sbci	r31, 0xBF	; 191
     99a:	20 81       	ld	r18, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:324
  if (bit_mask == NOT_A_PIN) {
     99c:	2f 3f       	cpi	r18, 0xFF	; 255
     99e:	79 f0       	breq	.+30     	; 0x9be <digitalRead+0x2c>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:337
  // high bar for stuff that would make it even slower than it already is.
  //
  // turnOffPWM(pin);

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);
     9a0:	81 5c       	subi	r24, 0xC1	; 193
     9a2:	9f 4b       	sbci	r25, 0xBF	; 191
     9a4:	dc 01       	movw	r26, r24
     9a6:	ec 91       	ld	r30, X
     9a8:	b0 e2       	ldi	r27, 0x20	; 32
     9aa:	eb 9f       	mul	r30, r27
     9ac:	f0 01       	movw	r30, r0
     9ae:	11 24       	eor	r1, r1
     9b0:	fc 5f       	subi	r31, 0xFC	; 252
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:340

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
     9b2:	90 85       	ldd	r25, Z+8	; 0x08
     9b4:	92 23       	and	r25, r18
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	19 f4       	brne	.+6      	; 0x9c0 <digitalRead+0x2e>
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	08 95       	ret
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:325
int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return -1;
     9be:	8f ef       	ldi	r24, 0xFF	; 255
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:345
  if (port->IN & bit_mask) {
    return HIGH;
  } else {
    return LOW;
  }
}
     9c0:	08 95       	ret

000009c2 <digitalWrite>:
digitalWrite():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:209
  default:
    break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
     9c2:	0f 93       	push	r16
     9c4:	1f 93       	push	r17
     9c6:	cf 93       	push	r28
     9c8:	df 93       	push	r29
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:212
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     9ca:	89 32       	cpi	r24, 0x29	; 41
     9cc:	08 f0       	brcs	.+2      	; 0x9d0 <digitalWrite+0xe>
     9ce:	bd c0       	rjmp	.+378    	; 0xb4a <digitalWrite+0x188>
check_valid_digital_pin():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/Arduino.h:712
     9d0:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:212
     9d2:	dc 01       	movw	r26, r24
     9d4:	af 56       	subi	r26, 0x6F	; 111
     9d6:	bf 4b       	sbci	r27, 0xBF	; 191
     9d8:	2c 91       	ld	r18, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:213
  if (bit_mask == NOT_A_PIN) {
     9da:	2f 3f       	cpi	r18, 0xFF	; 255
     9dc:	09 f4       	brne	.+2      	; 0x9e0 <digitalWrite+0x1e>
     9de:	b5 c0       	rjmp	.+362    	; 0xb4a <digitalWrite+0x188>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:218
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     9e0:	8c 01       	movw	r16, r24
     9e2:	01 5c       	subi	r16, 0xC1	; 193
     9e4:	1f 4b       	sbci	r17, 0xBF	; 191
     9e6:	e8 01       	movw	r28, r16
     9e8:	e8 81       	ld	r30, Y
     9ea:	d0 e2       	ldi	r29, 0x20	; 32
     9ec:	ed 9f       	mul	r30, r29
     9ee:	f0 01       	movw	r30, r0
     9f0:	11 24       	eor	r1, r1
     9f2:	fc 5f       	subi	r31, 0xFC	; 252
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:226
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
     9f4:	61 11       	cpse	r22, r1
     9f6:	33 c0       	rjmp	.+102    	; 0xa5e <digitalWrite+0x9c>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:227
    port->OUTCLR = bit_mask;
     9f8:	26 83       	std	Z+6, r18	; 0x06
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:251
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     9fa:	30 81       	ld	r19, Z
     9fc:	23 23       	and	r18, r19
     9fe:	ac 01       	movw	r20, r24
     a00:	48 59       	subi	r20, 0x98	; 152
     a02:	5f 4b       	sbci	r21, 0xBF	; 191
     a04:	21 11       	cpse	r18, r1
     a06:	11 c0       	rjmp	.+34     	; 0xa2a <digitalWrite+0x68>
     a08:	ea 01       	movw	r28, r20
     a0a:	28 81       	ld	r18, Y
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     a0c:	30 97       	sbiw	r30, 0x00	; 0
     a0e:	49 f1       	breq	.+82     	; 0xa62 <digitalWrite+0xa0>
     a10:	28 30       	cpi	r18, 0x08	; 8
     a12:	38 f5       	brcc	.+78     	; 0xa62 <digitalWrite+0xa0>
     a14:	70 96       	adiw	r30, 0x10	; 16
     a16:	e2 0f       	add	r30, r18
     a18:	f1 1d       	adc	r31, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:264

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     a1a:	3f b7       	in	r19, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:265
    cli();
     a1c:	f8 94       	cli
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:269

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     a1e:	20 81       	ld	r18, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:267

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
     a20:	61 11       	cpse	r22, r1
     a22:	22 c0       	rjmp	.+68     	; 0xa68 <digitalWrite+0xa6>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:269
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     a24:	27 7f       	andi	r18, 0xF7	; 247
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:272
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     a26:	20 83       	st	Z, r18
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:276
    }

    /* Restore system status */
    SREG = status;
     a28:	3f bf       	out	0x3f, r19	; 63
digitalPinToTimerNow():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:771
  badCall("Resuming core control of type D timer not supported.");
}


uint8_t digitalPinToTimerNow(uint8_t p) {
  uint8_t bit_pos = digitalPinToBitPosition(p);
     a2a:	fa 01       	movw	r30, r20
     a2c:	30 81       	ld	r19, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:772
  if (bit_pos == NOT_A_PIN) return NOT_ON_TIMER;     /* Use bit position to check for invalid pins */
     a2e:	3f 3f       	cpi	r19, 0xFF	; 255
     a30:	09 f4       	brne	.+2      	; 0xa34 <digitalWrite+0x72>
     a32:	8b c0       	rjmp	.+278    	; 0xb4a <digitalWrite+0x188>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:773
  uint8_t port = digitalPinToPort(p);                /* If bit_pos is valid, port will be too      */
     a34:	e8 01       	movw	r28, r16
     a36:	28 81       	ld	r18, Y
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:774
  if ( bit_pos < 6) {                                /* SPLIT MODE TCA output is on pins 0-5       */
     a38:	36 30       	cpi	r19, 0x06	; 6
     a3a:	58 f5       	brcc	.+86     	; 0xa92 <digitalWrite+0xd0>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:776
  #if defined(TCA1)
    uint8_t tcamux = PORTMUX.TCAROUTEA;
     a3c:	30 91 e6 05 	lds	r19, 0x05E6	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:778
    if ( __PeripheralControl & TIMERA0) {              /* make sure user hasn't taken over TCA0      */
      if (((tcamux & PORTMUX_TCA0_gm) == port)) {    /* TCA0 mux is EASY - same as the port number */
     a40:	43 2f       	mov	r20, r19
     a42:	47 70       	andi	r20, 0x07	; 7
     a44:	24 13       	cpse	r18, r20
     a46:	12 c0       	rjmp	.+36     	; 0xa6c <digitalWrite+0xaa>
turnOffPWM():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a48:	ec 91       	ld	r30, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:128
  switch (timer) {

  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
     a4a:	e5 30       	cpi	r30, 0x05	; 5
     a4c:	08 f0       	brcs	.+2      	; 0xa50 <digitalWrite+0x8e>
     a4e:	ee 0f       	add	r30, r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:130
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
     a50:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
     a54:	e0 95       	com	r30
     a56:	e8 23       	and	r30, r24
     a58:	e0 93 01 0a 	sts	0x0A01, r30	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
     a5c:	76 c0       	rjmp	.+236    	; 0xb4a <digitalWrite+0x188>
digitalWrite():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:247
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     a5e:	25 83       	std	Z+5, r18	; 0x05
     a60:	cc cf       	rjmp	.-104    	; 0x9fa <digitalWrite+0x38>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     a62:	f0 e0       	ldi	r31, 0x00	; 0
     a64:	e0 e0       	ldi	r30, 0x00	; 0
     a66:	d9 cf       	rjmp	.-78     	; 0xa1a <digitalWrite+0x58>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:272
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     a68:	28 60       	ori	r18, 0x08	; 8
     a6a:	dd cf       	rjmp	.-70     	; 0xa26 <digitalWrite+0x64>
digitalPinToTimerNow():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:782
        return TIMERA0;
      }
    }
    tcamux &= 0x18;
     a6c:	38 71       	andi	r19, 0x18	; 24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:784
    if (__PeripheralControl & TIMERA1) {               /* make sure user hasn't taken over TCA0      */
      if ((tcamux == 0 && port == PB ) || (tcamux == 0x18 && port == PG)) { /* supports only 6-ch  */
     a6e:	69 f4       	brne	.+26     	; 0xa8a <digitalWrite+0xc8>
     a70:	21 30       	cpi	r18, 0x01	; 1
     a72:	79 f4       	brne	.+30     	; 0xa92 <digitalWrite+0xd0>
turnOffPWM():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a74:	ec 91       	ld	r30, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:135
    TCA0.SPLIT.CTRLB &= ~bit_mask;
    break;
  #ifdef TCA1
  case TIMERA1:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
     a76:	e5 30       	cpi	r30, 0x05	; 5
     a78:	08 f0       	brcs	.+2      	; 0xa7c <digitalWrite+0xba>
     a7a:	ee 0f       	add	r30, r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:137
    /* Disable corresponding channel */
    TCA1.SPLIT.CTRLB &= ~bit_mask;
     a7c:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
     a80:	e0 95       	com	r30
     a82:	e8 23       	and	r30, r24
     a84:	e0 93 41 0a 	sts	0x0A41, r30	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
     a88:	60 c0       	rjmp	.+192    	; 0xb4a <digitalWrite+0x188>
digitalPinToTimerNow():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:784
     a8a:	38 31       	cpi	r19, 0x18	; 24
     a8c:	11 f4       	brne	.+4      	; 0xa92 <digitalWrite+0xd0>
     a8e:	26 30       	cpi	r18, 0x06	; 6
     a90:	89 f3       	breq	.-30     	; 0xa74 <digitalWrite+0xb2>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:796
        return TIMERA0;
      }
    }
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);
     a92:	8a 5e       	subi	r24, 0xEA	; 234
     a94:	9f 4b       	sbci	r25, 0xBF	; 191
     a96:	fc 01       	movw	r30, r24
     a98:	80 81       	ld	r24, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:799

  if ( __PeripheralControl & TIMERD0) {
    if (timer & TIMERD0) {
     a9a:	86 ff       	sbrs	r24, 6
     a9c:	3d c0       	rjmp	.+122    	; 0xb18 <digitalWrite+0x156>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:800
      byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
     a9e:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <__TEXT_REGION_LENGTH__+0x7e05e8>
     aa2:	97 70       	andi	r25, 0x07	; 7
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:799
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);

  if ( __PeripheralControl & TIMERD0) {
    if (timer & TIMERD0) {
     aa4:	48 2f       	mov	r20, r24
     aa6:	50 e0       	ldi	r21, 0x00	; 0
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:801
      byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
      if (tcdmux == (timer & ~TIMERD0)) {
     aa8:	4f 7b       	andi	r20, 0xBF	; 191
     aaa:	94 17       	cp	r25, r20
     aac:	15 06       	cpc	r1, r21
     aae:	a1 f5       	brne	.+104    	; 0xb18 <digitalWrite+0x156>
turnOffPWM():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     ab0:	ec 91       	ld	r30, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:171
        // on the DA series, it could be any of them
        #if !defined(ERRATA_TCD_PORTMUX) || ERRATA_TCD_PORTMUX == 0
          //                                Px4-Px7
          uint8_t fcset = TCD0.FAULTCTRL & (bit_mask > 0x0F ? bit_mask : bit_mask << 4 ); // hopefully that gets rendereed as swap, not 4 leftshifts
        #else
          uint8_t fcset = TCD0.FAULTCTRL & bit_mask;
     ab2:	80 91 92 0b 	lds	r24, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
     ab6:	8e 23       	and	r24, r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:174
        #endif
      #endif
      if (fcset) {
     ab8:	09 f4       	brne	.+2      	; 0xabc <digitalWrite+0xfa>
     aba:	47 c0       	rjmp	.+142    	; 0xb4a <digitalWrite+0x188>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:179
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
     abc:	c0 e2       	ldi	r28, 0x20	; 32
     abe:	2c 9f       	mul	r18, r28
     ac0:	90 01       	movw	r18, r0
     ac2:	11 24       	eor	r1, r1
     ac4:	3c 5f       	subi	r19, 0xFC	; 252
     ac6:	e8 30       	cpi	r30, 0x08	; 8
     ac8:	08 f0       	brcs	.+2      	; 0xacc <digitalWrite+0x10a>
     aca:	55 c0       	rjmp	.+170    	; 0xb76 <digitalWrite+0x1b4>
     acc:	20 5f       	subi	r18, 0xF0	; 240
     ace:	3f 4f       	sbci	r19, 0xFF	; 255
     ad0:	e2 0f       	add	r30, r18
     ad2:	f3 2f       	mov	r31, r19
     ad4:	f1 1d       	adc	r31, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:188
        // it was currently set to output PWM, so it's very hard to imagine triggering it with just innocent calls to digitalWrite
        // in a constructor - we do not promise core functions will behave if users are reconfiguring peripherals in arbitrary ways.
        // Starting pwm manually (analogWrite won't start it until init starts the timers) in a constructor and then digitalWriting the same pin,
        // when the pin uses TCD0 for PWM is not expected to to produce correct behavior. If you modify the configuration except as described in
        // REF_TCD.md, you must takeOverTCD0() and assume full responsibility for all TCD configuration.
        uint8_t oldSREG = SREG;
     ad6:	4f b7       	in	r20, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:189
        cli();
     ad8:	f8 94       	cli
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:190
        TCD0.CTRLA &= ~TCD_ENABLE_bm; // stop the timer
     ada:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
     ade:	9e 7f       	andi	r25, 0xFE	; 254
     ae0:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:192
        // Experimentally found ENRDY must be set set to configure FAULTCTRL
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
     ae4:	90 91 8e 0b 	lds	r25, 0x0B8E	; 0x800b8e <__TEXT_REGION_LENGTH__+0x7e0b8e>
     ae8:	90 ff       	sbrs	r25, 0
     aea:	fc cf       	rjmp	.-8      	; 0xae4 <digitalWrite+0x122>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:193
        _PROTECTED_WRITE(TCD0.FAULTCTRL,TCD0.FAULTCTRL & ~fcset);
     aec:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	80 95       	com	r24
     af4:	90 95       	com	r25
     af6:	30 e0       	ldi	r19, 0x00	; 0
     af8:	82 23       	and	r24, r18
     afa:	93 23       	and	r25, r19
     afc:	28 ed       	ldi	r18, 0xD8	; 216
     afe:	24 bf       	out	0x34, r18	; 52
     b00:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:195
        // while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA |= TCD_ENABLE_bm;  // re-enable it
     b04:	80 91 80 0b 	lds	r24, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
     b08:	81 60       	ori	r24, 0x01	; 1
     b0a:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:197
        #if defined(NO_GLITCH_TIMERD0)
          *pin_ctrl_reg &= ~(PORT_INVEN_bm);
     b0e:	80 81       	ld	r24, Z
     b10:	8f 77       	andi	r24, 0x7F	; 127
     b12:	80 83       	st	Z, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:199
        #endif
        SREG = oldSREG;
     b14:	4f bf       	out	0x3f, r20	; 63
     b16:	19 c0       	rjmp	.+50     	; 0xb4a <digitalWrite+0x188>
digitalPinToTimerNow():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:806
        return TIMERD0;
      }
    }
  }
  if (timer & TIMERB0) { /* Finally check TCBn, if we made it here w/out returning */
     b18:	85 ff       	sbrs	r24, 5
     b1a:	15 c0       	rjmp	.+42     	; 0xb46 <digitalWrite+0x184>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:808
    TCB_t* timer_B;
    timer_B = ((TCB_t *)&TCB0 + (timer - TIMERB0)); /* get timer struct */
     b1c:	30 e1       	ldi	r19, 0x10	; 16
     b1e:	83 9f       	mul	r24, r19
     b20:	f0 01       	movw	r30, r0
     b22:	11 24       	eor	r1, r1
     b24:	f7 5f       	subi	r31, 0xF7	; 247
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:809
    if (((timer_B->CTRLB) &  TCB_CNTMODE_gm) != TCB_CNTMODE_PWM8_gc )
     b26:	91 81       	ldd	r25, Z+1	; 0x01
     b28:	97 70       	andi	r25, 0x07	; 7
     b2a:	97 30       	cpi	r25, 0x07	; 7
     b2c:	71 f4       	brne	.+28     	; 0xb4a <digitalWrite+0x188>
turnOffPWM():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
     b2e:	ec 91       	ld	r30, X
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:123
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
     b30:	85 32       	cpi	r24, 0x25	; 37
     b32:	80 f4       	brcc	.+32     	; 0xb54 <digitalWrite+0x192>
     b34:	80 32       	cpi	r24, 0x20	; 32
     b36:	b0 f4       	brcc	.+44     	; 0xb64 <digitalWrite+0x1a2>
     b38:	88 30       	cpi	r24, 0x08	; 8
     b3a:	09 f4       	brne	.+2      	; 0xb3e <digitalWrite+0x17c>
     b3c:	9c cf       	rjmp	.-200    	; 0xa76 <digitalWrite+0xb4>
     b3e:	80 31       	cpi	r24, 0x10	; 16
     b40:	09 f4       	brne	.+2      	; 0xb44 <digitalWrite+0x182>
     b42:	83 cf       	rjmp	.-250    	; 0xa4a <digitalWrite+0x88>
     b44:	02 c0       	rjmp	.+4      	; 0xb4a <digitalWrite+0x188>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:116
{
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;
     b46:	81 11       	cpse	r24, r1
     b48:	f2 cf       	rjmp	.-28     	; 0xb2e <digitalWrite+0x16c>
digitalWrite():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:289
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
     b4a:	df 91       	pop	r29
     b4c:	cf 91       	pop	r28
     b4e:	1f 91       	pop	r17
     b50:	0f 91       	pop	r16
     b52:	08 95       	ret
turnOffPWM():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:123
  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
     b54:	80 34       	cpi	r24, 0x40	; 64
     b56:	09 f4       	brne	.+2      	; 0xb5a <digitalWrite+0x198>
     b58:	ac cf       	rjmp	.-168    	; 0xab2 <digitalWrite+0xf0>
     b5a:	80 38       	cpi	r24, 0x80	; 128
     b5c:	b1 f7       	brne	.-20     	; 0xb4a <digitalWrite+0x188>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:155
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);

    break;
  #if defined(DAC0)
  case DACOUT:
    DAC0.CTRLA = 0x00;
     b5e:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7e06a0>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:147
  case TIMERB1:
  case TIMERB2:
  case TIMERB3:
  case TIMERB4:

    timerB = (TCB_t *) &TCB0 + (timer - TIMERB0);
     b62:	f3 cf       	rjmp	.-26     	; 0xb4a <digitalWrite+0x188>
     b64:	90 e1       	ldi	r25, 0x10	; 16
     b66:	89 9f       	mul	r24, r25
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:150

     // Disable TCB compare channel
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);
     b68:	f0 01       	movw	r30, r0
     b6a:	11 24       	eor	r1, r1
     b6c:	f7 5f       	subi	r31, 0xF7	; 247
     b6e:	81 81       	ldd	r24, Z+1	; 0x01
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:179
      if (fcset) {
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
     b70:	8f 7e       	andi	r24, 0xEF	; 239
     b72:	81 83       	std	Z+1, r24	; 0x01
     b74:	ea cf       	rjmp	.-44     	; 0xb4a <digitalWrite+0x188>
digitalWrite():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:77

void LedCtrlClass::on(Led led, bool is_from_system_event) {
    if (is_from_system_event && manual_control_enabled)
        return;

    digitalWrite(getLedPin(led), 0);
     b76:	f0 e0       	ldi	r31, 0x00	; 0
     b78:	e0 e0       	ldi	r30, 0x00	; 0
     b7a:	ad cf       	rjmp	.-166    	; 0xad6 <digitalWrite+0x114>

00000b7c <LedCtrlClass::on(Led, bool) [clone .part.1] [clone .constprop.23]>:
_ZN12LedCtrlClass2onE3Ledb.part.1():
     b7c:	de de       	rcall	.-580    	; 0x93a <LedCtrlClass::getLedPin(Led) [clone .constprop.24]>
     b7e:	60 e0       	ldi	r22, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:84

void LedCtrlClass::off(Led led, bool is_from_system_event) {
    if (is_from_system_event && manual_control_enabled)
        return;

    digitalWrite(getLedPin(led), 1);
     b80:	20 cf       	rjmp	.-448    	; 0x9c2 <digitalWrite>

00000b82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>:
_ZN12LedCtrlClass3offE3Ledb.part.2():
     b82:	db de       	rcall	.-586    	; 0x93a <LedCtrlClass::getLedPin(Led) [clone .constprop.24]>
     b84:	61 e0       	ldi	r22, 0x01	; 1
     b86:	1d cf       	rjmp	.-454    	; 0x9c2 <digitalWrite>

00000b88 <__vector_31>:
__vector_31():
     b88:	ef 93       	push	r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:194
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #else
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
     b8a:	ff 93       	push	r31
     b8c:	e9 ec       	ldi	r30, 0xC9	; 201
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:199
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
     b8e:	f4 e4       	ldi	r31, 0x44	; 68
     b90:	8f 93       	push	r24
     b92:	8f b7       	in	r24, 0x3f	; 63
     b94:	8f 93       	push	r24
     b96:	80 81       	ld	r24, Z
     b98:	8f 5f       	subi	r24, 0xFF	; 255
     b9a:	80 83       	st	Z, r24
     b9c:	81 81       	ldd	r24, Z+1	; 0x01
     b9e:	8f 4f       	sbci	r24, 0xFF	; 255
     ba0:	81 83       	std	Z+1, r24	; 0x01
     ba2:	82 81       	ldd	r24, Z+2	; 0x02
     ba4:	8f 4f       	sbci	r24, 0xFF	; 255
     ba6:	82 83       	std	Z+2, r24	; 0x02
     ba8:	83 81       	ldd	r24, Z+3	; 0x03
     baa:	8f 4f       	sbci	r24, 0xFF	; 255
     bac:	83 83       	std	Z+3, r24	; 0x03
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
     bb4:	8f 91       	pop	r24
     bb6:	8f bf       	out	0x3f, r24	; 63
     bb8:	8f 91       	pop	r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:433
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTF
      ISR(PORTF_PORT_vect, ISR_NAKED){
      asm volatile(
     bba:	ff 91       	pop	r31
     bbc:	ef 91       	pop	r30
     bbe:	18 95       	reti

00000bc0 <__vector_35>:
__vector_35():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:419
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTE
      ISR(PORTE_PORT_vect, ISR_NAKED){
      asm volatile(
     bc0:	0f 93       	push	r16
     bc2:	0a e0       	ldi	r16, 0x0A	; 10
     bc4:	0f c0       	rjmp	.+30     	; 0xbe4 <isrBody>

00000bc6 <__vector_46>:
__vector_46():
     bc6:	0f 93       	push	r16
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:405
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTD
      ISR(PORTD_PORT_vect, ISR_NAKED){
      asm volatile(
     bc8:	08 e0       	ldi	r16, 0x08	; 8
     bca:	0c c0       	rjmp	.+24     	; 0xbe4 <isrBody>

00000bcc <__vector_24>:
__vector_24():
     bcc:	0f 93       	push	r16
     bce:	06 e0       	ldi	r16, 0x06	; 6
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:391
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTC
      ISR(PORTC_PORT_vect, ISR_NAKED) {
      asm volatile(
     bd0:	09 c0       	rjmp	.+18     	; 0xbe4 <isrBody>

00000bd2 <__vector_30>:
__vector_30():
     bd2:	0f 93       	push	r16
     bd4:	04 e0       	ldi	r16, 0x04	; 4
     bd6:	06 c0       	rjmp	.+12     	; 0xbe4 <isrBody>

00000bd8 <__vector_45>:
__vector_45():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:377
      ::);
    __builtin_unreachable();
    }
    #ifdef PORTB
      ISR(PORTB_PORT_vect, ISR_NAKED){
      asm volatile(
     bd8:	0f 93       	push	r16
     bda:	02 e0       	ldi	r16, 0x02	; 2
     bdc:	03 c0       	rjmp	.+6      	; 0xbe4 <isrBody>

00000bde <__vector_8>:
__vector_8():
     bde:	0f 93       	push	r16
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:364
 * then it's just a matter of making sure we pop everything we pushed onto the stack in the reverse order, including r16 followed by the reti to exit the interrupt..
*/

  #if defined(CORE_ATTACH_ALL)
    ISR(PORTA_PORT_vect, ISR_NAKED) {
    asm volatile(
     be0:	00 e0       	ldi	r16, 0x00	; 0
     be2:	00 c0       	rjmp	.+0      	; 0xbe4 <isrBody>

00000be4 <isrBody>:
isrBody():
     be4:	0f 92       	push	r0
     be6:	0f b6       	in	r0, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:148

  }

#if !defined(CORE_ATTACH_EARLYCLEAR)
  void __attribute__((naked)) __attribute__((used)) __attribute__((noreturn)) isrBody() {
    asm volatile (
     be8:	0f 92       	push	r0
     bea:	0b b6       	in	r0, 0x3b	; 59
     bec:	0f 92       	push	r0
     bee:	1f 92       	push	r1
     bf0:	11 24       	eor	r1, r1
     bf2:	ff 92       	push	r15
     bf4:	1f 93       	push	r17
     bf6:	2f 93       	push	r18
     bf8:	3f 93       	push	r19
     bfa:	4f 93       	push	r20
     bfc:	5f 93       	push	r21
     bfe:	6f 93       	push	r22
     c00:	7f 93       	push	r23
     c02:	8f 93       	push	r24
     c04:	9f 93       	push	r25
     c06:	af 93       	push	r26
     c08:	bf 93       	push	r27
     c0a:	cf 93       	push	r28
     c0c:	df 93       	push	r29
     c0e:	ef 93       	push	r30
     c10:	ff 93       	push	r31
     c12:	a2 e0       	ldi	r26, 0x02	; 2
     c14:	b0 e4       	ldi	r27, 0x40	; 64
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/WInterrupts.c:176
      "push  r28"        "\n\t" // Not call used, but we use it.
      "push  r29"        "\n\t" // same thing.
      "push  r30"        "\n\t"
      "push  r31"        "\n\t"
      ::);
    asm volatile (  // This gets us the address of intFunc in Y pointer reg.
     c16:	a0 0f       	add	r26, r16
     c18:	b1 1d       	adc	r27, r1
     c1a:	cd 91       	ld	r28, X+
     c1c:	dc 91       	ld	r29, X
     c1e:	00 0f       	add	r16, r16
     c20:	0d 5f       	subi	r16, 0xFD	; 253
     c22:	a0 2f       	mov	r26, r16
     c24:	b0 e0       	ldi	r27, 0x00	; 0
     c26:	fc 90       	ld	r15, X
     c28:	10 97       	sbiw	r26, 0x00	; 0
     c2a:	61 f0       	breq	.+24     	; 0xc44 <AIntEnd>
     c2c:	1f 2d       	mov	r17, r15

00000c2e <AIntLoop>:
     c2e:	16 95       	lsr	r17
     c30:	18 f0       	brcs	.+6      	; 0xc38 <AIntLoop+0xa>
     c32:	41 f0       	breq	.+16     	; 0xc44 <AIntEnd>
     c34:	22 96       	adiw	r28, 0x02	; 2
     c36:	fb cf       	rjmp	.-10     	; 0xc2e <AIntLoop>
     c38:	e9 91       	ld	r30, Y+
     c3a:	f9 91       	ld	r31, Y+
     c3c:	30 97       	sbiw	r30, 0x00	; 0
     c3e:	b9 f3       	breq	.-18     	; 0xc2e <AIntLoop>
     c40:	09 95       	icall
     c42:	f5 cf       	rjmp	.-22     	; 0xc2e <AIntLoop>

00000c44 <AIntEnd>:
     c44:	a0 2f       	mov	r26, r16
     c46:	b0 e0       	ldi	r27, 0x00	; 0
     c48:	fc 92       	st	X, r15
     c4a:	ff 91       	pop	r31
     c4c:	ef 91       	pop	r30
     c4e:	df 91       	pop	r29
     c50:	cf 91       	pop	r28
     c52:	bf 91       	pop	r27
     c54:	af 91       	pop	r26
     c56:	9f 91       	pop	r25
     c58:	8f 91       	pop	r24
     c5a:	7f 91       	pop	r23
     c5c:	6f 91       	pop	r22
     c5e:	5f 91       	pop	r21
     c60:	4f 91       	pop	r20
     c62:	3f 91       	pop	r19
     c64:	2f 91       	pop	r18
     c66:	1f 91       	pop	r17
     c68:	ff 90       	pop	r15
     c6a:	1f 90       	pop	r1
     c6c:	0f 90       	pop	r0
     c6e:	0b be       	out	0x3b, r0	; 59
     c70:	0f 90       	pop	r0
     c72:	0f be       	out	0x3f, r0	; 63
     c74:	0f 90       	pop	r0
     c76:	0f 91       	pop	r16
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART3.cpp:95
    ISR(USART3_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
     c78:	18 95       	reti

00000c7a <__vector_54>:
__vector_54():
     c7a:	ef 93       	push	r30
     c7c:	ff 93       	push	r31
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART3.cpp:102
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial3));
     c7e:	f8 98       	cbi	0x1f, 0	; 31
     c80:	e1 e3       	ldi	r30, 0x31	; 49
     c82:	f8 e4       	ldi	r31, 0x48	; 72
     c84:	0b c0       	rjmp	.+22     	; 0xc9c <_do_dre()>

00000c86 <__vector_53>:
__vector_53():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART3.cpp:72
      ISR(USART3_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
     c86:	ef 93       	push	r30
     c88:	ff 93       	push	r31
     c8a:	f8 98       	cbi	0x1f, 0	; 31
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART3.cpp:79
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial3));
     c8c:	e1 e3       	ldi	r30, 0x31	; 49
     c8e:	f8 e4       	ldi	r31, 0x48	; 72
     c90:	33 c0       	rjmp	.+102    	; 0xcf8 <_do_rxc()>

00000c92 <__vector_55>:
__vector_55():
     c92:	ef 93       	push	r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART3.cpp:35
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART3_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
     c94:	ff 93       	push	r31
     c96:	e1 e3       	ldi	r30, 0x31	; 49
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART3.cpp:42
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial3));
     c98:	f8 e4       	ldi	r31, 0x48	; 72
     c9a:	5e c0       	rjmp	.+188    	; 0xd58 <_do_txc()>

00000c9c <_do_dre()>:
_Z7_do_drev():
     c9c:	2f 93       	push	r18
     c9e:	2f b7       	in	r18, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:387
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
     ca0:	2f 93       	push	r18
     ca2:	8f 93       	push	r24
     ca4:	9f 93       	push	r25
     ca6:	af 93       	push	r26
     ca8:	bf 93       	push	r27
     caa:	68 94       	set

00000cac <_poll_dre>:
     cac:	cf 93       	push	r28
     cae:	df 93       	push	r29
     cb0:	20 e0       	ldi	r18, 0x00	; 0
     cb2:	c0 85       	ldd	r28, Z+8	; 0x08
     cb4:	d8 e0       	ldi	r29, 0x08	; 8
     cb6:	92 89       	ldd	r25, Z+18	; 0x12
     cb8:	df 01       	movw	r26, r30
     cba:	a9 0f       	add	r26, r25
     cbc:	b2 1f       	adc	r27, r18
     cbe:	ad 5a       	subi	r26, 0xAD	; 173
     cc0:	bf 4f       	sbci	r27, 0xFF	; 255
     cc2:	8c 91       	ld	r24, X
     cc4:	20 e4       	ldi	r18, 0x40	; 64
     cc6:	2c 83       	std	Y+4, r18	; 0x04
     cc8:	8a 83       	std	Y+2, r24	; 0x02
     cca:	9f 5f       	subi	r25, 0xFF	; 255
     ccc:	9f 73       	andi	r25, 0x3F	; 63
     cce:	8d 81       	ldd	r24, Y+5	; 0x05
     cd0:	21 89       	ldd	r18, Z+17	; 0x11
     cd2:	29 13       	cpse	r18, r25
     cd4:	02 c0       	rjmp	.+4      	; 0xcda <_done_dre_irq>
     cd6:	8f 7d       	andi	r24, 0xDF	; 223
     cd8:	8d 83       	std	Y+5, r24	; 0x05

00000cda <_done_dre_irq>:
     cda:	92 8b       	std	Z+18, r25	; 0x12
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	0e f0       	brts	.+2      	; 0xce4 <_done_dre_irq+0xa>
     ce2:	fa cb       	rjmp	.-2060   	; 0x4d8 <_poll_dre_done>
     ce4:	bf 91       	pop	r27
     ce6:	af 91       	pop	r26
     ce8:	9f 91       	pop	r25
     cea:	8f 91       	pop	r24
     cec:	2f 91       	pop	r18
     cee:	2f bf       	out	0x3f, r18	; 63
     cf0:	2f 91       	pop	r18
     cf2:	ff 91       	pop	r31
     cf4:	ef 91       	pop	r30
     cf6:	18 95       	reti

00000cf8 <_do_rxc()>:
_Z7_do_rxcv():
     cf8:	2f 93       	push	r18
     cfa:	2f b7       	in	r18, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:252
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // _buff_full_rxc moved to after the reti, and then rjmps back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
     cfc:	2f 93       	push	r18
     cfe:	3f 93       	push	r19
     d00:	8f 93       	push	r24
     d02:	9f 93       	push	r25
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	c0 85       	ldd	r28, Z+8	; 0x08
     d0a:	d8 e0       	ldi	r29, 0x08	; 8
     d0c:	2e 81       	ldd	r18, Y+6	; 0x06
     d0e:	2f 7e       	andi	r18, 0xEF	; 239
     d10:	2e 83       	std	Y+6, r18	; 0x06
     d12:	89 81       	ldd	r24, Y+1	; 0x01
     d14:	98 81       	ld	r25, Y
     d16:	86 74       	andi	r24, 0x46	; 70
     d18:	88 0f       	add	r24, r24
     d1a:	36 85       	ldd	r19, Z+14	; 0x0e
     d1c:	38 2b       	or	r19, r24
     d1e:	82 fd       	sbrc	r24, 2
     d20:	0d c0       	rjmp	.+26     	; 0xd3c <_end_rxc>
     d22:	c7 85       	ldd	r28, Z+15	; 0x0f
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	8c 0f       	add	r24, r28
     d28:	8f 73       	andi	r24, 0x3F	; 63
     d2a:	20 89       	ldd	r18, Z+16	; 0x10
     d2c:	28 17       	cp	r18, r24
     d2e:	91 f0       	breq	.+36     	; 0xd54 <_buff_full_rxc>
     d30:	ce 0f       	add	r28, r30
     d32:	df 2f       	mov	r29, r31
     d34:	20 e0       	ldi	r18, 0x00	; 0
     d36:	d2 1f       	adc	r29, r18
     d38:	9b 8b       	std	Y+19, r25	; 0x13
     d3a:	87 87       	std	Z+15, r24	; 0x0f

00000d3c <_end_rxc>:
     d3c:	36 87       	std	Z+14, r19	; 0x0e
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	9f 91       	pop	r25
     d44:	8f 91       	pop	r24
     d46:	3f 91       	pop	r19
     d48:	2f 91       	pop	r18
     d4a:	2f bf       	out	0x3f, r18	; 63
     d4c:	2f 91       	pop	r18
     d4e:	ff 91       	pop	r31
     d50:	ef 91       	pop	r30
     d52:	18 95       	reti

00000d54 <_buff_full_rxc>:
     d54:	30 64       	ori	r19, 0x40	; 64
     d56:	f2 cf       	rjmp	.-28     	; 0xd3c <_end_rxc>

00000d58 <_do_txc()>:
_Z7_do_txcv():
     d58:	8f 93       	push	r24
     d5a:	8f b7       	in	r24, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:127
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
     d5c:	8f 93       	push	r24
     d5e:	9f 93       	push	r25
     d60:	cf 93       	push	r28
     d62:	df 93       	push	r29
     d64:	c0 85       	ldd	r28, Z+8	; 0x08
     d66:	d8 e0       	ldi	r29, 0x08	; 8
     d68:	9d 81       	ldd	r25, Y+5	; 0x05

00000d6a <_txc_flush_rx>:
     d6a:	88 81       	ld	r24, Y
     d6c:	8c 81       	ldd	r24, Y+4	; 0x04
     d6e:	87 fd       	sbrc	r24, 7
     d70:	fc cf       	rjmp	.-8      	; 0xd6a <_txc_flush_rx>
     d72:	9f 7b       	andi	r25, 0xBF	; 191
     d74:	90 68       	ori	r25, 0x80	; 128
     d76:	9d 83       	std	Y+5, r25	; 0x05
     d78:	df 91       	pop	r29
     d7a:	cf 91       	pop	r28
     d7c:	9f 91       	pop	r25
     d7e:	8f 91       	pop	r24
     d80:	8f bf       	out	0x3f, r24	; 63
     d82:	8f 91       	pop	r24
     d84:	ff 91       	pop	r31
     d86:	ef 91       	pop	r30
     d88:	18 95       	reti

00000d8a <__vector_42>:
__vector_42():
     d8a:	1f 92       	push	r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:986

/**
 *@brief      TWI1 Slave Interrupt vector
 */
#if defined(TWI1)
  ISR(TWI1_TWIS_vect) {
     d8c:	0f 92       	push	r0
     d8e:	0f b6       	in	r0, 0x3f	; 63
     d90:	0f 92       	push	r0
     d92:	11 24       	eor	r1, r1
     d94:	0b b6       	in	r0, 0x3b	; 59
     d96:	0f 92       	push	r0
     d98:	2f 93       	push	r18
     d9a:	3f 93       	push	r19
     d9c:	4f 93       	push	r20
     d9e:	5f 93       	push	r21
     da0:	6f 93       	push	r22
     da2:	7f 93       	push	r23
     da4:	8f 93       	push	r24
     da6:	9f 93       	push	r25
     da8:	af 93       	push	r26
     daa:	bf 93       	push	r27
     dac:	ef 93       	push	r30
     dae:	ff 93       	push	r31
onSlaveIRQ():
     db0:	85 ed       	ldi	r24, 0xD5	; 213
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:929
                                                    // Wire interfaces. Here is decoded which interrupt was fired.
  #if defined(TWI1) &&  defined(TWI_USING_WIRE1)   // Two TWIs available and TWI1 is used. Need to check the module
    if (module == &TWI0) {
      TWI_HandleSlaveIRQ(&(Wire.vars));
    } else if (module == &TWI1) {
      TWI_HandleSlaveIRQ(&(Wire1.vars));
     db2:	94 e4       	ldi	r25, 0x44	; 68
     db4:	00 dc       	rcall	.-2048   	; 0x5b6 <TWI_HandleSlaveIRQ>
__vector_42():
     db6:	ff 91       	pop	r31
     db8:	ef 91       	pop	r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:988
 *@brief      TWI1 Slave Interrupt vector
 */
#if defined(TWI1)
  ISR(TWI1_TWIS_vect) {
    TwoWire::onSlaveIRQ(&TWI1);
  }
     dba:	bf 91       	pop	r27
     dbc:	af 91       	pop	r26
     dbe:	9f 91       	pop	r25
     dc0:	8f 91       	pop	r24
     dc2:	7f 91       	pop	r23
     dc4:	6f 91       	pop	r22
     dc6:	5f 91       	pop	r21
     dc8:	4f 91       	pop	r20
     dca:	3f 91       	pop	r19
     dcc:	2f 91       	pop	r18
     dce:	0f 90       	pop	r0
     dd0:	0b be       	out	0x3b, r0	; 59
     dd2:	0f 90       	pop	r0
     dd4:	0f be       	out	0x3f, r0	; 63
     dd6:	0f 90       	pop	r0
     dd8:	1f 90       	pop	r1
     dda:	18 95       	reti

00000ddc <__vector_18>:
__vector_18():
     ddc:	1f 92       	push	r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:977


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
     dde:	0f 92       	push	r0
     de0:	0f b6       	in	r0, 0x3f	; 63
     de2:	0f 92       	push	r0
     de4:	11 24       	eor	r1, r1
     de6:	0b b6       	in	r0, 0x3b	; 59
     de8:	0f 92       	push	r0
     dea:	2f 93       	push	r18
     dec:	3f 93       	push	r19
     dee:	4f 93       	push	r20
     df0:	5f 93       	push	r21
     df2:	6f 93       	push	r22
     df4:	7f 93       	push	r23
     df6:	8f 93       	push	r24
     df8:	9f 93       	push	r25
     dfa:	af 93       	push	r26
     dfc:	bf 93       	push	r27
     dfe:	ef 93       	push	r30
     e00:	ff 93       	push	r31
onSlaveIRQ():
     e02:	83 e7       	ldi	r24, 0x73	; 115
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:927
 */
void TwoWire::onSlaveIRQ(TWI_t *module) {          // This function is static and is, thus, the only one for both
                                                    // Wire interfaces. Here is decoded which interrupt was fired.
  #if defined(TWI1) &&  defined(TWI_USING_WIRE1)   // Two TWIs available and TWI1 is used. Need to check the module
    if (module == &TWI0) {
      TWI_HandleSlaveIRQ(&(Wire.vars));
     e04:	96 e4       	ldi	r25, 0x46	; 70
     e06:	d7 db       	rcall	.-2130   	; 0x5b6 <TWI_HandleSlaveIRQ>
__vector_18():
     e08:	ff 91       	pop	r31
     e0a:	ef 91       	pop	r30
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/libraries/Wire/src/Wire.cpp:979
/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
  TwoWire::onSlaveIRQ(&TWI0);
}
     e0c:	bf 91       	pop	r27
     e0e:	af 91       	pop	r26
     e10:	9f 91       	pop	r25
     e12:	8f 91       	pop	r24
     e14:	7f 91       	pop	r23
     e16:	6f 91       	pop	r22
     e18:	5f 91       	pop	r21
     e1a:	4f 91       	pop	r20
     e1c:	3f 91       	pop	r19
     e1e:	2f 91       	pop	r18
     e20:	0f 90       	pop	r0
     e22:	0b be       	out	0x3b, r0	; 59
     e24:	0f 90       	pop	r0
     e26:	0f be       	out	0x3f, r0	; 63
     e28:	0f 90       	pop	r0
     e2a:	1f 90       	pop	r1
     e2c:	18 95       	reti

00000e2e <__vector_33>:
__vector_33():
     e2e:	1f 92       	push	r1
     e30:	0f 92       	push	r0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:462
/**
 * @brief Data register empty. Allows us to keep track of when the data has
 * been transmitted on the line and set up new data to be transmitted from
 * the ring buffer.
 */
ISR(USART1_DRE_vect) {
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	0f 92       	push	r0
     e36:	11 24       	eor	r1, r1
     e38:	8f 93       	push	r24
     e3a:	9f 93       	push	r25
     e3c:	80 91 c5 44 	lds	r24, 0x44C5	; 0x8044c5 <tx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:463
    if (tx_num_elements != 0) {
     e40:	90 91 c6 44 	lds	r25, 0x44C6	; 0x8044c6 <tx_num_elements+0x1>
     e44:	89 2b       	or	r24, r25
     e46:	01 f1       	breq	.+64     	; 0xe88 <__vector_33+0x5a>
     e48:	80 91 c3 44 	lds	r24, 0x44C3	; 0x8044c3 <tx_tail_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:464
        tx_tail_index      = (tx_tail_index + 1) & TX_BUFFER_MASK;
     e4c:	90 91 c4 44 	lds	r25, 0x44C4	; 0x8044c4 <tx_tail_index+0x1>
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	91 70       	andi	r25, 0x01	; 1
     e54:	80 93 c3 44 	sts	0x44C3, r24	; 0x8044c3 <tx_tail_index>
     e58:	90 93 c4 44 	sts	0x44C4, r25	; 0x8044c4 <tx_tail_index+0x1>
     e5c:	80 91 c3 44 	lds	r24, 0x44C3	; 0x8044c3 <tx_tail_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:465
        HWSERIALAT.TXDATAL = tx_buffer[tx_tail_index];
     e60:	90 91 c4 44 	lds	r25, 0x44C4	; 0x8044c4 <tx_tail_index+0x1>
     e64:	10 92 22 08 	sts	0x0822, r1	; 0x800822 <__TEXT_REGION_LENGTH__+0x7e0822>
     e68:	80 91 c5 44 	lds	r24, 0x44C5	; 0x8044c5 <tx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:466
        tx_num_elements--;
     e6c:	90 91 c6 44 	lds	r25, 0x44C6	; 0x8044c6 <tx_num_elements+0x1>
     e70:	01 97       	sbiw	r24, 0x01	; 1
     e72:	80 93 c5 44 	sts	0x44C5, r24	; 0x8044c5 <tx_num_elements>
     e76:	90 93 c6 44 	sts	0x44C6, r25	; 0x8044c6 <tx_num_elements+0x1>
     e7a:	9f 91       	pop	r25
     e7c:	8f 91       	pop	r24
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:470
    } else {
        HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
    }
}
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti
     e88:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:468
    if (tx_num_elements != 0) {
        tx_tail_index      = (tx_tail_index + 1) & TX_BUFFER_MASK;
        HWSERIALAT.TXDATAL = tx_buffer[tx_tail_index];
        tx_num_elements--;
    } else {
        HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
     e8c:	8f 7d       	andi	r24, 0xDF	; 223
     e8e:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
     e92:	f3 cf       	rjmp	.-26     	; 0xe7a <__vector_33+0x4c>

00000e94 <__vector_32>:
__vector_32():
     e94:	1f 92       	push	r1
     e96:	0f 92       	push	r0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:320
        VPORTC.INTFLAGS = RING_INT_bm;
    }
}

// RX complete
ISR(USART1_RXC_vect) {
     e98:	0f b6       	in	r0, 0x3f	; 63
     e9a:	0f 92       	push	r0
     e9c:	11 24       	eor	r1, r1
     e9e:	0b b6       	in	r0, 0x3b	; 59
     ea0:	0f 92       	push	r0
     ea2:	0f 93       	push	r16
     ea4:	1f 93       	push	r17
     ea6:	2f 93       	push	r18
     ea8:	3f 93       	push	r19
     eaa:	4f 93       	push	r20
     eac:	5f 93       	push	r21
     eae:	6f 93       	push	r22
     eb0:	7f 93       	push	r23
     eb2:	8f 93       	push	r24
     eb4:	9f 93       	push	r25
     eb6:	af 93       	push	r26
     eb8:	bf 93       	push	r27
     eba:	cf 93       	push	r28
     ebc:	df 93       	push	r29
     ebe:	ef 93       	push	r30
     ec0:	ff 93       	push	r31
     ec2:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x7e0820>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:321
    uint8_t data = USART1.RXDATAL;
     ec6:	20 91 c1 44 	lds	r18, 0x44C1	; 0x8044c1 <rx_head_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:325

    // We do an logical AND here as a means of allowing the index to wrap
    // around since we have a circular buffer
    rx_head_index            = (rx_head_index + 1) & RX_BUFFER_MASK;
     eca:	30 91 c2 44 	lds	r19, 0x44C2	; 0x8044c2 <rx_head_index+0x1>
     ece:	2f 5f       	subi	r18, 0xFF	; 255
     ed0:	3f 4f       	sbci	r19, 0xFF	; 255
     ed2:	31 70       	andi	r19, 0x01	; 1
     ed4:	20 93 c1 44 	sts	0x44C1, r18	; 0x8044c1 <rx_head_index>
     ed8:	30 93 c2 44 	sts	0x44C2, r19	; 0x8044c2 <rx_head_index+0x1>
     edc:	20 91 c1 44 	lds	r18, 0x44C1	; 0x8044c1 <rx_head_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:326
    rx_buffer[rx_head_index] = data;
     ee0:	30 91 c2 44 	lds	r19, 0x44C2	; 0x8044c2 <rx_head_index+0x1>
     ee4:	20 91 bf 44 	lds	r18, 0x44BF	; 0x8044bf <rx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:327
    rx_num_elements++;
     ee8:	30 91 c0 44 	lds	r19, 0x44C0	; 0x8044c0 <rx_num_elements+0x1>
     eec:	2f 5f       	subi	r18, 0xFF	; 255
     eee:	3f 4f       	sbci	r19, 0xFF	; 255
     ef0:	20 93 bf 44 	sts	0x44BF, r18	; 0x8044bf <rx_num_elements>
     ef4:	30 93 c0 44 	sts	0x44C0, r19	; 0x8044c0 <rx_num_elements+0x1>
     ef8:	20 91 00 40 	lds	r18, 0x4000	; 0x804000 <__DATA_REGION_ORIGIN__>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:334
    // Here we keep track of the length of the URC when it starts and
    // compare it against the look up table of lengths of the strings we are
    // looking for. We compare against them first in order to save some
    // cycles in the ISR and if the lengths match, we compare the string for
    // the URC and against the buffer. If they match, call the callback
    switch (urc_parse_state) {
     efc:	30 91 01 40 	lds	r19, 0x4001	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
     f00:	21 30       	cpi	r18, 0x01	; 1
     f02:	31 05       	cpc	r19, r1
     f04:	c9 f1       	breq	.+114    	; 0xf78 <__vector_32+0xe4>
     f06:	08 f4       	brcc	.+2      	; 0xf0a <__vector_32+0x76>
     f08:	52 c0       	rjmp	.+164    	; 0xfae <__vector_32+0x11a>
     f0a:	22 30       	cpi	r18, 0x02	; 2
     f0c:	31 05       	cpc	r19, r1
     f0e:	09 f4       	brne	.+2      	; 0xf12 <__vector_32+0x7e>
     f10:	e2 c0       	rjmp	.+452    	; 0x10d6 <__vector_32+0x242>
     f12:	23 30       	cpi	r18, 0x03	; 3
     f14:	31 05       	cpc	r19, r1
     f16:	61 f4       	brne	.+24     	; 0xf30 <__vector_32+0x9c>
     f18:	8b 32       	cpi	r24, 0x2B	; 43
     f1a:	51 f4       	brne	.+20     	; 0xf30 <__vector_32+0x9c>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:338

    case URC_NOT_PARSING:

        if (data == URC_IDENTIFIER_START_CHARACTER) {
     f1c:	10 92 bd 44 	sts	0x44BD, r1	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:339
            urc_identifier_buffer_length = 0;
     f20:	10 92 be 44 	sts	0x44BE, r1	; 0x8044be <urc_identifier_buffer_length+0x1>
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	90 e0       	ldi	r25, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:340
            urc_parse_state              = URC_EVALUATING_IDENTIFIER;
     f28:	80 93 00 40 	sts	0x4000, r24	; 0x804000 <__DATA_REGION_ORIGIN__>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:351

        // Some commands return a '+' followed by numbers which can be mistaken
        // for an URC, so we check against that and disregard the data if that
        // is the case
        if (data >= '0' && data <= '9') {
            urc_parse_state = URC_NOT_PARSING;
     f2c:	90 93 01 40 	sts	0x4001, r25	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
rtsUpdate():
     f30:	80 91 db 41 	lds	r24, 0x41DB	; 0x8041db <power_save_mode>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:243
 * target that no more data should be sent
 */
static inline void rtsUpdate(void) {
    // If we are in a power save mode, flow control is disabled until we get a
    // RING0 ack
    if (power_save_mode == 1) {
     f34:	81 30       	cpi	r24, 0x01	; 1
     f36:	49 f0       	breq	.+18     	; 0xf4a <__vector_32+0xb6>
     f38:	80 91 bf 44 	lds	r24, 0x44BF	; 0x8044bf <rx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:253
        return;
    }

    // We prefer to not use arduino's digitalWrite here to reduce code in the
    // ISR
    if (rx_num_elements < RX_BUFFER_ALMOST_FULL) {
     f3c:	90 91 c0 44 	lds	r25, 0x44C0	; 0x8044c0 <rx_num_elements+0x1>
     f40:	8e 3f       	cpi	r24, 0xFE	; 254
     f42:	91 40       	sbci	r25, 0x01	; 1
     f44:	08 f0       	brcs	.+2      	; 0xf48 <__vector_32+0xb4>
     f46:	39 c1       	rjmp	.+626    	; 0x11ba <__vector_32+0x326>
     f48:	4f 98       	cbi	0x09, 7	; 9
__vector_32():
     f4a:	ff 91       	pop	r31
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:255
        // Space for more data, assert RTS line (active low)
        VPORTC.OUT &= (~RTS_PIN_bm);
     f4c:	ef 91       	pop	r30
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:455
    default:
        break;
    }

    rtsUpdate();
}
     f4e:	df 91       	pop	r29
     f50:	cf 91       	pop	r28
     f52:	bf 91       	pop	r27
     f54:	af 91       	pop	r26
     f56:	9f 91       	pop	r25
     f58:	8f 91       	pop	r24
     f5a:	7f 91       	pop	r23
     f5c:	6f 91       	pop	r22
     f5e:	5f 91       	pop	r21
     f60:	4f 91       	pop	r20
     f62:	3f 91       	pop	r19
     f64:	2f 91       	pop	r18
     f66:	1f 91       	pop	r17
     f68:	0f 91       	pop	r16
     f6a:	0f 90       	pop	r0
     f6c:	0b be       	out	0x3b, r0	; 59
     f6e:	0f 90       	pop	r0
     f70:	0f be       	out	0x3f, r0	; 63
     f72:	0f 90       	pop	r0
     f74:	1f 90       	pop	r1
     f76:	18 95       	reti
     f78:	90 ed       	ldi	r25, 0xD0	; 208
     f7a:	98 0f       	add	r25, r24
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:350
    case URC_EVALUATING_IDENTIFIER:

        // Some commands return a '+' followed by numbers which can be mistaken
        // for an URC, so we check against that and disregard the data if that
        // is the case
        if (data >= '0' && data <= '9') {
     f7c:	9a 30       	cpi	r25, 0x0A	; 10
     f7e:	18 f4       	brcc	.+6      	; 0xf86 <__vector_32+0xf2>
     f80:	83 e0       	ldi	r24, 0x03	; 3
     f82:	90 e0       	ldi	r25, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:351
            urc_parse_state = URC_NOT_PARSING;
     f84:	d1 cf       	rjmp	.-94     	; 0xf28 <__vector_32+0x94>
     f86:	20 91 bd 44 	lds	r18, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:353
        } else {
            urc_identifier_buffer[urc_identifier_buffer_length++] = data;
     f8a:	30 91 be 44 	lds	r19, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
     f8e:	a9 01       	movw	r20, r18
     f90:	4f 5f       	subi	r20, 0xFF	; 255
     f92:	5f 4f       	sbci	r21, 0xFF	; 255
     f94:	40 93 bd 44 	sts	0x44BD, r20	; 0x8044bd <urc_identifier_buffer_length>
     f98:	50 93 be 44 	sts	0x44BE, r21	; 0x8044be <urc_identifier_buffer_length+0x1>
     f9c:	2f 55       	subi	r18, 0x5F	; 95
     f9e:	3b 4b       	sbci	r19, 0xBB	; 187
     fa0:	f9 01       	movw	r30, r18
     fa2:	80 83       	st	Z, r24
     fa4:	10 92 00 40 	sts	0x4000, r1	; 0x804000 <__DATA_REGION_ORIGIN__>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:354
            urc_parse_state = URC_PARSING_IDENTIFIER;
     fa8:	10 92 01 40 	sts	0x4001, r1	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
     fac:	c1 cf       	rjmp	.-126    	; 0xf30 <__vector_32+0x9c>
     fae:	8a 33       	cpi	r24, 0x3A	; 58
     fb0:	19 f0       	breq	.+6      	; 0xfb8 <__vector_32+0x124>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:360
        }
        break;

    case URC_PARSING_IDENTIFIER:

        if (data == URC_IDENTIFIER_END_CHARACTER || data == CARRIAGE_RETURN) {
     fb2:	8d 30       	cpi	r24, 0x0D	; 13
     fb4:	09 f0       	breq	.+2      	; 0xfb8 <__vector_32+0x124>
     fb6:	77 c0       	rjmp	.+238    	; 0x10a6 <__vector_32+0x212>
     fb8:	83 e0       	ldi	r24, 0x03	; 3
     fba:	90 e0       	ldi	r25, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:364

            // We set this as the initial condition and if we find a match
            // for the URC we go on parsing the data
            urc_parse_state = URC_NOT_PARSING;
     fbc:	80 93 00 40 	sts	0x4000, r24	; 0x804000 <__DATA_REGION_ORIGIN__>
     fc0:	90 93 01 40 	sts	0x4001, r25	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
     fc4:	10 e0       	ldi	r17, 0x00	; 0
     fc6:	00 e0       	ldi	r16, 0x00	; 0
     fc8:	e8 01       	movw	r28, r16
     fca:	85 e0       	ldi	r24, 0x05	; 5
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:368

            for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {

                if (urcs[i].identifier_length == urc_identifier_buffer_length) {
     fcc:	cc 0f       	add	r28, r28
     fce:	dd 1f       	adc	r29, r29
     fd0:	8a 95       	dec	r24
     fd2:	e1 f7       	brne	.-8      	; 0xfcc <__vector_32+0x138>
     fd4:	cf 59       	subi	r28, 0x9F	; 159
     fd6:	dc 4b       	sbci	r29, 0xBC	; 188
     fd8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fda:	80 91 bd 44 	lds	r24, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
     fde:	90 91 be 44 	lds	r25, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
     fe2:	28 17       	cp	r18, r24
     fe4:	19 06       	cpc	r1, r25
     fe6:	09 f0       	breq	.+2      	; 0xfea <__vector_32+0x156>
     fe8:	57 c0       	rjmp	.+174    	; 0x1098 <__vector_32+0x204>
     fea:	4c 8d       	ldd	r20, Y+28	; 0x1c
     fec:	50 e0       	ldi	r21, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:371
                    if (memcmp((const void*)urc_identifier_buffer,
                               (const void*)urcs[i].identifier,
                               urcs[i].identifier_length) == 0) {
     fee:	be 01       	movw	r22, r28
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:369
            urc_parse_state = URC_NOT_PARSING;

            for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {

                if (urcs[i].identifier_length == urc_identifier_buffer_length) {
                    if (memcmp((const void*)urc_identifier_buffer,
     ff0:	81 ea       	ldi	r24, 0xA1	; 161
     ff2:	94 e4       	ldi	r25, 0x44	; 68
     ff4:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <memcmp>
     ff8:	89 2b       	or	r24, r25
     ffa:	09 f0       	breq	.+2      	; 0xffe <__vector_32+0x16a>
     ffc:	4d c0       	rjmp	.+154    	; 0x1098 <__vector_32+0x204>
     ffe:	00 93 60 43 	sts	0x4360, r16	; 0x804360 <urc_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:373
                               (const void*)urcs[i].identifier,
                               urcs[i].identifier_length) == 0) {

                        urc_index            = i;
    1002:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1004:	9f 8d       	ldd	r25, Y+31	; 0x1f
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:374
                        urc_current_callback = urcs[i].callback;
    1006:	80 93 5e 43 	sts	0x435E, r24	; 0x80435e <urc_current_callback>
    100a:	90 93 5f 43 	sts	0x435F, r25	; 0x80435f <urc_current_callback+0x1>
    100e:	82 e0       	ldi	r24, 0x02	; 2
    1010:	90 e0       	ldi	r25, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:375
                        urc_parse_state      = URC_PARSING_DATA;
    1012:	80 93 00 40 	sts	0x4000, r24	; 0x804000 <__DATA_REGION_ORIGIN__>
    1016:	90 93 01 40 	sts	0x4001, r25	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
    101a:	e0 91 60 43 	lds	r30, 0x4360	; 0x804360 <urc_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:382
                        // Clear data if requested and if the data hasn't
                        // already been read
                        // We apply the + 2 here as we also want to remove the
                        // start character and the end character of the URC (+
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
    101e:	20 e2       	ldi	r18, 0x20	; 32
    1020:	e2 9f       	mul	r30, r18
    1022:	f0 01       	movw	r30, r0
    1024:	11 24       	eor	r1, r1
    1026:	ef 59       	subi	r30, 0x9F	; 159
    1028:	fc 4b       	sbci	r31, 0xBC	; 188
    102a:	85 8d       	ldd	r24, Z+29	; 0x1d
    102c:	88 23       	and	r24, r24
    102e:	59 f1       	breq	.+86     	; 0x1086 <__vector_32+0x1f2>
    1030:	80 91 bd 44 	lds	r24, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:384
                            rx_num_elements >=
                                (urc_identifier_buffer_length + 2)) {
    1034:	90 91 be 44 	lds	r25, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
    1038:	20 91 bf 44 	lds	r18, 0x44BF	; 0x8044bf <rx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:383
                        // already been read
                        // We apply the + 2 here as we also want to remove the
                        // start character and the end character of the URC (+
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
                            rx_num_elements >=
    103c:	30 91 c0 44 	lds	r19, 0x44C0	; 0x8044c0 <rx_num_elements+0x1>
    1040:	02 96       	adiw	r24, 0x02	; 2
    1042:	28 17       	cp	r18, r24
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:384
                                (urc_identifier_buffer_length + 2)) {
    1044:	39 07       	cpc	r19, r25
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:382
                        // Clear data if requested and if the data hasn't
                        // already been read
                        // We apply the + 2 here as we also want to remove the
                        // start character and the end character of the URC (+
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
    1046:	f8 f0       	brcs	.+62     	; 0x1086 <__vector_32+0x1f2>
    1048:	80 91 c1 44 	lds	r24, 0x44C1	; 0x8044c1 <rx_head_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:387
                            rx_num_elements >=
                                (urc_identifier_buffer_length + 2)) {

                            rx_head_index =
                                (rx_head_index -
    104c:	90 91 c2 44 	lds	r25, 0x44C2	; 0x8044c2 <rx_head_index+0x1>
    1050:	20 91 bd 44 	lds	r18, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
    1054:	30 91 be 44 	lds	r19, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
    1058:	02 97       	sbiw	r24, 0x02	; 2
    105a:	82 1b       	sub	r24, r18
    105c:	93 0b       	sbc	r25, r19
    105e:	91 70       	andi	r25, 0x01	; 1
    1060:	80 93 c1 44 	sts	0x44C1, r24	; 0x8044c1 <rx_head_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:386
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
                            rx_num_elements >=
                                (urc_identifier_buffer_length + 2)) {

                            rx_head_index =
    1064:	90 93 c2 44 	sts	0x44C2, r25	; 0x8044c2 <rx_head_index+0x1>
    1068:	20 91 bd 44 	lds	r18, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:391
                                (rx_head_index -
                                 (urc_identifier_buffer_length + 2)) &
                                RX_BUFFER_MASK;

                            rx_num_elements -= (urc_identifier_buffer_length +
    106c:	30 91 be 44 	lds	r19, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
    1070:	80 91 bf 44 	lds	r24, 0x44BF	; 0x8044bf <rx_num_elements>
    1074:	90 91 c0 44 	lds	r25, 0x44C0	; 0x8044c0 <rx_num_elements+0x1>
    1078:	02 97       	sbiw	r24, 0x02	; 2
    107a:	82 1b       	sub	r24, r18
    107c:	93 0b       	sbc	r25, r19
    107e:	80 93 bf 44 	sts	0x44BF, r24	; 0x8044bf <rx_num_elements>
    1082:	90 93 c0 44 	sts	0x44C0, r25	; 0x8044c0 <rx_num_elements+0x1>
    1086:	10 92 5c 43 	sts	0x435C, r1	; 0x80435c <urc_data_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:397
                                                2);
                        }

                        // Reset the index in order to prepare the URC
                        // buffer for data
                        urc_data_buffer_length = 0;
    108a:	10 92 5d 43 	sts	0x435D, r1	; 0x80435d <urc_data_buffer_length+0x1>
    108e:	10 92 bd 44 	sts	0x44BD, r1	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:403

                        break;
                    }
                }
            }
            urc_identifier_buffer_length = 0;
    1092:	10 92 be 44 	sts	0x44BE, r1	; 0x8044be <urc_identifier_buffer_length+0x1>
    1096:	4c cf       	rjmp	.-360    	; 0xf30 <__vector_32+0x9c>
    1098:	0f 5f       	subi	r16, 0xFF	; 255
    109a:	1f 4f       	sbci	r17, 0xFF	; 255
    109c:	0a 30       	cpi	r16, 0x0A	; 10
    109e:	11 05       	cpc	r17, r1
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:366

            // We set this as the initial condition and if we find a match
            // for the URC we go on parsing the data
            urc_parse_state = URC_NOT_PARSING;

            for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
    10a0:	09 f0       	breq	.+2      	; 0x10a4 <__vector_32+0x210>
    10a2:	92 cf       	rjmp	.-220    	; 0xfc8 <__vector_32+0x134>
    10a4:	f4 cf       	rjmp	.-24     	; 0x108e <__vector_32+0x1fa>
    10a6:	20 91 bd 44 	lds	r18, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:405
                    }
                }
            }
            urc_identifier_buffer_length = 0;

        } else if (urc_identifier_buffer_length == URC_IDENTIFIER_BUFFER_SIZE) {
    10aa:	30 91 be 44 	lds	r19, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
    10ae:	2c 31       	cpi	r18, 0x1C	; 28
    10b0:	31 05       	cpc	r19, r1
    10b2:	09 f4       	brne	.+2      	; 0x10b6 <__vector_32+0x222>
    10b4:	65 cf       	rjmp	.-310    	; 0xf80 <__vector_32+0xec>
    10b6:	20 91 bd 44 	lds	r18, 0x44BD	; 0x8044bd <urc_identifier_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:408
            urc_parse_state = URC_NOT_PARSING;
        } else {
            urc_identifier_buffer[urc_identifier_buffer_length++] = data;
    10ba:	30 91 be 44 	lds	r19, 0x44BE	; 0x8044be <urc_identifier_buffer_length+0x1>
    10be:	a9 01       	movw	r20, r18
    10c0:	4f 5f       	subi	r20, 0xFF	; 255
    10c2:	5f 4f       	sbci	r21, 0xFF	; 255
    10c4:	40 93 bd 44 	sts	0x44BD, r20	; 0x8044bd <urc_identifier_buffer_length>
    10c8:	50 93 be 44 	sts	0x44BE, r21	; 0x8044be <urc_identifier_buffer_length+0x1>
    10cc:	2f 55       	subi	r18, 0x5F	; 95
    10ce:	3b 4b       	sbci	r19, 0xBB	; 187
    10d0:	f9 01       	movw	r30, r18
    10d2:	80 83       	st	Z, r24
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:446

        } else if (urc_data_buffer_length == URC_DATA_BUFFER_SIZE) {
            // This is just a failsafe
            urc_parse_state = URC_NOT_PARSING;
        } else {
            urc_data_buffer[urc_data_buffer_length++] = data;
    10d4:	2d cf       	rjmp	.-422    	; 0xf30 <__vector_32+0x9c>
    10d6:	8d 30       	cpi	r24, 0x0D	; 13
    10d8:	19 f0       	breq	.+6      	; 0x10e0 <__vector_32+0x24c>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:415

        break;

    case URC_PARSING_DATA:

        if (data == CARRIAGE_RETURN || data == LINE_FEED) {
    10da:	8a 30       	cpi	r24, 0x0A	; 10
    10dc:	09 f0       	breq	.+2      	; 0x10e0 <__vector_32+0x24c>
    10de:	57 c0       	rjmp	.+174    	; 0x118e <__vector_32+0x2fa>
    10e0:	e0 91 5c 43 	lds	r30, 0x435C	; 0x80435c <urc_data_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:418

            // Add termination since we're done
            urc_data_buffer[urc_data_buffer_length] = 0;
    10e4:	f0 91 5d 43 	lds	r31, 0x435D	; 0x80435d <urc_data_buffer_length+0x1>
    10e8:	e4 52       	subi	r30, 0x24	; 36
    10ea:	fe 4b       	sbci	r31, 0xBE	; 190
    10ec:	10 82       	st	Z, r1
    10ee:	e0 91 60 43 	lds	r30, 0x4360	; 0x804360 <urc_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:422

            // Clear the buffer for the URC if requested and if it already
            // hasn't been read
            if (urcs[urc_index].should_clear &&
    10f2:	20 e2       	ldi	r18, 0x20	; 32
    10f4:	e2 9f       	mul	r30, r18
    10f6:	f0 01       	movw	r30, r0
    10f8:	11 24       	eor	r1, r1
    10fa:	ef 59       	subi	r30, 0x9F	; 159
    10fc:	fc 4b       	sbci	r31, 0xBC	; 188
    10fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    1100:	88 23       	and	r24, r24
    1102:	41 f1       	breq	.+80     	; 0x1154 <__vector_32+0x2c0>
    1104:	20 91 bf 44 	lds	r18, 0x44BF	; 0x8044bf <rx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:423
                rx_num_elements >= urc_data_buffer_length) {
    1108:	30 91 c0 44 	lds	r19, 0x44C0	; 0x8044c0 <rx_num_elements+0x1>
    110c:	80 91 5c 43 	lds	r24, 0x435C	; 0x80435c <urc_data_buffer_length>
    1110:	90 91 5d 43 	lds	r25, 0x435D	; 0x80435d <urc_data_buffer_length+0x1>
    1114:	28 17       	cp	r18, r24
    1116:	39 07       	cpc	r19, r25
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:422
            // Add termination since we're done
            urc_data_buffer[urc_data_buffer_length] = 0;

            // Clear the buffer for the URC if requested and if it already
            // hasn't been read
            if (urcs[urc_index].should_clear &&
    1118:	e8 f0       	brcs	.+58     	; 0x1154 <__vector_32+0x2c0>
    111a:	80 91 c1 44 	lds	r24, 0x44C1	; 0x8044c1 <rx_head_index>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:425
                rx_num_elements >= urc_data_buffer_length) {

                rx_head_index = (rx_head_index - urc_data_buffer_length) &
    111e:	90 91 c2 44 	lds	r25, 0x44C2	; 0x8044c2 <rx_head_index+0x1>
    1122:	20 91 5c 43 	lds	r18, 0x435C	; 0x80435c <urc_data_buffer_length>
    1126:	30 91 5d 43 	lds	r19, 0x435D	; 0x80435d <urc_data_buffer_length+0x1>
    112a:	82 1b       	sub	r24, r18
    112c:	93 0b       	sbc	r25, r19
    112e:	91 70       	andi	r25, 0x01	; 1
    1130:	80 93 c1 44 	sts	0x44C1, r24	; 0x8044c1 <rx_head_index>
    1134:	90 93 c2 44 	sts	0x44C2, r25	; 0x8044c2 <rx_head_index+0x1>
    1138:	80 91 bf 44 	lds	r24, 0x44BF	; 0x8044bf <rx_num_elements>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:427
                                RX_BUFFER_MASK;
                rx_num_elements = (rx_num_elements - urc_data_buffer_length);
    113c:	90 91 c0 44 	lds	r25, 0x44C0	; 0x8044c0 <rx_num_elements+0x1>
    1140:	20 91 5c 43 	lds	r18, 0x435C	; 0x80435c <urc_data_buffer_length>
    1144:	30 91 5d 43 	lds	r19, 0x435D	; 0x80435d <urc_data_buffer_length+0x1>
    1148:	82 1b       	sub	r24, r18
    114a:	93 0b       	sbc	r25, r19
    114c:	80 93 bf 44 	sts	0x44BF, r24	; 0x8044bf <rx_num_elements>
    1150:	90 93 c0 44 	sts	0x44C0, r25	; 0x8044c0 <rx_num_elements+0x1>
    1154:	e0 91 5e 43 	lds	r30, 0x435E	; 0x80435e <urc_current_callback>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:430
            }

            if (urc_current_callback != NULL) {
    1158:	f0 91 5f 43 	lds	r31, 0x435F	; 0x80435f <urc_current_callback+0x1>
    115c:	30 97       	sbiw	r30, 0x00	; 0
    115e:	61 f0       	breq	.+24     	; 0x1178 <__vector_32+0x2e4>
    1160:	c0 e8       	ldi	r28, 0x80	; 128
    1162:	c0 93 45 04 	sts	0x0445, r28	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:433
                // Apply flow control here for the modem, we make it wait to
                // send more data until we've finished the URC callback
                RTS_PORT.OUTSET = RTS_PIN_bm;
    1166:	8c ed       	ldi	r24, 0xDC	; 220
    1168:	91 e4       	ldi	r25, 0x41	; 65
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:434
                urc_current_callback((char*)urc_data_buffer);
    116a:	09 95       	icall
    116c:	10 92 5e 43 	sts	0x435E, r1	; 0x80435e <urc_current_callback>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:435
                urc_current_callback = NULL;
    1170:	10 92 5f 43 	sts	0x435F, r1	; 0x80435f <urc_current_callback+0x1>
    1174:	c0 93 46 04 	sts	0x0446, r28	; 0x800446 <__TEXT_REGION_LENGTH__+0x7e0446>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:436
                RTS_PORT.OUTCLR      = RTS_PIN_bm;
    1178:	83 e0       	ldi	r24, 0x03	; 3
    117a:	90 e0       	ldi	r25, 0x00	; 0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:439
            }

            urc_parse_state        = URC_NOT_PARSING;
    117c:	80 93 00 40 	sts	0x4000, r24	; 0x804000 <__DATA_REGION_ORIGIN__>
    1180:	90 93 01 40 	sts	0x4001, r25	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
    1184:	10 92 5c 43 	sts	0x435C, r1	; 0x80435c <urc_data_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:440
            urc_data_buffer_length = 0;
    1188:	10 92 5d 43 	sts	0x435D, r1	; 0x80435d <urc_data_buffer_length+0x1>
    118c:	d1 ce       	rjmp	.-606    	; 0xf30 <__vector_32+0x9c>
    118e:	20 91 5c 43 	lds	r18, 0x435C	; 0x80435c <urc_data_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:442

        } else if (urc_data_buffer_length == URC_DATA_BUFFER_SIZE) {
    1192:	30 91 5d 43 	lds	r19, 0x435D	; 0x80435d <urc_data_buffer_length+0x1>
    1196:	20 38       	cpi	r18, 0x80	; 128
    1198:	31 40       	sbci	r19, 0x01	; 1
    119a:	09 f4       	brne	.+2      	; 0x119e <__vector_32+0x30a>
    119c:	f1 ce       	rjmp	.-542    	; 0xf80 <__vector_32+0xec>
    119e:	20 91 5c 43 	lds	r18, 0x435C	; 0x80435c <urc_data_buffer_length>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:446
            // This is just a failsafe
            urc_parse_state = URC_NOT_PARSING;
        } else {
            urc_data_buffer[urc_data_buffer_length++] = data;
    11a2:	30 91 5d 43 	lds	r19, 0x435D	; 0x80435d <urc_data_buffer_length+0x1>
    11a6:	a9 01       	movw	r20, r18
    11a8:	4f 5f       	subi	r20, 0xFF	; 255
    11aa:	5f 4f       	sbci	r21, 0xFF	; 255
    11ac:	40 93 5c 43 	sts	0x435C, r20	; 0x80435c <urc_data_buffer_length>
    11b0:	50 93 5d 43 	sts	0x435D, r21	; 0x80435d <urc_data_buffer_length+0x1>
    11b4:	24 52       	subi	r18, 0x24	; 36
    11b6:	3e 4b       	sbci	r19, 0xBE	; 190
    11b8:	8b cf       	rjmp	.-234    	; 0x10d0 <__vector_32+0x23c>
rtsUpdate():
    11ba:	4f 9a       	sbi	0x09, 7	; 9
    11bc:	c6 ce       	rjmp	.-628    	; 0xf4a <__vector_32+0xb6>

000011be <__vector_6>:
__vector_6():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/sequans_controller.cpp:259
        // Space for more data, assert RTS line (active low)
        VPORTC.OUT &= (~RTS_PIN_bm);
    } else {
        // Buffer is filling up, tell the target to stop sending data
        // for now by de-asserting RTS
        VPORTC.OUT |= RTS_PIN_bm;
    11be:	1f 92       	push	r1
    11c0:	0f 92       	push	r0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/low_power.cpp:132
/**
 * @brief Contains stored values of the OUT register for the respective ports.
 */
static uint8_t pin_out_state[6];

ISR(RTC_PIT_vect) {
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	0f 92       	push	r0
    11c6:	11 24       	eor	r1, r1
    11c8:	8f 93       	push	r24
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <__TEXT_REGION_LENGTH__+0x7e0153>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/low_power.cpp:133
    RTC.PITINTFLAGS = RTC_PI_bm;
    11d0:	80 93 da 41 	sts	0x41DA, r24	; 0x8041da <pit_triggered>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/low_power.cpp:134
    pit_triggered   = true;
    11d4:	8f 91       	pop	r24
    11d6:	0f 90       	pop	r0
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/low_power.cpp:135
}
    11d8:	0f be       	out	0x3f, r0	; 63
    11da:	0f 90       	pop	r0
    11dc:	1f 90       	pop	r1
    11de:	18 95       	reti

000011e0 <vfprintf>:
vfprintf():
    11e0:	2f 92       	push	r2
    11e2:	3f 92       	push	r3
    11e4:	4f 92       	push	r4
    11e6:	5f 92       	push	r5
    11e8:	6f 92       	push	r6
    11ea:	7f 92       	push	r7
    11ec:	8f 92       	push	r8
    11ee:	9f 92       	push	r9
    11f0:	af 92       	push	r10
    11f2:	bf 92       	push	r11
    11f4:	cf 92       	push	r12
    11f6:	df 92       	push	r13
    11f8:	ef 92       	push	r14
    11fa:	ff 92       	push	r15
    11fc:	0f 93       	push	r16
    11fe:	1f 93       	push	r17
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	2f 97       	sbiw	r28, 0x0f	; 15
    120a:	cd bf       	out	0x3d, r28	; 61
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	6c 01       	movw	r12, r24
    1210:	1b 01       	movw	r2, r22
    1212:	5a 01       	movw	r10, r20
    1214:	fc 01       	movw	r30, r24
    1216:	16 82       	std	Z+6, r1	; 0x06
    1218:	17 82       	std	Z+7, r1	; 0x07
    121a:	83 81       	ldd	r24, Z+3	; 0x03
    121c:	9e 01       	movw	r18, r28
    121e:	2f 5f       	subi	r18, 0xFF	; 255
    1220:	3f 4f       	sbci	r19, 0xFF	; 255
    1222:	49 01       	movw	r8, r18
    1224:	81 fd       	sbrc	r24, 1
    1226:	ce c0       	rjmp	.+412    	; 0x13c4 <vfprintf+0x1e4>
    1228:	8f ef       	ldi	r24, 0xFF	; 255
    122a:	9f ef       	ldi	r25, 0xFF	; 255
    122c:	d4 c2       	rjmp	.+1448   	; 0x17d6 <vfprintf+0x5f6>
    122e:	f1 2c       	mov	r15, r1
    1230:	51 2c       	mov	r5, r1
    1232:	00 e0       	ldi	r16, 0x00	; 0
    1234:	00 32       	cpi	r16, 0x20	; 32
    1236:	38 f4       	brcc	.+14     	; 0x1246 <vfprintf+0x66>
    1238:	8b 32       	cpi	r24, 0x2B	; 43
    123a:	09 f1       	breq	.+66     	; 0x127e <vfprintf+0x9e>
    123c:	90 f4       	brcc	.+36     	; 0x1262 <vfprintf+0x82>
    123e:	80 32       	cpi	r24, 0x20	; 32
    1240:	f9 f0       	breq	.+62     	; 0x1280 <vfprintf+0xa0>
    1242:	83 32       	cpi	r24, 0x23	; 35
    1244:	09 f1       	breq	.+66     	; 0x1288 <vfprintf+0xa8>
    1246:	07 fd       	sbrc	r16, 7
    1248:	34 c0       	rjmp	.+104    	; 0x12b2 <vfprintf+0xd2>
    124a:	20 ed       	ldi	r18, 0xD0	; 208
    124c:	28 0f       	add	r18, r24
    124e:	2a 30       	cpi	r18, 0x0A	; 10
    1250:	20 f5       	brcc	.+72     	; 0x129a <vfprintf+0xba>
    1252:	06 ff       	sbrs	r16, 6
    1254:	1b c0       	rjmp	.+54     	; 0x128c <vfprintf+0xac>
    1256:	fa e0       	ldi	r31, 0x0A	; 10
    1258:	ff 9e       	mul	r15, r31
    125a:	20 0d       	add	r18, r0
    125c:	11 24       	eor	r1, r1
    125e:	f2 2e       	mov	r15, r18
    1260:	05 c0       	rjmp	.+10     	; 0x126c <vfprintf+0x8c>
    1262:	8d 32       	cpi	r24, 0x2D	; 45
    1264:	79 f0       	breq	.+30     	; 0x1284 <vfprintf+0xa4>
    1266:	80 33       	cpi	r24, 0x30	; 48
    1268:	71 f7       	brne	.-36     	; 0x1246 <vfprintf+0x66>
    126a:	01 60       	ori	r16, 0x01	; 1
    126c:	f1 01       	movw	r30, r2
    126e:	93 fd       	sbrc	r25, 3
    1270:	85 91       	lpm	r24, Z+
    1272:	93 ff       	sbrs	r25, 3
    1274:	81 91       	ld	r24, Z+
    1276:	1f 01       	movw	r2, r30
    1278:	81 11       	cpse	r24, r1
    127a:	dc cf       	rjmp	.-72     	; 0x1234 <vfprintf+0x54>
    127c:	1a c0       	rjmp	.+52     	; 0x12b2 <vfprintf+0xd2>
    127e:	02 60       	ori	r16, 0x02	; 2
    1280:	04 60       	ori	r16, 0x04	; 4
    1282:	f4 cf       	rjmp	.-24     	; 0x126c <vfprintf+0x8c>
    1284:	08 60       	ori	r16, 0x08	; 8
    1286:	f2 cf       	rjmp	.-28     	; 0x126c <vfprintf+0x8c>
    1288:	00 61       	ori	r16, 0x10	; 16
    128a:	f0 cf       	rjmp	.-32     	; 0x126c <vfprintf+0x8c>
    128c:	3a e0       	ldi	r19, 0x0A	; 10
    128e:	53 9e       	mul	r5, r19
    1290:	20 0d       	add	r18, r0
    1292:	11 24       	eor	r1, r1
    1294:	52 2e       	mov	r5, r18
    1296:	00 62       	ori	r16, 0x20	; 32
    1298:	e9 cf       	rjmp	.-46     	; 0x126c <vfprintf+0x8c>
    129a:	8e 32       	cpi	r24, 0x2E	; 46
    129c:	21 f4       	brne	.+8      	; 0x12a6 <vfprintf+0xc6>
    129e:	06 fd       	sbrc	r16, 6
    12a0:	97 c2       	rjmp	.+1326   	; 0x17d0 <vfprintf+0x5f0>
    12a2:	00 64       	ori	r16, 0x40	; 64
    12a4:	e3 cf       	rjmp	.-58     	; 0x126c <vfprintf+0x8c>
    12a6:	8c 36       	cpi	r24, 0x6C	; 108
    12a8:	11 f4       	brne	.+4      	; 0x12ae <vfprintf+0xce>
    12aa:	00 68       	ori	r16, 0x80	; 128
    12ac:	df cf       	rjmp	.-66     	; 0x126c <vfprintf+0x8c>
    12ae:	88 36       	cpi	r24, 0x68	; 104
    12b0:	e9 f2       	breq	.-70     	; 0x126c <vfprintf+0x8c>
    12b2:	9b eb       	ldi	r25, 0xBB	; 187
    12b4:	98 0f       	add	r25, r24
    12b6:	93 30       	cpi	r25, 0x03	; 3
    12b8:	08 f0       	brcs	.+2      	; 0x12bc <vfprintf+0xdc>
    12ba:	5c c0       	rjmp	.+184    	; 0x1374 <vfprintf+0x194>
    12bc:	00 61       	ori	r16, 0x10	; 16
    12be:	80 5e       	subi	r24, 0xE0	; 224
    12c0:	06 fd       	sbrc	r16, 6
    12c2:	02 c0       	rjmp	.+4      	; 0x12c8 <vfprintf+0xe8>
    12c4:	46 e0       	ldi	r20, 0x06	; 6
    12c6:	f4 2e       	mov	r15, r20
    12c8:	10 2f       	mov	r17, r16
    12ca:	1f 73       	andi	r17, 0x3F	; 63
    12cc:	85 36       	cpi	r24, 0x65	; 101
    12ce:	09 f0       	breq	.+2      	; 0x12d2 <vfprintf+0xf2>
    12d0:	58 c0       	rjmp	.+176    	; 0x1382 <vfprintf+0x1a2>
    12d2:	10 64       	ori	r17, 0x40	; 64
    12d4:	17 ff       	sbrs	r17, 7
    12d6:	5e c0       	rjmp	.+188    	; 0x1394 <vfprintf+0x1b4>
    12d8:	8f 2d       	mov	r24, r15
    12da:	9b e3       	ldi	r25, 0x3B	; 59
    12dc:	9f 15       	cp	r25, r15
    12de:	08 f4       	brcc	.+2      	; 0x12e2 <vfprintf+0x102>
    12e0:	8b e3       	ldi	r24, 0x3B	; 59
    12e2:	44 24       	eor	r4, r4
    12e4:	43 94       	inc	r4
    12e6:	48 0e       	add	r4, r24
    12e8:	27 e0       	ldi	r18, 0x07	; 7
    12ea:	35 01       	movw	r6, r10
    12ec:	f4 e0       	ldi	r31, 0x04	; 4
    12ee:	6f 0e       	add	r6, r31
    12f0:	71 1c       	adc	r7, r1
    12f2:	f5 01       	movw	r30, r10
    12f4:	60 81       	ld	r22, Z
    12f6:	71 81       	ldd	r23, Z+1	; 0x01
    12f8:	82 81       	ldd	r24, Z+2	; 0x02
    12fa:	93 81       	ldd	r25, Z+3	; 0x03
    12fc:	04 2d       	mov	r16, r4
    12fe:	a4 01       	movw	r20, r8
    1300:	5a d5       	rcall	.+2740   	; 0x1db6 <__ftoa_engine>
    1302:	5c 01       	movw	r10, r24
    1304:	f9 81       	ldd	r31, Y+1	; 0x01
    1306:	fc 87       	std	Y+12, r31	; 0x0c
    1308:	f0 ff       	sbrs	r31, 0
    130a:	03 c0       	rjmp	.+6      	; 0x1312 <vfprintf+0x132>
    130c:	0d e2       	ldi	r16, 0x2D	; 45
    130e:	f3 ff       	sbrs	r31, 3
    1310:	07 c0       	rjmp	.+14     	; 0x1320 <vfprintf+0x140>
    1312:	0b e2       	ldi	r16, 0x2B	; 43
    1314:	11 fd       	sbrc	r17, 1
    1316:	04 c0       	rjmp	.+8      	; 0x1320 <vfprintf+0x140>
    1318:	01 2f       	mov	r16, r17
    131a:	04 70       	andi	r16, 0x04	; 4
    131c:	12 fd       	sbrc	r17, 2
    131e:	00 e2       	ldi	r16, 0x20	; 32
    1320:	2c 85       	ldd	r18, Y+12	; 0x0c
    1322:	2c 70       	andi	r18, 0x0C	; 12
    1324:	e2 2e       	mov	r14, r18
    1326:	09 f4       	brne	.+2      	; 0x132a <vfprintf+0x14a>
    1328:	67 c0       	rjmp	.+206    	; 0x13f8 <vfprintf+0x218>
    132a:	01 11       	cpse	r16, r1
    132c:	b9 c2       	rjmp	.+1394   	; 0x18a0 <vfprintf+0x6c0>
    132e:	f3 e0       	ldi	r31, 0x03	; 3
    1330:	e1 2c       	mov	r14, r1
    1332:	f5 15       	cp	r31, r5
    1334:	90 f4       	brcc	.+36     	; 0x135a <vfprintf+0x17a>
    1336:	83 e0       	ldi	r24, 0x03	; 3
    1338:	e5 2c       	mov	r14, r5
    133a:	e8 1a       	sub	r14, r24
    133c:	13 fd       	sbrc	r17, 3
    133e:	07 c0       	rjmp	.+14     	; 0x134e <vfprintf+0x16e>
    1340:	b6 01       	movw	r22, r12
    1342:	80 e2       	ldi	r24, 0x20	; 32
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	25 d6       	rcall	.+3146   	; 0x1f92 <fputc>
    1348:	ea 94       	dec	r14
    134a:	e1 10       	cpse	r14, r1
    134c:	f9 cf       	rjmp	.-14     	; 0x1340 <vfprintf+0x160>
    134e:	00 23       	and	r16, r16
    1350:	21 f0       	breq	.+8      	; 0x135a <vfprintf+0x17a>
    1352:	b6 01       	movw	r22, r12
    1354:	80 2f       	mov	r24, r16
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	1c d6       	rcall	.+3128   	; 0x1f92 <fputc>
    135a:	3c 85       	ldd	r19, Y+12	; 0x0c
    135c:	24 ef       	ldi	r18, 0xF4	; 244
    135e:	a2 2e       	mov	r10, r18
    1360:	20 e0       	ldi	r18, 0x00	; 0
    1362:	b2 2e       	mov	r11, r18
    1364:	33 fd       	sbrc	r19, 3
    1366:	04 c0       	rjmp	.+8      	; 0x1370 <vfprintf+0x190>
    1368:	98 ef       	ldi	r25, 0xF8	; 248
    136a:	a9 2e       	mov	r10, r25
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	b9 2e       	mov	r11, r25
    1370:	10 71       	andi	r17, 0x10	; 16
    1372:	21 c0       	rjmp	.+66     	; 0x13b6 <vfprintf+0x1d6>
    1374:	9b e9       	ldi	r25, 0x9B	; 155
    1376:	98 0f       	add	r25, r24
    1378:	93 30       	cpi	r25, 0x03	; 3
    137a:	08 f0       	brcs	.+2      	; 0x137e <vfprintf+0x19e>
    137c:	39 c1       	rjmp	.+626    	; 0x15f0 <vfprintf+0x410>
    137e:	0f 7e       	andi	r16, 0xEF	; 239
    1380:	9f cf       	rjmp	.-194    	; 0x12c0 <vfprintf+0xe0>
    1382:	86 36       	cpi	r24, 0x66	; 102
    1384:	11 f4       	brne	.+4      	; 0x138a <vfprintf+0x1aa>
    1386:	10 68       	ori	r17, 0x80	; 128
    1388:	a5 cf       	rjmp	.-182    	; 0x12d4 <vfprintf+0xf4>
    138a:	ff 20       	and	r15, r15
    138c:	09 f4       	brne	.+2      	; 0x1390 <vfprintf+0x1b0>
    138e:	a2 cf       	rjmp	.-188    	; 0x12d4 <vfprintf+0xf4>
    1390:	fa 94       	dec	r15
    1392:	a0 cf       	rjmp	.-192    	; 0x12d4 <vfprintf+0xf4>
    1394:	e7 e0       	ldi	r30, 0x07	; 7
    1396:	2f 2d       	mov	r18, r15
    1398:	ef 15       	cp	r30, r15
    139a:	18 f4       	brcc	.+6      	; 0x13a2 <vfprintf+0x1c2>
    139c:	27 e0       	ldi	r18, 0x07	; 7
    139e:	37 e0       	ldi	r19, 0x07	; 7
    13a0:	f3 2e       	mov	r15, r19
    13a2:	41 2c       	mov	r4, r1
    13a4:	a2 cf       	rjmp	.-188    	; 0x12ea <vfprintf+0x10a>
    13a6:	11 11       	cpse	r17, r1
    13a8:	80 52       	subi	r24, 0x20	; 32
    13aa:	b6 01       	movw	r22, r12
    13ac:	90 e0       	ldi	r25, 0x00	; 0
    13ae:	f1 d5       	rcall	.+3042   	; 0x1f92 <fputc>
    13b0:	8f ef       	ldi	r24, 0xFF	; 255
    13b2:	a8 1a       	sub	r10, r24
    13b4:	b8 0a       	sbc	r11, r24
    13b6:	f5 01       	movw	r30, r10
    13b8:	84 91       	lpm	r24, Z
    13ba:	81 11       	cpse	r24, r1
    13bc:	f4 cf       	rjmp	.-24     	; 0x13a6 <vfprintf+0x1c6>
    13be:	e1 10       	cpse	r14, r1
    13c0:	69 c2       	rjmp	.+1234   	; 0x1894 <vfprintf+0x6b4>
    13c2:	53 01       	movw	r10, r6
    13c4:	f6 01       	movw	r30, r12
    13c6:	93 81       	ldd	r25, Z+3	; 0x03
    13c8:	f1 01       	movw	r30, r2
    13ca:	93 fd       	sbrc	r25, 3
    13cc:	85 91       	lpm	r24, Z+
    13ce:	93 ff       	sbrs	r25, 3
    13d0:	81 91       	ld	r24, Z+
    13d2:	1f 01       	movw	r2, r30
    13d4:	88 23       	and	r24, r24
    13d6:	09 f4       	brne	.+2      	; 0x13da <vfprintf+0x1fa>
    13d8:	fb c1       	rjmp	.+1014   	; 0x17d0 <vfprintf+0x5f0>
    13da:	85 32       	cpi	r24, 0x25	; 37
    13dc:	41 f4       	brne	.+16     	; 0x13ee <vfprintf+0x20e>
    13de:	93 fd       	sbrc	r25, 3
    13e0:	85 91       	lpm	r24, Z+
    13e2:	93 ff       	sbrs	r25, 3
    13e4:	81 91       	ld	r24, Z+
    13e6:	1f 01       	movw	r2, r30
    13e8:	85 32       	cpi	r24, 0x25	; 37
    13ea:	09 f0       	breq	.+2      	; 0x13ee <vfprintf+0x20e>
    13ec:	20 cf       	rjmp	.-448    	; 0x122e <vfprintf+0x4e>
    13ee:	b6 01       	movw	r22, r12
    13f0:	90 e0       	ldi	r25, 0x00	; 0
    13f2:	cf d5       	rcall	.+2974   	; 0x1f92 <fputc>
    13f4:	35 01       	movw	r6, r10
    13f6:	e5 cf       	rjmp	.-54     	; 0x13c2 <vfprintf+0x1e2>
    13f8:	17 ff       	sbrs	r17, 7
    13fa:	6c c0       	rjmp	.+216    	; 0x14d4 <vfprintf+0x2f4>
    13fc:	4a 0c       	add	r4, r10
    13fe:	fc 85       	ldd	r31, Y+12	; 0x0c
    1400:	f4 ff       	sbrs	r31, 4
    1402:	04 c0       	rjmp	.+8      	; 0x140c <vfprintf+0x22c>
    1404:	8a 81       	ldd	r24, Y+2	; 0x02
    1406:	81 33       	cpi	r24, 0x31	; 49
    1408:	09 f4       	brne	.+2      	; 0x140c <vfprintf+0x22c>
    140a:	4a 94       	dec	r4
    140c:	14 14       	cp	r1, r4
    140e:	0c f0       	brlt	.+2      	; 0x1412 <vfprintf+0x232>
    1410:	83 c0       	rjmp	.+262    	; 0x1518 <vfprintf+0x338>
    1412:	28 e0       	ldi	r18, 0x08	; 8
    1414:	24 15       	cp	r18, r4
    1416:	10 f4       	brcc	.+4      	; 0x141c <vfprintf+0x23c>
    1418:	88 e0       	ldi	r24, 0x08	; 8
    141a:	48 2e       	mov	r4, r24
    141c:	85 e0       	ldi	r24, 0x05	; 5
    141e:	90 e0       	ldi	r25, 0x00	; 0
    1420:	17 ff       	sbrs	r17, 7
    1422:	06 c0       	rjmp	.+12     	; 0x1430 <vfprintf+0x250>
    1424:	c5 01       	movw	r24, r10
    1426:	b7 fe       	sbrs	r11, 7
    1428:	02 c0       	rjmp	.+4      	; 0x142e <vfprintf+0x24e>
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	01 96       	adiw	r24, 0x01	; 1
    1430:	01 11       	cpse	r16, r1
    1432:	01 96       	adiw	r24, 0x01	; 1
    1434:	ff 20       	and	r15, r15
    1436:	31 f0       	breq	.+12     	; 0x1444 <vfprintf+0x264>
    1438:	2f 2d       	mov	r18, r15
    143a:	30 e0       	ldi	r19, 0x00	; 0
    143c:	2f 5f       	subi	r18, 0xFF	; 255
    143e:	3f 4f       	sbci	r19, 0xFF	; 255
    1440:	82 0f       	add	r24, r18
    1442:	93 1f       	adc	r25, r19
    1444:	58 16       	cp	r5, r24
    1446:	19 06       	cpc	r1, r25
    1448:	19 f0       	breq	.+6      	; 0x1450 <vfprintf+0x270>
    144a:	14 f0       	brlt	.+4      	; 0x1450 <vfprintf+0x270>
    144c:	e5 2c       	mov	r14, r5
    144e:	e8 1a       	sub	r14, r24
    1450:	81 2f       	mov	r24, r17
    1452:	89 70       	andi	r24, 0x09	; 9
    1454:	11 f4       	brne	.+4      	; 0x145a <vfprintf+0x27a>
    1456:	e1 10       	cpse	r14, r1
    1458:	64 c0       	rjmp	.+200    	; 0x1522 <vfprintf+0x342>
    145a:	00 23       	and	r16, r16
    145c:	21 f0       	breq	.+8      	; 0x1466 <vfprintf+0x286>
    145e:	b6 01       	movw	r22, r12
    1460:	80 2f       	mov	r24, r16
    1462:	90 e0       	ldi	r25, 0x00	; 0
    1464:	96 d5       	rcall	.+2860   	; 0x1f92 <fputc>
    1466:	13 fd       	sbrc	r17, 3
    1468:	02 c0       	rjmp	.+4      	; 0x146e <vfprintf+0x28e>
    146a:	e1 10       	cpse	r14, r1
    146c:	60 c0       	rjmp	.+192    	; 0x152e <vfprintf+0x34e>
    146e:	17 ff       	sbrs	r17, 7
    1470:	77 c0       	rjmp	.+238    	; 0x1560 <vfprintf+0x380>
    1472:	85 01       	movw	r16, r10
    1474:	b7 fe       	sbrs	r11, 7
    1476:	02 c0       	rjmp	.+4      	; 0x147c <vfprintf+0x29c>
    1478:	10 e0       	ldi	r17, 0x00	; 0
    147a:	00 e0       	ldi	r16, 0x00	; 0
    147c:	c5 01       	movw	r24, r10
    147e:	84 19       	sub	r24, r4
    1480:	91 09       	sbc	r25, r1
    1482:	2c 01       	movw	r4, r24
    1484:	6f 2d       	mov	r22, r15
    1486:	70 e0       	ldi	r23, 0x00	; 0
    1488:	ee 27       	eor	r30, r30
    148a:	ff 27       	eor	r31, r31
    148c:	e6 1b       	sub	r30, r22
    148e:	f7 0b       	sbc	r31, r23
    1490:	ee 87       	std	Y+14, r30	; 0x0e
    1492:	ff 87       	std	Y+15, r31	; 0x0f
    1494:	0f 3f       	cpi	r16, 0xFF	; 255
    1496:	10 07       	cpc	r17, r16
    1498:	21 f4       	brne	.+8      	; 0x14a2 <vfprintf+0x2c2>
    149a:	b6 01       	movw	r22, r12
    149c:	8e e2       	ldi	r24, 0x2E	; 46
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	78 d5       	rcall	.+2800   	; 0x1f92 <fputc>
    14a2:	a0 16       	cp	r10, r16
    14a4:	b1 06       	cpc	r11, r17
    14a6:	0c f4       	brge	.+2      	; 0x14aa <vfprintf+0x2ca>
    14a8:	48 c0       	rjmp	.+144    	; 0x153a <vfprintf+0x35a>
    14aa:	40 16       	cp	r4, r16
    14ac:	51 06       	cpc	r5, r17
    14ae:	0c f0       	brlt	.+2      	; 0x14b2 <vfprintf+0x2d2>
    14b0:	44 c0       	rjmp	.+136    	; 0x153a <vfprintf+0x35a>
    14b2:	f5 01       	movw	r30, r10
    14b4:	e0 1b       	sub	r30, r16
    14b6:	f1 0b       	sbc	r31, r17
    14b8:	e8 0d       	add	r30, r8
    14ba:	f9 1d       	adc	r31, r9
    14bc:	81 81       	ldd	r24, Z+1	; 0x01
    14be:	01 50       	subi	r16, 0x01	; 1
    14c0:	11 09       	sbc	r17, r1
    14c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    14c4:	3f 85       	ldd	r19, Y+15	; 0x0f
    14c6:	02 17       	cp	r16, r18
    14c8:	13 07       	cpc	r17, r19
    14ca:	cc f1       	brlt	.+114    	; 0x153e <vfprintf+0x35e>
    14cc:	b6 01       	movw	r22, r12
    14ce:	90 e0       	ldi	r25, 0x00	; 0
    14d0:	60 d5       	rcall	.+2752   	; 0x1f92 <fputc>
    14d2:	e0 cf       	rjmp	.-64     	; 0x1494 <vfprintf+0x2b4>
    14d4:	16 fd       	sbrc	r17, 6
    14d6:	a2 cf       	rjmp	.-188    	; 0x141c <vfprintf+0x23c>
    14d8:	ef 2d       	mov	r30, r15
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	ea 15       	cp	r30, r10
    14de:	fb 05       	cpc	r31, r11
    14e0:	34 f0       	brlt	.+12     	; 0x14ee <vfprintf+0x30e>
    14e2:	3c ef       	ldi	r19, 0xFC	; 252
    14e4:	a3 16       	cp	r10, r19
    14e6:	3f ef       	ldi	r19, 0xFF	; 255
    14e8:	b3 06       	cpc	r11, r19
    14ea:	0c f0       	brlt	.+2      	; 0x14ee <vfprintf+0x30e>
    14ec:	10 68       	ori	r17, 0x80	; 128
    14ee:	32 96       	adiw	r30, 0x02	; 2
    14f0:	e8 0d       	add	r30, r8
    14f2:	f9 1d       	adc	r31, r9
    14f4:	01 c0       	rjmp	.+2      	; 0x14f8 <vfprintf+0x318>
    14f6:	fa 94       	dec	r15
    14f8:	ff 20       	and	r15, r15
    14fa:	19 f0       	breq	.+6      	; 0x1502 <vfprintf+0x322>
    14fc:	82 91       	ld	r24, -Z
    14fe:	80 33       	cpi	r24, 0x30	; 48
    1500:	d1 f3       	breq	.-12     	; 0x14f6 <vfprintf+0x316>
    1502:	17 ff       	sbrs	r17, 7
    1504:	8b cf       	rjmp	.-234    	; 0x141c <vfprintf+0x23c>
    1506:	44 24       	eor	r4, r4
    1508:	43 94       	inc	r4
    150a:	4f 0c       	add	r4, r15
    150c:	fa 14       	cp	r15, r10
    150e:	1b 04       	cpc	r1, r11
    1510:	31 f0       	breq	.+12     	; 0x151e <vfprintf+0x33e>
    1512:	2c f0       	brlt	.+10     	; 0x151e <vfprintf+0x33e>
    1514:	fa 18       	sub	r15, r10
    1516:	82 cf       	rjmp	.-252    	; 0x141c <vfprintf+0x23c>
    1518:	44 24       	eor	r4, r4
    151a:	43 94       	inc	r4
    151c:	7f cf       	rjmp	.-258    	; 0x141c <vfprintf+0x23c>
    151e:	f1 2c       	mov	r15, r1
    1520:	7d cf       	rjmp	.-262    	; 0x141c <vfprintf+0x23c>
    1522:	b6 01       	movw	r22, r12
    1524:	80 e2       	ldi	r24, 0x20	; 32
    1526:	90 e0       	ldi	r25, 0x00	; 0
    1528:	34 d5       	rcall	.+2664   	; 0x1f92 <fputc>
    152a:	ea 94       	dec	r14
    152c:	94 cf       	rjmp	.-216    	; 0x1456 <vfprintf+0x276>
    152e:	b6 01       	movw	r22, r12
    1530:	80 e3       	ldi	r24, 0x30	; 48
    1532:	90 e0       	ldi	r25, 0x00	; 0
    1534:	2e d5       	rcall	.+2652   	; 0x1f92 <fputc>
    1536:	ea 94       	dec	r14
    1538:	98 cf       	rjmp	.-208    	; 0x146a <vfprintf+0x28a>
    153a:	80 e3       	ldi	r24, 0x30	; 48
    153c:	c0 cf       	rjmp	.-128    	; 0x14be <vfprintf+0x2de>
    153e:	a0 16       	cp	r10, r16
    1540:	b1 06       	cpc	r11, r17
    1542:	41 f4       	brne	.+16     	; 0x1554 <vfprintf+0x374>
    1544:	9a 81       	ldd	r25, Y+2	; 0x02
    1546:	96 33       	cpi	r25, 0x36	; 54
    1548:	48 f4       	brcc	.+18     	; 0x155c <vfprintf+0x37c>
    154a:	95 33       	cpi	r25, 0x35	; 53
    154c:	19 f4       	brne	.+6      	; 0x1554 <vfprintf+0x374>
    154e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1550:	34 ff       	sbrs	r19, 4
    1552:	04 c0       	rjmp	.+8      	; 0x155c <vfprintf+0x37c>
    1554:	b6 01       	movw	r22, r12
    1556:	90 e0       	ldi	r25, 0x00	; 0
    1558:	1c d5       	rcall	.+2616   	; 0x1f92 <fputc>
    155a:	31 cf       	rjmp	.-414    	; 0x13be <vfprintf+0x1de>
    155c:	81 e3       	ldi	r24, 0x31	; 49
    155e:	fa cf       	rjmp	.-12     	; 0x1554 <vfprintf+0x374>
    1560:	8a 81       	ldd	r24, Y+2	; 0x02
    1562:	81 33       	cpi	r24, 0x31	; 49
    1564:	19 f0       	breq	.+6      	; 0x156c <vfprintf+0x38c>
    1566:	9c 85       	ldd	r25, Y+12	; 0x0c
    1568:	9f 7e       	andi	r25, 0xEF	; 239
    156a:	9c 87       	std	Y+12, r25	; 0x0c
    156c:	b6 01       	movw	r22, r12
    156e:	90 e0       	ldi	r25, 0x00	; 0
    1570:	10 d5       	rcall	.+2592   	; 0x1f92 <fputc>
    1572:	ff 20       	and	r15, r15
    1574:	99 f0       	breq	.+38     	; 0x159c <vfprintf+0x3bc>
    1576:	b6 01       	movw	r22, r12
    1578:	8e e2       	ldi	r24, 0x2E	; 46
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	0a d5       	rcall	.+2580   	; 0x1f92 <fputc>
    157e:	f3 94       	inc	r15
    1580:	f3 94       	inc	r15
    1582:	e2 e0       	ldi	r30, 0x02	; 2
    1584:	01 e0       	ldi	r16, 0x01	; 1
    1586:	0e 0f       	add	r16, r30
    1588:	e8 0d       	add	r30, r8
    158a:	f9 2d       	mov	r31, r9
    158c:	f1 1d       	adc	r31, r1
    158e:	80 81       	ld	r24, Z
    1590:	b6 01       	movw	r22, r12
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	fe d4       	rcall	.+2556   	; 0x1f92 <fputc>
    1596:	e0 2f       	mov	r30, r16
    1598:	0f 11       	cpse	r16, r15
    159a:	f4 cf       	rjmp	.-24     	; 0x1584 <vfprintf+0x3a4>
    159c:	85 e6       	ldi	r24, 0x65	; 101
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	14 ff       	sbrs	r17, 4
    15a2:	02 c0       	rjmp	.+4      	; 0x15a8 <vfprintf+0x3c8>
    15a4:	85 e4       	ldi	r24, 0x45	; 69
    15a6:	90 e0       	ldi	r25, 0x00	; 0
    15a8:	b6 01       	movw	r22, r12
    15aa:	f3 d4       	rcall	.+2534   	; 0x1f92 <fputc>
    15ac:	b7 fc       	sbrc	r11, 7
    15ae:	06 c0       	rjmp	.+12     	; 0x15bc <vfprintf+0x3dc>
    15b0:	a1 14       	cp	r10, r1
    15b2:	b1 04       	cpc	r11, r1
    15b4:	b1 f4       	brne	.+44     	; 0x15e2 <vfprintf+0x402>
    15b6:	ec 85       	ldd	r30, Y+12	; 0x0c
    15b8:	e4 ff       	sbrs	r30, 4
    15ba:	13 c0       	rjmp	.+38     	; 0x15e2 <vfprintf+0x402>
    15bc:	b1 94       	neg	r11
    15be:	a1 94       	neg	r10
    15c0:	b1 08       	sbc	r11, r1
    15c2:	8d e2       	ldi	r24, 0x2D	; 45
    15c4:	b6 01       	movw	r22, r12
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	e4 d4       	rcall	.+2504   	; 0x1f92 <fputc>
    15ca:	80 e3       	ldi	r24, 0x30	; 48
    15cc:	2a e0       	ldi	r18, 0x0A	; 10
    15ce:	a2 16       	cp	r10, r18
    15d0:	b1 04       	cpc	r11, r1
    15d2:	4c f4       	brge	.+18     	; 0x15e6 <vfprintf+0x406>
    15d4:	b6 01       	movw	r22, r12
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	dc d4       	rcall	.+2488   	; 0x1f92 <fputc>
    15da:	b6 01       	movw	r22, r12
    15dc:	c5 01       	movw	r24, r10
    15de:	c0 96       	adiw	r24, 0x30	; 48
    15e0:	bb cf       	rjmp	.-138    	; 0x1558 <vfprintf+0x378>
    15e2:	8b e2       	ldi	r24, 0x2B	; 43
    15e4:	ef cf       	rjmp	.-34     	; 0x15c4 <vfprintf+0x3e4>
    15e6:	8f 5f       	subi	r24, 0xFF	; 255
    15e8:	fa e0       	ldi	r31, 0x0A	; 10
    15ea:	af 1a       	sub	r10, r31
    15ec:	b1 08       	sbc	r11, r1
    15ee:	ee cf       	rjmp	.-36     	; 0x15cc <vfprintf+0x3ec>
    15f0:	83 36       	cpi	r24, 0x63	; 99
    15f2:	c1 f0       	breq	.+48     	; 0x1624 <vfprintf+0x444>
    15f4:	83 37       	cpi	r24, 0x73	; 115
    15f6:	69 f1       	breq	.+90     	; 0x1652 <vfprintf+0x472>
    15f8:	83 35       	cpi	r24, 0x53	; 83
    15fa:	09 f0       	breq	.+2      	; 0x15fe <vfprintf+0x41e>
    15fc:	57 c0       	rjmp	.+174    	; 0x16ac <vfprintf+0x4cc>
    15fe:	35 01       	movw	r6, r10
    1600:	f2 e0       	ldi	r31, 0x02	; 2
    1602:	6f 0e       	add	r6, r31
    1604:	71 1c       	adc	r7, r1
    1606:	f5 01       	movw	r30, r10
    1608:	a0 80       	ld	r10, Z
    160a:	b1 80       	ldd	r11, Z+1	; 0x01
    160c:	6f 2d       	mov	r22, r15
    160e:	70 e0       	ldi	r23, 0x00	; 0
    1610:	06 fd       	sbrc	r16, 6
    1612:	02 c0       	rjmp	.+4      	; 0x1618 <vfprintf+0x438>
    1614:	6f ef       	ldi	r22, 0xFF	; 255
    1616:	7f ef       	ldi	r23, 0xFF	; 255
    1618:	c5 01       	movw	r24, r10
    161a:	a5 d4       	rcall	.+2378   	; 0x1f66 <strnlen_P>
    161c:	8c 87       	std	Y+12, r24	; 0x0c
    161e:	9d 87       	std	Y+13, r25	; 0x0d
    1620:	00 68       	ori	r16, 0x80	; 128
    1622:	0d c0       	rjmp	.+26     	; 0x163e <vfprintf+0x45e>
    1624:	35 01       	movw	r6, r10
    1626:	32 e0       	ldi	r19, 0x02	; 2
    1628:	63 0e       	add	r6, r19
    162a:	71 1c       	adc	r7, r1
    162c:	f5 01       	movw	r30, r10
    162e:	80 81       	ld	r24, Z
    1630:	89 83       	std	Y+1, r24	; 0x01
    1632:	21 e0       	ldi	r18, 0x01	; 1
    1634:	30 e0       	ldi	r19, 0x00	; 0
    1636:	2c 87       	std	Y+12, r18	; 0x0c
    1638:	3d 87       	std	Y+13, r19	; 0x0d
    163a:	54 01       	movw	r10, r8
    163c:	0f 77       	andi	r16, 0x7F	; 127
    163e:	03 fd       	sbrc	r16, 3
    1640:	06 c0       	rjmp	.+12     	; 0x164e <vfprintf+0x46e>
    1642:	2c 85       	ldd	r18, Y+12	; 0x0c
    1644:	3d 85       	ldd	r19, Y+13	; 0x0d
    1646:	52 16       	cp	r5, r18
    1648:	13 06       	cpc	r1, r19
    164a:	09 f0       	breq	.+2      	; 0x164e <vfprintf+0x46e>
    164c:	a0 f4       	brcc	.+40     	; 0x1676 <vfprintf+0x496>
    164e:	e5 2c       	mov	r14, r5
    1650:	28 c0       	rjmp	.+80     	; 0x16a2 <vfprintf+0x4c2>
    1652:	35 01       	movw	r6, r10
    1654:	32 e0       	ldi	r19, 0x02	; 2
    1656:	63 0e       	add	r6, r19
    1658:	71 1c       	adc	r7, r1
    165a:	f5 01       	movw	r30, r10
    165c:	a0 80       	ld	r10, Z
    165e:	b1 80       	ldd	r11, Z+1	; 0x01
    1660:	6f 2d       	mov	r22, r15
    1662:	70 e0       	ldi	r23, 0x00	; 0
    1664:	06 fd       	sbrc	r16, 6
    1666:	02 c0       	rjmp	.+4      	; 0x166c <vfprintf+0x48c>
    1668:	6f ef       	ldi	r22, 0xFF	; 255
    166a:	7f ef       	ldi	r23, 0xFF	; 255
    166c:	c5 01       	movw	r24, r10
    166e:	86 d4       	rcall	.+2316   	; 0x1f7c <strnlen>
    1670:	8c 87       	std	Y+12, r24	; 0x0c
    1672:	9d 87       	std	Y+13, r25	; 0x0d
    1674:	e3 cf       	rjmp	.-58     	; 0x163c <vfprintf+0x45c>
    1676:	b6 01       	movw	r22, r12
    1678:	80 e2       	ldi	r24, 0x20	; 32
    167a:	90 e0       	ldi	r25, 0x00	; 0
    167c:	8a d4       	rcall	.+2324   	; 0x1f92 <fputc>
    167e:	5a 94       	dec	r5
    1680:	e0 cf       	rjmp	.-64     	; 0x1642 <vfprintf+0x462>
    1682:	f5 01       	movw	r30, r10
    1684:	07 fd       	sbrc	r16, 7
    1686:	85 91       	lpm	r24, Z+
    1688:	07 ff       	sbrs	r16, 7
    168a:	81 91       	ld	r24, Z+
    168c:	5f 01       	movw	r10, r30
    168e:	b6 01       	movw	r22, r12
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	7f d4       	rcall	.+2302   	; 0x1f92 <fputc>
    1694:	e1 10       	cpse	r14, r1
    1696:	ea 94       	dec	r14
    1698:	8c 85       	ldd	r24, Y+12	; 0x0c
    169a:	9d 85       	ldd	r25, Y+13	; 0x0d
    169c:	01 97       	sbiw	r24, 0x01	; 1
    169e:	8c 87       	std	Y+12, r24	; 0x0c
    16a0:	9d 87       	std	Y+13, r25	; 0x0d
    16a2:	ec 85       	ldd	r30, Y+12	; 0x0c
    16a4:	fd 85       	ldd	r31, Y+13	; 0x0d
    16a6:	ef 2b       	or	r30, r31
    16a8:	61 f7       	brne	.-40     	; 0x1682 <vfprintf+0x4a2>
    16aa:	89 ce       	rjmp	.-750    	; 0x13be <vfprintf+0x1de>
    16ac:	84 36       	cpi	r24, 0x64	; 100
    16ae:	19 f0       	breq	.+6      	; 0x16b6 <vfprintf+0x4d6>
    16b0:	89 36       	cpi	r24, 0x69	; 105
    16b2:	09 f0       	breq	.+2      	; 0x16b6 <vfprintf+0x4d6>
    16b4:	70 c0       	rjmp	.+224    	; 0x1796 <vfprintf+0x5b6>
    16b6:	35 01       	movw	r6, r10
    16b8:	07 ff       	sbrs	r16, 7
    16ba:	62 c0       	rjmp	.+196    	; 0x1780 <vfprintf+0x5a0>
    16bc:	f4 e0       	ldi	r31, 0x04	; 4
    16be:	6f 0e       	add	r6, r31
    16c0:	71 1c       	adc	r7, r1
    16c2:	f5 01       	movw	r30, r10
    16c4:	60 81       	ld	r22, Z
    16c6:	71 81       	ldd	r23, Z+1	; 0x01
    16c8:	82 81       	ldd	r24, Z+2	; 0x02
    16ca:	93 81       	ldd	r25, Z+3	; 0x03
    16cc:	10 2f       	mov	r17, r16
    16ce:	1f 76       	andi	r17, 0x6F	; 111
    16d0:	97 ff       	sbrs	r25, 7
    16d2:	08 c0       	rjmp	.+16     	; 0x16e4 <vfprintf+0x504>
    16d4:	90 95       	com	r25
    16d6:	80 95       	com	r24
    16d8:	70 95       	com	r23
    16da:	61 95       	neg	r22
    16dc:	7f 4f       	sbci	r23, 0xFF	; 255
    16de:	8f 4f       	sbci	r24, 0xFF	; 255
    16e0:	9f 4f       	sbci	r25, 0xFF	; 255
    16e2:	10 68       	ori	r17, 0x80	; 128
    16e4:	2a e0       	ldi	r18, 0x0A	; 10
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	a4 01       	movw	r20, r8
    16ea:	83 d4       	rcall	.+2310   	; 0x1ff2 <__ultoa_invert>
    16ec:	a8 2e       	mov	r10, r24
    16ee:	a8 18       	sub	r10, r8
    16f0:	ba 2c       	mov	r11, r10
    16f2:	01 2f       	mov	r16, r17
    16f4:	16 ff       	sbrs	r17, 6
    16f6:	0a c0       	rjmp	.+20     	; 0x170c <vfprintf+0x52c>
    16f8:	0e 7f       	andi	r16, 0xFE	; 254
    16fa:	af 14       	cp	r10, r15
    16fc:	38 f4       	brcc	.+14     	; 0x170c <vfprintf+0x52c>
    16fe:	14 ff       	sbrs	r17, 4
    1700:	04 c0       	rjmp	.+8      	; 0x170a <vfprintf+0x52a>
    1702:	12 fd       	sbrc	r17, 2
    1704:	02 c0       	rjmp	.+4      	; 0x170a <vfprintf+0x52a>
    1706:	01 2f       	mov	r16, r17
    1708:	0e 7e       	andi	r16, 0xEE	; 238
    170a:	bf 2c       	mov	r11, r15
    170c:	04 ff       	sbrs	r16, 4
    170e:	9c c0       	rjmp	.+312    	; 0x1848 <vfprintf+0x668>
    1710:	fe 01       	movw	r30, r28
    1712:	ea 0d       	add	r30, r10
    1714:	f1 1d       	adc	r31, r1
    1716:	80 81       	ld	r24, Z
    1718:	80 33       	cpi	r24, 0x30	; 48
    171a:	09 f0       	breq	.+2      	; 0x171e <vfprintf+0x53e>
    171c:	8e c0       	rjmp	.+284    	; 0x183a <vfprintf+0x65a>
    171e:	09 7e       	andi	r16, 0xE9	; 233
    1720:	f0 2f       	mov	r31, r16
    1722:	f8 70       	andi	r31, 0x08	; 8
    1724:	ef 2e       	mov	r14, r31
    1726:	03 fd       	sbrc	r16, 3
    1728:	9d c0       	rjmp	.+314    	; 0x1864 <vfprintf+0x684>
    172a:	00 ff       	sbrs	r16, 0
    172c:	97 c0       	rjmp	.+302    	; 0x185c <vfprintf+0x67c>
    172e:	fa 2c       	mov	r15, r10
    1730:	b5 14       	cp	r11, r5
    1732:	10 f4       	brcc	.+4      	; 0x1738 <vfprintf+0x558>
    1734:	f5 0c       	add	r15, r5
    1736:	fb 18       	sub	r15, r11
    1738:	04 ff       	sbrs	r16, 4
    173a:	9a c0       	rjmp	.+308    	; 0x1870 <vfprintf+0x690>
    173c:	b6 01       	movw	r22, r12
    173e:	80 e3       	ldi	r24, 0x30	; 48
    1740:	90 e0       	ldi	r25, 0x00	; 0
    1742:	27 d4       	rcall	.+2126   	; 0x1f92 <fputc>
    1744:	02 ff       	sbrs	r16, 2
    1746:	08 c0       	rjmp	.+16     	; 0x1758 <vfprintf+0x578>
    1748:	88 e7       	ldi	r24, 0x78	; 120
    174a:	90 e0       	ldi	r25, 0x00	; 0
    174c:	01 ff       	sbrs	r16, 1
    174e:	02 c0       	rjmp	.+4      	; 0x1754 <vfprintf+0x574>
    1750:	88 e5       	ldi	r24, 0x58	; 88
    1752:	90 e0       	ldi	r25, 0x00	; 0
    1754:	b6 01       	movw	r22, r12
    1756:	1d d4       	rcall	.+2106   	; 0x1f92 <fputc>
    1758:	af 14       	cp	r10, r15
    175a:	08 f4       	brcc	.+2      	; 0x175e <vfprintf+0x57e>
    175c:	95 c0       	rjmp	.+298    	; 0x1888 <vfprintf+0x6a8>
    175e:	aa 94       	dec	r10
    1760:	0a 2d       	mov	r16, r10
    1762:	10 e0       	ldi	r17, 0x00	; 0
    1764:	0f 5f       	subi	r16, 0xFF	; 255
    1766:	1f 4f       	sbci	r17, 0xFF	; 255
    1768:	08 0d       	add	r16, r8
    176a:	19 1d       	adc	r17, r9
    176c:	f8 01       	movw	r30, r16
    176e:	82 91       	ld	r24, -Z
    1770:	8f 01       	movw	r16, r30
    1772:	b6 01       	movw	r22, r12
    1774:	90 e0       	ldi	r25, 0x00	; 0
    1776:	0d d4       	rcall	.+2074   	; 0x1f92 <fputc>
    1778:	80 16       	cp	r8, r16
    177a:	91 06       	cpc	r9, r17
    177c:	b9 f7       	brne	.-18     	; 0x176c <vfprintf+0x58c>
    177e:	1f ce       	rjmp	.-962    	; 0x13be <vfprintf+0x1de>
    1780:	f2 e0       	ldi	r31, 0x02	; 2
    1782:	6f 0e       	add	r6, r31
    1784:	71 1c       	adc	r7, r1
    1786:	f5 01       	movw	r30, r10
    1788:	60 81       	ld	r22, Z
    178a:	71 81       	ldd	r23, Z+1	; 0x01
    178c:	07 2e       	mov	r0, r23
    178e:	00 0c       	add	r0, r0
    1790:	88 0b       	sbc	r24, r24
    1792:	99 0b       	sbc	r25, r25
    1794:	9b cf       	rjmp	.-202    	; 0x16cc <vfprintf+0x4ec>
    1796:	10 2f       	mov	r17, r16
    1798:	85 37       	cpi	r24, 0x75	; 117
    179a:	a1 f4       	brne	.+40     	; 0x17c4 <vfprintf+0x5e4>
    179c:	1f 7e       	andi	r17, 0xEF	; 239
    179e:	2a e0       	ldi	r18, 0x0A	; 10
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	35 01       	movw	r6, r10
    17a4:	17 ff       	sbrs	r17, 7
    17a6:	40 c0       	rjmp	.+128    	; 0x1828 <vfprintf+0x648>
    17a8:	f4 e0       	ldi	r31, 0x04	; 4
    17aa:	6f 0e       	add	r6, r31
    17ac:	71 1c       	adc	r7, r1
    17ae:	f5 01       	movw	r30, r10
    17b0:	60 81       	ld	r22, Z
    17b2:	71 81       	ldd	r23, Z+1	; 0x01
    17b4:	82 81       	ldd	r24, Z+2	; 0x02
    17b6:	93 81       	ldd	r25, Z+3	; 0x03
    17b8:	a4 01       	movw	r20, r8
    17ba:	1b d4       	rcall	.+2102   	; 0x1ff2 <__ultoa_invert>
    17bc:	a8 2e       	mov	r10, r24
    17be:	a8 18       	sub	r10, r8
    17c0:	1f 77       	andi	r17, 0x7F	; 127
    17c2:	96 cf       	rjmp	.-212    	; 0x16f0 <vfprintf+0x510>
    17c4:	19 7f       	andi	r17, 0xF9	; 249
    17c6:	8f 36       	cpi	r24, 0x6F	; 111
    17c8:	61 f1       	breq	.+88     	; 0x1822 <vfprintf+0x642>
    17ca:	d8 f4       	brcc	.+54     	; 0x1802 <vfprintf+0x622>
    17cc:	88 35       	cpi	r24, 0x58	; 88
    17ce:	21 f1       	breq	.+72     	; 0x1818 <vfprintf+0x638>
    17d0:	f6 01       	movw	r30, r12
    17d2:	86 81       	ldd	r24, Z+6	; 0x06
    17d4:	97 81       	ldd	r25, Z+7	; 0x07
    17d6:	2f 96       	adiw	r28, 0x0f	; 15
    17d8:	cd bf       	out	0x3d, r28	; 61
    17da:	de bf       	out	0x3e, r29	; 62
    17dc:	df 91       	pop	r29
    17de:	cf 91       	pop	r28
    17e0:	1f 91       	pop	r17
    17e2:	0f 91       	pop	r16
    17e4:	ff 90       	pop	r15
    17e6:	ef 90       	pop	r14
    17e8:	df 90       	pop	r13
    17ea:	cf 90       	pop	r12
    17ec:	bf 90       	pop	r11
    17ee:	af 90       	pop	r10
    17f0:	9f 90       	pop	r9
    17f2:	8f 90       	pop	r8
    17f4:	7f 90       	pop	r7
    17f6:	6f 90       	pop	r6
    17f8:	5f 90       	pop	r5
    17fa:	4f 90       	pop	r4
    17fc:	3f 90       	pop	r3
    17fe:	2f 90       	pop	r2
    1800:	08 95       	ret
    1802:	80 37       	cpi	r24, 0x70	; 112
    1804:	39 f0       	breq	.+14     	; 0x1814 <vfprintf+0x634>
    1806:	88 37       	cpi	r24, 0x78	; 120
    1808:	19 f7       	brne	.-58     	; 0x17d0 <vfprintf+0x5f0>
    180a:	14 fd       	sbrc	r17, 4
    180c:	14 60       	ori	r17, 0x04	; 4
    180e:	20 e1       	ldi	r18, 0x10	; 16
    1810:	30 e0       	ldi	r19, 0x00	; 0
    1812:	c7 cf       	rjmp	.-114    	; 0x17a2 <vfprintf+0x5c2>
    1814:	10 61       	ori	r17, 0x10	; 16
    1816:	f9 cf       	rjmp	.-14     	; 0x180a <vfprintf+0x62a>
    1818:	04 fd       	sbrc	r16, 4
    181a:	16 60       	ori	r17, 0x06	; 6
    181c:	20 e1       	ldi	r18, 0x10	; 16
    181e:	32 e0       	ldi	r19, 0x02	; 2
    1820:	c0 cf       	rjmp	.-128    	; 0x17a2 <vfprintf+0x5c2>
    1822:	28 e0       	ldi	r18, 0x08	; 8
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	bd cf       	rjmp	.-134    	; 0x17a2 <vfprintf+0x5c2>
    1828:	f2 e0       	ldi	r31, 0x02	; 2
    182a:	6f 0e       	add	r6, r31
    182c:	71 1c       	adc	r7, r1
    182e:	f5 01       	movw	r30, r10
    1830:	60 81       	ld	r22, Z
    1832:	71 81       	ldd	r23, Z+1	; 0x01
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	80 e0       	ldi	r24, 0x00	; 0
    1838:	bf cf       	rjmp	.-130    	; 0x17b8 <vfprintf+0x5d8>
    183a:	02 fd       	sbrc	r16, 2
    183c:	02 c0       	rjmp	.+4      	; 0x1842 <vfprintf+0x662>
    183e:	b3 94       	inc	r11
    1840:	6f cf       	rjmp	.-290    	; 0x1720 <vfprintf+0x540>
    1842:	b3 94       	inc	r11
    1844:	b3 94       	inc	r11
    1846:	6c cf       	rjmp	.-296    	; 0x1720 <vfprintf+0x540>
    1848:	80 2f       	mov	r24, r16
    184a:	86 78       	andi	r24, 0x86	; 134
    184c:	09 f4       	brne	.+2      	; 0x1850 <vfprintf+0x670>
    184e:	68 cf       	rjmp	.-304    	; 0x1720 <vfprintf+0x540>
    1850:	f6 cf       	rjmp	.-20     	; 0x183e <vfprintf+0x65e>
    1852:	b6 01       	movw	r22, r12
    1854:	80 e2       	ldi	r24, 0x20	; 32
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	9c d3       	rcall	.+1848   	; 0x1f92 <fputc>
    185a:	b3 94       	inc	r11
    185c:	b5 14       	cp	r11, r5
    185e:	c8 f3       	brcs	.-14     	; 0x1852 <vfprintf+0x672>
    1860:	e1 2c       	mov	r14, r1
    1862:	6a cf       	rjmp	.-300    	; 0x1738 <vfprintf+0x558>
    1864:	e5 2c       	mov	r14, r5
    1866:	eb 18       	sub	r14, r11
    1868:	b5 14       	cp	r11, r5
    186a:	08 f4       	brcc	.+2      	; 0x186e <vfprintf+0x68e>
    186c:	65 cf       	rjmp	.-310    	; 0x1738 <vfprintf+0x558>
    186e:	f8 cf       	rjmp	.-16     	; 0x1860 <vfprintf+0x680>
    1870:	80 2f       	mov	r24, r16
    1872:	86 78       	andi	r24, 0x86	; 134
    1874:	09 f4       	brne	.+2      	; 0x1878 <vfprintf+0x698>
    1876:	70 cf       	rjmp	.-288    	; 0x1758 <vfprintf+0x578>
    1878:	8b e2       	ldi	r24, 0x2B	; 43
    187a:	01 ff       	sbrs	r16, 1
    187c:	80 e2       	ldi	r24, 0x20	; 32
    187e:	07 fd       	sbrc	r16, 7
    1880:	8d e2       	ldi	r24, 0x2D	; 45
    1882:	b6 01       	movw	r22, r12
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	67 cf       	rjmp	.-306    	; 0x1756 <vfprintf+0x576>
    1888:	b6 01       	movw	r22, r12
    188a:	80 e3       	ldi	r24, 0x30	; 48
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	81 d3       	rcall	.+1794   	; 0x1f92 <fputc>
    1890:	fa 94       	dec	r15
    1892:	62 cf       	rjmp	.-316    	; 0x1758 <vfprintf+0x578>
    1894:	b6 01       	movw	r22, r12
    1896:	80 e2       	ldi	r24, 0x20	; 32
    1898:	90 e0       	ldi	r25, 0x00	; 0
    189a:	7b d3       	rcall	.+1782   	; 0x1f92 <fputc>
    189c:	ea 94       	dec	r14
    189e:	8f cd       	rjmp	.-1250   	; 0x13be <vfprintf+0x1de>
    18a0:	24 e0       	ldi	r18, 0x04	; 4
    18a2:	e1 2c       	mov	r14, r1
    18a4:	25 15       	cp	r18, r5
    18a6:	08 f0       	brcs	.+2      	; 0x18aa <vfprintf+0x6ca>
    18a8:	54 cd       	rjmp	.-1368   	; 0x1352 <vfprintf+0x172>
    18aa:	84 e0       	ldi	r24, 0x04	; 4
    18ac:	45 cd       	rjmp	.-1398   	; 0x1338 <vfprintf+0x158>

000018ae <global constructors keyed to 65535_0_Code.ino.cpp.o.8311>:
_GLOBAL__I_65535_0_Code.ino.cpp.o.8311():
    18ae:	10 92 33 48 	sts	0x4833, r1	; 0x804833 <Serial3+0x2>
    18b2:	10 92 34 48 	sts	0x4834, r1	; 0x804834 <Serial3+0x3>
    18b6:	88 ee       	ldi	r24, 0xE8	; 232
    18b8:	93 e0       	ldi	r25, 0x03	; 3
    18ba:	a0 e0       	ldi	r26, 0x00	; 0
    18bc:	b0 e0       	ldi	r27, 0x00	; 0
    18be:	80 93 35 48 	sts	0x4835, r24	; 0x804835 <Serial3+0x4>
    18c2:	90 93 36 48 	sts	0x4836, r25	; 0x804836 <Serial3+0x5>
    18c6:	a0 93 37 48 	sts	0x4837, r26	; 0x804837 <Serial3+0x6>
    18ca:	b0 93 38 48 	sts	0x4838, r27	; 0x804838 <Serial3+0x7>
    18ce:	2e eb       	ldi	r18, 0xBE	; 190
    18d0:	30 e4       	ldi	r19, 0x40	; 64
    18d2:	20 93 31 48 	sts	0x4831, r18	; 0x804831 <Serial3>
    18d6:	30 93 32 48 	sts	0x4832, r19	; 0x804832 <Serial3+0x1>
    18da:	20 e6       	ldi	r18, 0x60	; 96
    18dc:	38 e0       	ldi	r19, 0x08	; 8
    18de:	20 93 39 48 	sts	0x4839, r18	; 0x804839 <Serial3+0x8>
    18e2:	30 93 3a 48 	sts	0x483A, r19	; 0x80483a <Serial3+0x9>
    18e6:	26 ef       	ldi	r18, 0xF6	; 246
    18e8:	31 e0       	ldi	r19, 0x01	; 1
    18ea:	20 93 3b 48 	sts	0x483B, r18	; 0x80483b <Serial3+0xa>
    18ee:	30 93 3c 48 	sts	0x483C, r19	; 0x80483c <Serial3+0xb>
    18f2:	22 e0       	ldi	r18, 0x02	; 2
    18f4:	20 93 3d 48 	sts	0x483D, r18	; 0x80483d <Serial3+0xc>
    18f8:	10 92 3e 48 	sts	0x483E, r1	; 0x80483e <Serial3+0xd>
    18fc:	10 92 3f 48 	sts	0x483F, r1	; 0x80483f <Serial3+0xe>
    1900:	10 92 6d 46 	sts	0x466D, r1	; 0x80466d <Wire+0x2>
    1904:	10 92 6e 46 	sts	0x466E, r1	; 0x80466e <Wire+0x3>
    1908:	80 93 6f 46 	sts	0x466F, r24	; 0x80466f <Wire+0x4>
    190c:	90 93 70 46 	sts	0x4670, r25	; 0x804670 <Wire+0x5>
    1910:	a0 93 71 46 	sts	0x4671, r26	; 0x804671 <Wire+0x6>
    1914:	b0 93 72 46 	sts	0x4672, r27	; 0x804672 <Wire+0x7>
    1918:	20 ed       	ldi	r18, 0xD0	; 208
    191a:	30 e4       	ldi	r19, 0x40	; 64
    191c:	20 93 6b 46 	sts	0x466B, r18	; 0x80466b <Wire>
    1920:	30 93 6c 46 	sts	0x466C, r19	; 0x80466c <Wire+0x1>
    1924:	40 e0       	ldi	r20, 0x00	; 0
    1926:	59 e0       	ldi	r21, 0x09	; 9
    1928:	40 93 73 46 	sts	0x4673, r20	; 0x804673 <Wire+0x8>
    192c:	50 93 74 46 	sts	0x4674, r21	; 0x804674 <Wire+0x9>
    1930:	10 92 cf 44 	sts	0x44CF, r1	; 0x8044cf <Wire1+0x2>
    1934:	10 92 d0 44 	sts	0x44D0, r1	; 0x8044d0 <Wire1+0x3>
    1938:	80 93 d1 44 	sts	0x44D1, r24	; 0x8044d1 <Wire1+0x4>
    193c:	90 93 d2 44 	sts	0x44D2, r25	; 0x8044d2 <Wire1+0x5>
    1940:	a0 93 d3 44 	sts	0x44D3, r26	; 0x8044d3 <Wire1+0x6>
    1944:	b0 93 d4 44 	sts	0x44D4, r27	; 0x8044d4 <Wire1+0x7>
    1948:	20 93 cd 44 	sts	0x44CD, r18	; 0x8044cd <Wire1>
    194c:	30 93 ce 44 	sts	0x44CE, r19	; 0x8044ce <Wire1+0x1>
    1950:	80 e2       	ldi	r24, 0x20	; 32
    1952:	99 e0       	ldi	r25, 0x09	; 9
    1954:	80 93 d5 44 	sts	0x44D5, r24	; 0x8044d5 <Wire1+0x8>
    1958:	90 93 d6 44 	sts	0x44D6, r25	; 0x8044d6 <Wire1+0x9>
    195c:	80 91 09 48 	lds	r24, 0x4809	; 0x804809 <guard variable for SequansControllerClass::instance()::instance>
    1960:	81 11       	cpse	r24, r1
    1962:	03 c0       	rjmp	.+6      	; 0x196a <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0xbc>
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	80 93 09 48 	sts	0x4809, r24	; 0x804809 <guard variable for SequansControllerClass::instance()::instance>
    196a:	80 91 11 48 	lds	r24, 0x4811	; 0x804811 <guard variable for SecurityProfileClass::instance()::instance>
    196e:	81 11       	cpse	r24, r1
    1970:	03 c0       	rjmp	.+6      	; 0x1978 <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0xca>
    1972:	81 e0       	ldi	r24, 0x01	; 1
    1974:	80 93 11 48 	sts	0x4811, r24	; 0x804811 <guard variable for SecurityProfileClass::instance()::instance>
    1978:	80 91 19 48 	lds	r24, 0x4819	; 0x804819 <guard variable for MqttClientClass::instance()::instance>
    197c:	81 11       	cpse	r24, r1
    197e:	03 c0       	rjmp	.+6      	; 0x1986 <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0xd8>
    1980:	81 e0       	ldi	r24, 0x01	; 1
    1982:	80 93 19 48 	sts	0x4819, r24	; 0x804819 <guard variable for MqttClientClass::instance()::instance>
    1986:	80 91 21 48 	lds	r24, 0x4821	; 0x804821 <guard variable for LteClass::instance()::instance>
    198a:	81 11       	cpse	r24, r1
    198c:	03 c0       	rjmp	.+6      	; 0x1994 <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0xe6>
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	80 93 21 48 	sts	0x4821, r24	; 0x804821 <guard variable for LteClass::instance()::instance>
    1994:	80 91 29 48 	lds	r24, 0x4829	; 0x804829 <guard variable for LowPowerClass::instance()::instance>
    1998:	81 11       	cpse	r24, r1
    199a:	03 c0       	rjmp	.+6      	; 0x19a2 <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0xf4>
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	80 93 29 48 	sts	0x4829, r24	; 0x804829 <guard variable for LowPowerClass::instance()::instance>
    19a2:	81 e3       	ldi	r24, 0x31	; 49
    19a4:	98 e4       	ldi	r25, 0x48	; 72
    19a6:	80 93 c4 48 	sts	0x48C4, r24	; 0x8048c4 <Log>
    19aa:	90 93 c5 48 	sts	0x48C5, r25	; 0x8048c5 <Log+0x1>
    19ae:	83 e0       	ldi	r24, 0x03	; 3
    19b0:	90 e0       	ldi	r25, 0x00	; 0
    19b2:	80 93 c6 48 	sts	0x48C6, r24	; 0x8048c6 <Log+0x2>
    19b6:	90 93 c7 48 	sts	0x48C7, r25	; 0x8048c7 <Log+0x3>
    19ba:	80 91 c8 48 	lds	r24, 0x48C8	; 0x8048c8 <guard variable for HttpClientClass::instance()::instance>
    19be:	81 11       	cpse	r24, r1
    19c0:	03 c0       	rjmp	.+6      	; 0x19c8 <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0x11a>
    19c2:	81 e0       	ldi	r24, 0x01	; 1
    19c4:	80 93 c8 48 	sts	0x48C8, r24	; 0x8048c8 <guard variable for HttpClientClass::instance()::instance>
    19c8:	10 92 d0 48 	sts	0x48D0, r1	; 0x8048d0 <PHONE_NUMBER>
    19cc:	10 92 d1 48 	sts	0x48D1, r1	; 0x8048d1 <PHONE_NUMBER+0x1>
    19d0:	10 92 d2 48 	sts	0x48D2, r1	; 0x8048d2 <PHONE_NUMBER+0x2>
    19d4:	10 92 d3 48 	sts	0x48D3, r1	; 0x8048d3 <PHONE_NUMBER+0x3>
    19d8:	10 92 d4 48 	sts	0x48D4, r1	; 0x8048d4 <PHONE_NUMBER+0x4>
    19dc:	10 92 d5 48 	sts	0x48D5, r1	; 0x8048d5 <PHONE_NUMBER+0x5>
    19e0:	6d e0       	ldi	r22, 0x0D	; 13
    19e2:	70 e0       	ldi	r23, 0x00	; 0
    19e4:	90 e0       	ldi	r25, 0x00	; 0
    19e6:	80 e0       	ldi	r24, 0x00	; 0
    19e8:	a9 d4       	rcall	.+2386   	; 0x233c <realloc>
    19ea:	00 97       	sbiw	r24, 0x00	; 0
    19ec:	f9 f0       	breq	.+62     	; 0x1a2c <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0x17e>
    19ee:	80 93 d0 48 	sts	0x48D0, r24	; 0x8048d0 <PHONE_NUMBER>
    19f2:	90 93 d1 48 	sts	0x48D1, r25	; 0x8048d1 <PHONE_NUMBER+0x1>
    19f6:	2c e0       	ldi	r18, 0x0C	; 12
    19f8:	30 e0       	ldi	r19, 0x00	; 0
    19fa:	20 93 d2 48 	sts	0x48D2, r18	; 0x8048d2 <PHONE_NUMBER+0x2>
    19fe:	30 93 d3 48 	sts	0x48D3, r19	; 0x8048d3 <PHONE_NUMBER+0x3>
    1a02:	20 91 d4 48 	lds	r18, 0x48D4	; 0x8048d4 <PHONE_NUMBER+0x4>
    1a06:	30 91 d5 48 	lds	r19, 0x48D5	; 0x8048d5 <PHONE_NUMBER+0x5>
    1a0a:	23 2b       	or	r18, r19
    1a0c:	11 f4       	brne	.+4      	; 0x1a12 <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0x164>
    1a0e:	fc 01       	movw	r30, r24
    1a10:	10 82       	st	Z, r1
    1a12:	8c e0       	ldi	r24, 0x0C	; 12
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	80 93 d4 48 	sts	0x48D4, r24	; 0x8048d4 <PHONE_NUMBER+0x4>
    1a1a:	90 93 d5 48 	sts	0x48D5, r25	; 0x8048d5 <PHONE_NUMBER+0x5>
    1a1e:	6c e1       	ldi	r22, 0x1C	; 28
    1a20:	71 e4       	ldi	r23, 0x41	; 65
    1a22:	80 91 d0 48 	lds	r24, 0x48D0	; 0x8048d0 <PHONE_NUMBER>
    1a26:	90 91 d1 48 	lds	r25, 0x48D1	; 0x8048d1 <PHONE_NUMBER+0x1>
    1a2a:	7a c5       	rjmp	.+2804   	; 0x2520 <strcpy>
    1a2c:	80 91 d0 48 	lds	r24, 0x48D0	; 0x8048d0 <PHONE_NUMBER>
    1a30:	90 91 d1 48 	lds	r25, 0x48D1	; 0x8048d1 <PHONE_NUMBER+0x1>
    1a34:	00 97       	sbiw	r24, 0x00	; 0
    1a36:	09 f0       	breq	.+2      	; 0x1a3a <global constructors keyed to 65535_0_Code.ino.cpp.o.8311+0x18c>
    1a38:	f8 d3       	rcall	.+2032   	; 0x222a <free>
    1a3a:	10 92 d0 48 	sts	0x48D0, r1	; 0x8048d0 <PHONE_NUMBER>
    1a3e:	10 92 d1 48 	sts	0x48D1, r1	; 0x8048d1 <PHONE_NUMBER+0x1>
    1a42:	10 92 d4 48 	sts	0x48D4, r1	; 0x8048d4 <PHONE_NUMBER+0x4>
    1a46:	10 92 d5 48 	sts	0x48D5, r1	; 0x8048d5 <PHONE_NUMBER+0x5>
    1a4a:	10 92 d2 48 	sts	0x48D2, r1	; 0x8048d2 <PHONE_NUMBER+0x2>
    1a4e:	10 92 d3 48 	sts	0x48D3, r1	; 0x8048d3 <PHONE_NUMBER+0x3>
    1a52:	08 95       	ret

00001a54 <main>:
init_clock():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1642
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
    #elif (F_CPU == 28000000)
      /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
    #elif (F_CPU == 24000000)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    1a54:	88 ed       	ldi	r24, 0xD8	; 216
    1a56:	94 e2       	ldi	r25, 0x24	; 36
    1a58:	84 bf       	out	0x34, r24	; 52
    1a5a:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
init_TCA0():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1912
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    1a5e:	21 e0       	ldi	r18, 0x01	; 1
    1a60:	20 93 03 0a 	sts	0x0A03, r18	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7e0a03>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1917

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1a64:	8e ef       	ldi	r24, 0xFE	; 254
    1a66:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7e0a26>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1918
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    1a6a:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7e0a27>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1945
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    1a6e:	9b e0       	ldi	r25, 0x0B	; 11
    1a70:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7e0a00>
init_timers():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1890
uint8_t __PeripheralControl = 0xFF;

void init_timers() {
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    1a74:	32 e0       	ldi	r19, 0x02	; 2
    1a76:	30 93 e6 05 	sts	0x05E6, r19	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
init_TCA1():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1963

#if defined(TCA1)
void __attribute__((weak)) init_TCA1() {

  /* Enable Split Mode */
  TCA1.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    1a7a:	20 93 43 0a 	sts	0x0A43, r18	; 0x800a43 <__TEXT_REGION_LENGTH__+0x7e0a43>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1966

  /* Period setting, 8-bit register in SPLIT mode */
  TCA1.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1a7e:	80 93 66 0a 	sts	0x0A66, r24	; 0x800a66 <__TEXT_REGION_LENGTH__+0x7e0a66>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1967
  TCA1.SPLIT.HPER    = PWM_TIMER_PERIOD;
    1a82:	80 93 67 0a 	sts	0x0A67, r24	; 0x800a67 <__TEXT_REGION_LENGTH__+0x7e0a67>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1978
    TCA1.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA1) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA1 to different divider"
    #endif
    TCA1.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    1a86:	90 93 40 0a 	sts	0x0A40, r25	; 0x800a40 <__TEXT_REGION_LENGTH__+0x7e0a40>
init_TCBs():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2000
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    1a8a:	90 93 e7 05 	sts	0x05E7, r25	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7e05e7>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1a8e:	37 e0       	ldi	r19, 0x07	; 7
    1a90:	30 93 01 0b 	sts	0x0B01, r19	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7e0b01>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1a94:	80 93 0c 0b 	sts	0x0B0C, r24	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7e0b0c>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1a98:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7e0b0d>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1a9c:	95 e0       	ldi	r25, 0x05	; 5
    1a9e:	90 93 00 0b 	sts	0x0B00, r25	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7e0b00>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1aa2:	30 93 11 0b 	sts	0x0B11, r19	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7e0b11>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1aa6:	80 93 1c 0b 	sts	0x0B1C, r24	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7e0b1c>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1aaa:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7e0b1d>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1aae:	90 93 10 0b 	sts	0x0B10, r25	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7e0b10>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    1ab2:	30 93 31 0b 	sts	0x0B31, r19	; 0x800b31 <__TEXT_REGION_LENGTH__+0x7e0b31>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    1ab6:	80 93 3c 0b 	sts	0x0B3C, r24	; 0x800b3c <__TEXT_REGION_LENGTH__+0x7e0b3c>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    1aba:	10 92 3d 0b 	sts	0x0B3D, r1	; 0x800b3d <__TEXT_REGION_LENGTH__+0x7e0b3d>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    1abe:	90 93 30 0b 	sts	0x0B30, r25	; 0x800b30 <__TEXT_REGION_LENGTH__+0x7e0b30>
init_TCD0():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2104
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
    1ac2:	4f ef       	ldi	r20, 0xFF	; 255
    1ac4:	5f e0       	ldi	r21, 0x0F	; 15
    1ac6:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7e0baa>
    1aca:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7e0bab>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2108
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    1ace:	80 e8       	ldi	r24, 0x80	; 128
    1ad0:	80 93 82 0b 	sts	0x0B82, r24	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7e0b82>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2110
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
    1ad4:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7e0b81>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2113
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    1ad8:	4b ef       	ldi	r20, 0xFB	; 251
    1ada:	53 e0       	ldi	r21, 0x03	; 3
    1adc:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7e0bae>
    1ae0:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7e0baf>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:2122
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    1ae4:	81 e7       	ldi	r24, 0x71	; 113
    1ae6:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
init_ADC0():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1536
    #elif F_CPU >= 36000000
      ADC0.CTRLC = ADC_PRESC_DIV28_gc; // 1.286 @ 36 MHz
    #elif F_CPU >  28000000
      ADC0.CTRLC = ADC_PRESC_DIV24_gc; // 1.33 @ 32 MHz, 1.
    #elif F_CPU >= 24000000
      ADC0.CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    1aea:	90 93 02 06 	sts	0x0602, r25	; 0x800602 <__TEXT_REGION_LENGTH__+0x7e0602>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1548
    #elif F_CPU >= 4000000
      ADC0.CTRLC = ADC_PRESC_DIV4_gc;  // 1 MHz
    #else  // 1 MHz / 2 = 500 kHz - the lowest setting
      ADC0.CTRLC = ADC_PRESC_DIV2_gc;
    #endif
    ADC0.SAMPCTRL = 14; // 16 ADC clock sampling time - should be about the same amount of *time* as originally?
    1aee:	8e e0       	ldi	r24, 0x0E	; 14
    1af0:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x7e0605>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1550
    // This is WAY conservative! We could drop it down...
    ADC0.CTRLD = ADC_INITDLY_DLY64_gc; // VREF can take 50uS to become ready, and we're running the ADC clock
    1af4:	80 e6       	ldi	r24, 0x60	; 96
    1af6:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <__TEXT_REGION_LENGTH__+0x7e0603>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1553
    // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
    /* Enable ADC */
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    1afa:	90 93 00 06 	sts	0x0600, r25	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
analogReference():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:117


void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    1afe:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    1b02:	88 7f       	andi	r24, 0xF8	; 248
    1b04:	85 60       	ori	r24, 0x05	; 5
    1b06:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
DACReference():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_analog.c:124
}

void DACReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.DAC0REF = (VREF.DAC0REF & ~(VREF_REFSEL_gm))|(mode);
    1b0a:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
    1b0e:	88 7f       	andi	r24, 0xF8	; 248
    1b10:	85 60       	ori	r24, 0x05	; 5
    1b12:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
init_millis():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1448
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    1b16:	8f ed       	ldi	r24, 0xDF	; 223
    1b18:	9e e2       	ldi	r25, 0x2E	; 46
    1b1a:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7e0b2c>
    1b1e:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7e0b2d>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1450
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    1b22:	20 93 25 0b 	sts	0x0B25, r18	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7e0b25>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1452
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    1b26:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7e0b21>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring.c:1454
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    1b2a:	83 e0       	ldi	r24, 0x03	; 3
    1b2c:	80 93 20 0b 	sts	0x0B20, r24	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7e0b20>
main():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/main.cpp:52
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    1b30:	78 94       	sei
begin():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/log.cpp:66

    this->setLogLevel(ll);
    return true;
}

void LogClass::begin(const uint32_t baud_rate) { this->uart->begin(baud_rate); }
    1b32:	c0 91 c4 48 	lds	r28, 0x48C4	; 0x8048c4 <Log>
    1b36:	d0 91 c5 48 	lds	r29, 0x48C5	; 0x8048c5 <Log+0x1>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:540
    }

    void HardwareSerial::begin(unsigned long baud, uint16_t options) {
      // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
      // without first calling end()
      if (_state & 1) {
    1b3a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b3c:	80 ff       	sbrs	r24, 0
    1b3e:	12 c0       	rjmp	.+36     	; 0x1b64 <main+0x110>
end():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:684
        return NOT_A_MUX; // At this point, we have checked all group codes for this peripheral. It ain't there. Return NOT_A_MUX.
      }
    }
    void HardwareSerial::end() {
      // wait for transmission of outgoing data
      flush();
    1b40:	e8 81       	ld	r30, Y
    1b42:	f9 81       	ldd	r31, Y+1	; 0x01
    1b44:	06 80       	ldd	r0, Z+6	; 0x06
    1b46:	f7 81       	ldd	r31, Z+7	; 0x07
    1b48:	e0 2d       	mov	r30, r0
    1b4a:	ce 01       	movw	r24, r28
    1b4c:	09 95       	icall
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:687
      // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
      // TXCIE only used in half duplex - we can just turn the damned thing off yo!
      volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
    1b4e:	e8 85       	ldd	r30, Y+8	; 0x08
    1b50:	f9 85       	ldd	r31, Y+9	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:688
      temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
    1b52:	86 81       	ldd	r24, Z+6	; 0x06
    1b54:	16 82       	std	Z+6, r1	; 0x06
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:689
      temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
    1b56:	85 81       	ldd	r24, Z+5	; 0x05
    1b58:	15 82       	std	Z+5, r1	; 0x05
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:690
      temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error. TXCIE only used in half duplex
    1b5a:	80 e4       	ldi	r24, 0x40	; 64
    1b5c:	84 83       	std	Z+4, r24	; 0x04
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:692
      // clear any received data
      _rx_buffer_head = _rx_buffer_tail;
    1b5e:	88 89       	ldd	r24, Y+16	; 0x10
    1b60:	8f 87       	std	Y+15, r24	; 0x0f
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:696

      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    1b62:	1e 86       	std	Y+14, r1	; 0x0e
begin():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:579
        setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
      }
      if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
        setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
      }
      uint8_t oldSREG = SREG;
    1b64:	6f b7       	in	r22, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:580
      cli();
    1b66:	f8 94       	cli
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:581
      volatile USART_t* MyUSART = _hwserial_module;
    1b68:	e8 85       	ldd	r30, Y+8	; 0x08
    1b6a:	f9 85       	ldd	r31, Y+9	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:582
      (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
    1b6c:	16 82       	std	Z+6, r1	; 0x06
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:583
      (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
    1b6e:	33 e0       	ldi	r19, 0x03	; 3
    1b70:	37 83       	std	Z+7, r19	; 0x07
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:584
      (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
    1b72:	81 e4       	ldi	r24, 0x41	; 65
    1b74:	93 e0       	ldi	r25, 0x03	; 3
    1b76:	80 87       	std	Z+8, r24	; 0x08
    1b78:	91 87       	std	Z+9, r25	; 0x09
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:590
      if (ctrla & 0x20) {                       // Now we have to do a bit of work
        setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
        (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
        (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
      } else {
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
    1b7a:	14 86       	std	Z+12, r1	; 0x0c
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:592
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
    1b7c:	80 e8       	ldi	r24, 0x80	; 128
    1b7e:	85 83       	std	Z+5, r24	; 0x05
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:593
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
    1b80:	80 ec       	ldi	r24, 0xC0	; 192
    1b82:	86 83       	std	Z+6, r24	; 0x06
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:594
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
    1b84:	2d 85       	ldd	r18, Y+13	; 0x0d
    1b86:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b88:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b8a:	9b 85       	ldd	r25, Y+11	; 0x0b
_set_pins():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:641
    //  1  1  1  0      TX set output, RX not changed. Loopback mode: you can only see what you send since TX is OUTPUT and that's what's connected to RX.
    //  1  1  1  1      TX set input pullup. Half-duplex mode.
    // * indicates that RS485 mode if requested will be enabled, even though it is inappropriate. These configurations are documented unsupported.
    // Static
    void HardwareSerial::_set_pins(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_setting, uint8_t enmask) {
      uint8_t* mux_row_ptr   = mux_table_ptr + (mux_setting * USART_PINS_WIDTH);
    1b8c:	fc 01       	movw	r30, r24
    1b8e:	23 9f       	mul	r18, r19
    1b90:	e0 0d       	add	r30, r0
    1b92:	f1 1d       	adc	r31, r1
    1b94:	11 24       	eor	r1, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:642
      uint16_t mux_row_gc_tx = pgm_read_word_near(mux_row_ptr); // Clever trick for faster PGM reads of consecutive bytes!
    1b96:	45 91       	lpm	r20, Z+
    1b98:	54 91       	lpm	r21, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:644
      uint8_t mux_group_code = (uint8_t) (mux_row_gc_tx);       // this is the mux
      if (mux_setting < mux_count) {              // if false, pinmux none was selected, and we skip the pin configuration.
    1b9a:	27 17       	cp	r18, r23
    1b9c:	08 f0       	brcs	.+2      	; 0x1ba0 <main+0x14c>
    1b9e:	3e c0       	rjmp	.+124    	; 0x1c1c <main+0x1c8>
_pinMode():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1ba0:	59 32       	cpi	r21, 0x29	; 41
    1ba2:	90 f4       	brcc	.+36     	; 0x1bc8 <main+0x174>
check_valid_digital_pin():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/Arduino.h:712
    1ba4:	25 2f       	mov	r18, r21
    1ba6:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:79
    1ba8:	f9 01       	movw	r30, r18
    1baa:	ef 56       	subi	r30, 0x6F	; 111
    1bac:	ff 4b       	sbci	r31, 0xBF	; 191
    1bae:	a0 81       	ld	r26, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1bb0:	af 3f       	cpi	r26, 0xFF	; 255
    1bb2:	51 f0       	breq	.+20     	; 0x1bc8 <main+0x174>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1bb4:	21 5c       	subi	r18, 0xC1	; 193
    1bb6:	3f 4b       	sbci	r19, 0xBF	; 191
    1bb8:	e9 01       	movw	r28, r18
    1bba:	e8 81       	ld	r30, Y
    1bbc:	d0 e2       	ldi	r29, 0x20	; 32
    1bbe:	ed 9f       	mul	r30, r29
    1bc0:	f0 01       	movw	r30, r0
    1bc2:	11 24       	eor	r1, r1
    1bc4:	fc 5f       	subi	r31, 0xFC	; 252
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1bc6:	a1 83       	std	Z+1, r26	; 0x01
_set_pins():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:653
          pinMode(mux_pin_tx, OUTPUT);            // If and only if TX is enabled and open drain isn't should the TX pin be output.
        } else if (enmask & 0x50) {               // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
          pinMode(mux_pin_tx, INPUT_PULLUP);      // TX should be INPUT_PULLUP.
        }
        if (enmask & 0x80 && !(enmask & 0x10)) {  // Likewise if RX is enabled, unless loopback mode is too
          pinMode(mux_pin_tx + 1, INPUT_PULLUP);  // (in which case we caught it above), it should be pulled up
    1bc8:	21 e0       	ldi	r18, 0x01	; 1
    1bca:	25 0f       	add	r18, r21
_pinMode():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1bcc:	29 32       	cpi	r18, 0x29	; 41
    1bce:	30 f5       	brcc	.+76     	; 0x1c1c <main+0x1c8>
check_valid_digital_pin():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/Arduino.h:712
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:79
    1bd2:	f9 01       	movw	r30, r18
    1bd4:	ef 56       	subi	r30, 0x6F	; 111
    1bd6:	ff 4b       	sbci	r31, 0xBF	; 191
    1bd8:	c0 81       	ld	r28, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1bda:	cf 3f       	cpi	r28, 0xFF	; 255
    1bdc:	f9 f0       	breq	.+62     	; 0x1c1c <main+0x1c8>
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1bde:	f9 01       	movw	r30, r18
    1be0:	e1 5c       	subi	r30, 0xC1	; 193
    1be2:	ff 4b       	sbci	r31, 0xBF	; 191
    1be4:	a0 81       	ld	r26, Z
    1be6:	e0 e2       	ldi	r30, 0x20	; 32
    1be8:	ae 9f       	mul	r26, r30
    1bea:	d0 01       	movw	r26, r0
    1bec:	11 24       	eor	r1, r1
    1bee:	bc 5f       	subi	r27, 0xFC	; 252
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    1bf0:	28 59       	subi	r18, 0x98	; 152
    1bf2:	3f 4b       	sbci	r19, 0xBF	; 191
    1bf4:	f9 01       	movw	r30, r18
    1bf6:	d0 81       	ld	r29, Z
main():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    1bf8:	f0 e0       	ldi	r31, 0x00	; 0
    1bfa:	e0 e0       	ldi	r30, 0x00	; 0
_pinMode():
    1bfc:	d8 30       	cpi	r29, 0x08	; 8
    1bfe:	30 f4       	brcc	.+12     	; 0x1c0c <main+0x1b8>
    1c00:	9d 01       	movw	r18, r26
    1c02:	20 5f       	subi	r18, 0xF0	; 240
    1c04:	3f 4f       	sbci	r19, 0xFF	; 255
    1c06:	f9 01       	movw	r30, r18
    1c08:	ed 0f       	add	r30, r29
    1c0a:	f1 1d       	adc	r31, r1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
    1c0c:	3f b7       	in	r19, 0x3f	; 63
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
    1c0e:	f8 94       	cli
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1c10:	12 96       	adiw	r26, 0x02	; 2
    1c12:	cc 93       	st	X, r28
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:95
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    1c14:	20 81       	ld	r18, Z
    1c16:	28 60       	ori	r18, 0x08	; 8
    1c18:	20 83       	st	Z, r18
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/wiring_digital.c:99
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    }
    SREG = status;                      /* Restore state */
    1c1a:	3f bf       	out	0x3f, r19	; 63
_mux_set():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:601
    }

// Static
    void HardwareSerial::_mux_set(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_code) {
    #if HWSERIAL_MUX_REG_COUNT > 1  // for big pincount devices that have more then one USART PORTMUX register
      uint8_t* mux_info_ptr = mux_table_ptr + (mux_count * USART_PINS_WIDTH) + 1;
    1c1c:	fc 01       	movw	r30, r24
    1c1e:	23 e0       	ldi	r18, 0x03	; 3
    1c20:	72 9f       	mul	r23, r18
    1c22:	e0 0d       	add	r30, r0
    1c24:	f1 1d       	adc	r31, r1
    1c26:	11 24       	eor	r1, r1
    1c28:	31 96       	adiw	r30, 0x01	; 1
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:602
      uint16_t mux_options_off_gm = pgm_read_word_near(mux_info_ptr);  /* pointer offset to the second columun
    1c2a:	25 91       	lpm	r18, Z+
    1c2c:	34 91       	lpm	r19, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:605
      at the end bottom row of the table, with info about the mux options, rather than a specific option
      Low byte is the offset from USARTROUTEA, second byte is the group mask. */
      volatile uint8_t* portmux  = (uint8_t*)(HWSERIAL_MUX_REGISTER_BASE + (uint8_t)mux_options_off_gm); // offset
    1c2e:	f9 01       	movw	r30, r18
    1c30:	ff 27       	eor	r31, r31
    1c32:	ee 51       	subi	r30, 0x1E	; 30
    1c34:	fa 4f       	sbci	r31, 0xFA	; 250
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:606
      uint8_t temp   = *portmux;
    1c36:	90 81       	ld	r25, Z
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:607
      temp          &= ~((uint8_t) (mux_options_off_gm >> 8)); // Group Mask
    1c38:	83 2f       	mov	r24, r19
    1c3a:	80 95       	com	r24
    1c3c:	89 23       	and	r24, r25
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:608
      temp          |= mux_code;
    1c3e:	48 2b       	or	r20, r24
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:609
      *portmux       = temp;
    1c40:	40 83       	st	Z, r20
begin():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/UART.cpp:595
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
      SREG = oldSREG;                             // re-enable interrupts, and we're done.
    1c42:	6f bf       	out	0x3f, r22	; 63
main():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:96
    const uint8_t led_pin = getLedPin(led);
    digitalWrite(led_pin, !digitalRead(led_pin));
}

void LedCtrlClass::startupCycle() {
    for (int i = int(Led::CELL); i <= int(Led::USER); i++) {
    1c44:	d0 e0       	ldi	r29, 0x00	; 0
    1c46:	c0 e0       	ldi	r28, 0x00	; 0
on():
    1c48:	ce 01       	movw	r24, r28
    1c4a:	0e 94 be 05 	call	0xb7c	; 0xb7c <LedCtrlClass::on(Led, bool) [clone .part.1] [clone .constprop.23]>
startupCycle():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:98
        this->on(Led(i));
        delay(50);
    1c4e:	62 e3       	ldi	r22, 0x32	; 50
    1c50:	70 e0       	ldi	r23, 0x00	; 0
    1c52:	80 e0       	ldi	r24, 0x00	; 0
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	0e 94 c3 01 	call	0x386	; 0x386 <delay>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:96
    const uint8_t led_pin = getLedPin(led);
    digitalWrite(led_pin, !digitalRead(led_pin));
}

void LedCtrlClass::startupCycle() {
    for (int i = int(Led::CELL); i <= int(Led::USER); i++) {
    1c5a:	21 96       	adiw	r28, 0x01	; 1
    1c5c:	c5 30       	cpi	r28, 0x05	; 5
    1c5e:	d1 05       	cpc	r29, r1
    1c60:	99 f7       	brne	.-26     	; 0x1c48 <main+0x1f4>
main():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:101
        this->on(Led(i));
        delay(50);
    }

    for (int i = int(Led::CELL); i <= int(Led::USER); i++) {
    1c62:	d0 e0       	ldi	r29, 0x00	; 0
    1c64:	c0 e0       	ldi	r28, 0x00	; 0
off():
    1c66:	ce 01       	movw	r24, r28
    1c68:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
startupCycle():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:103
        this->off(Led(i));
        delay(50);
    1c6c:	62 e3       	ldi	r22, 0x32	; 50
    1c6e:	70 e0       	ldi	r23, 0x00	; 0
    1c70:	80 e0       	ldi	r24, 0x00	; 0
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	0e 94 c3 01 	call	0x386	; 0x386 <delay>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:101
    for (int i = int(Led::CELL); i <= int(Led::USER); i++) {
        this->on(Led(i));
        delay(50);
    }

    for (int i = int(Led::CELL); i <= int(Led::USER); i++) {
    1c78:	21 96       	adiw	r28, 0x01	; 1
    1c7a:	c5 30       	cpi	r28, 0x05	; 5
    1c7c:	d1 05       	cpc	r29, r1
    1c7e:	99 f7       	brne	.-26     	; 0x1c66 <main+0x212>
main():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:106
        this->off(Led(i));
        delay(50);
    }

    for (int i = int(Led::USER); i >= int(Led::CELL); i--) {
    1c80:	c4 e0       	ldi	r28, 0x04	; 4
    1c82:	d0 e0       	ldi	r29, 0x00	; 0
on():
    1c84:	ce 01       	movw	r24, r28
    1c86:	0e 94 be 05 	call	0xb7c	; 0xb7c <LedCtrlClass::on(Led, bool) [clone .part.1] [clone .constprop.23]>
startupCycle():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:108
        this->on(Led(i));
        delay(50);
    1c8a:	62 e3       	ldi	r22, 0x32	; 50
    1c8c:	70 e0       	ldi	r23, 0x00	; 0
    1c8e:	80 e0       	ldi	r24, 0x00	; 0
    1c90:	90 e0       	ldi	r25, 0x00	; 0
    1c92:	0e 94 c3 01 	call	0x386	; 0x386 <delay>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:106
    for (int i = int(Led::CELL); i <= int(Led::USER); i++) {
        this->off(Led(i));
        delay(50);
    }

    for (int i = int(Led::USER); i >= int(Led::CELL); i--) {
    1c96:	21 97       	sbiw	r28, 0x01	; 1
    1c98:	a8 f7       	brcc	.-22     	; 0x1c84 <main+0x230>
main():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:111
        this->on(Led(i));
        delay(50);
    }

    for (int i = int(Led::USER); i >= int(Led::CELL); i--) {
    1c9a:	c4 e0       	ldi	r28, 0x04	; 4
    1c9c:	d0 e0       	ldi	r29, 0x00	; 0
off():
    1c9e:	ce 01       	movw	r24, r28
    1ca0:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
startupCycle():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:113
        this->off(Led(i));
        delay(50);
    1ca4:	62 e3       	ldi	r22, 0x32	; 50
    1ca6:	70 e0       	ldi	r23, 0x00	; 0
    1ca8:	80 e0       	ldi	r24, 0x00	; 0
    1caa:	90 e0       	ldi	r25, 0x00	; 0
    1cac:	0e 94 c3 01 	call	0x386	; 0x386 <delay>
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:111
    for (int i = int(Led::USER); i >= int(Led::CELL); i--) {
        this->on(Led(i));
        delay(50);
    }

    for (int i = int(Led::USER); i >= int(Led::CELL); i--) {
    1cb0:	21 97       	sbiw	r28, 0x01	; 1
    1cb2:	a8 f7       	brcc	.-22     	; 0x1c9e <main+0x24a>
beginManual():
/Users/francis-hung/Documents/Arduino/libraries/AVR-IoT-Cellular/src/led_ctrl.cpp:43
    this->off(Led::ERROR);
    this->off(Led::USER);
}

void LedCtrlClass::beginManual() {
    manual_control_enabled = true;
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	80 93 c8 44 	sts	0x44C8, r24	; 0x8044c8 <manual_control_enabled>
__pinconfigure():
    1cba:	61 e8       	ldi	r22, 0x81	; 129
    1cbc:	70 e0       	ldi	r23, 0x00	; 0
    1cbe:	80 e0       	ldi	r24, 0x00	; 0
    1cc0:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
    1cc4:	61 e8       	ldi	r22, 0x81	; 129
    1cc6:	70 e0       	ldi	r23, 0x00	; 0
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
    1cce:	61 e8       	ldi	r22, 0x81	; 129
    1cd0:	70 e0       	ldi	r23, 0x00	; 0
    1cd2:	82 e0       	ldi	r24, 0x02	; 2
    1cd4:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
    1cd8:	61 e8       	ldi	r22, 0x81	; 129
    1cda:	70 e0       	ldi	r23, 0x00	; 0
    1cdc:	83 e0       	ldi	r24, 0x03	; 3
    1cde:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
    1ce2:	61 e8       	ldi	r22, 0x81	; 129
    1ce4:	70 e0       	ldi	r23, 0x00	; 0
    1ce6:	8a e0       	ldi	r24, 0x0A	; 10
    1ce8:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
off():
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	80 e0       	ldi	r24, 0x00	; 0
    1cf0:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1cfc:	82 e0       	ldi	r24, 0x02	; 2
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d04:	83 e0       	ldi	r24, 0x03	; 3
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d0c:	84 e0       	ldi	r24, 0x04	; 4
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	80 e0       	ldi	r24, 0x00	; 0
    1d18:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d1c:	81 e0       	ldi	r24, 0x01	; 1
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d24:	82 e0       	ldi	r24, 0x02	; 2
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d2c:	83 e0       	ldi	r24, 0x03	; 3
    1d2e:	90 e0       	ldi	r25, 0x00	; 0
    1d30:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d34:	84 e0       	ldi	r24, 0x04	; 4
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
__pinconfigure():
    1d3c:	62 e0       	ldi	r22, 0x02	; 2
    1d3e:	70 e0       	ldi	r23, 0x00	; 0
    1d40:	8f e1       	ldi	r24, 0x1F	; 31
    1d42:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
    1d46:	62 e0       	ldi	r22, 0x02	; 2
    1d48:	70 e0       	ldi	r23, 0x00	; 0
    1d4a:	80 e2       	ldi	r24, 0x20	; 32
    1d4c:	0e 94 49 01 	call	0x292	; 0x292 <__pinconfigure(unsigned char, unsigned int) [clone .part.0]>
setup():
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:46
    LedCtrl.off(Led::ERROR);
    LedCtrl.off(Led::USER);

    pinConfigure(PIN_PE1, PIN_DIR_INPUT);
    pinConfigure(PIN_PE2, PIN_DIR_INPUT);
    Log.info("Start reading pin input");
    1d50:	89 e2       	ldi	r24, 0x29	; 41
    1d52:	91 e4       	ldi	r25, 0x41	; 65
    1d54:	0e 94 21 04 	call	0x842	; 0x842 <LogClass::info(char const*) [clone .constprop.26]>
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:47
    int readP1 = digitalRead(PIN_PE1);
    1d58:	8f e1       	ldi	r24, 0x1F	; 31
    1d5a:	0e 94 c9 04 	call	0x992	; 0x992 <digitalRead>
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:48
    Log.info("Pin P1 val: " + readP1);
    1d5e:	08 2e       	mov	r0, r24
    1d60:	00 0c       	add	r0, r0
    1d62:	99 0b       	sbc	r25, r25
    1d64:	8f 5b       	subi	r24, 0xBF	; 191
    1d66:	9e 4b       	sbci	r25, 0xBE	; 190
    1d68:	0e 94 21 04 	call	0x842	; 0x842 <LogClass::info(char const*) [clone .constprop.26]>
loop():
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:53
}

void loop() {
    
    if (digitalRead(PIN_PE1) == 1)
    1d6c:	8f e1       	ldi	r24, 0x1F	; 31
    1d6e:	0e 94 c9 04 	call	0x992	; 0x992 <digitalRead>
    1d72:	81 30       	cpi	r24, 0x01	; 1
    1d74:	99 f4       	brne	.+38     	; 0x1d9c <main+0x348>
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:55
    {
        Log.info("Pin PE1 trigger");
    1d76:	8e e4       	ldi	r24, 0x4E	; 78
    1d78:	91 e4       	ldi	r25, 0x41	; 65
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:62
        delay(3000);
        LedCtrl.off(Led::USER);
    }
    else if (digitalRead(PIN_PE2) == 1)
    {
        Log.info("Pin PE2 trigger");
    1d7a:	0e 94 21 04 	call	0x842	; 0x842 <LogClass::info(char const*) [clone .constprop.26]>
on():
    1d7e:	84 e0       	ldi	r24, 0x04	; 4
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	0e 94 be 05 	call	0xb7c	; 0xb7c <LedCtrlClass::on(Led, bool) [clone .part.1] [clone .constprop.23]>
loop():
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:64
        LedCtrl.on(Led::USER);
        delay(3000);
    1d86:	68 eb       	ldi	r22, 0xB8	; 184
    1d88:	7b e0       	ldi	r23, 0x0B	; 11
    1d8a:	80 e0       	ldi	r24, 0x00	; 0
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	0e 94 c3 01 	call	0x386	; 0x386 <delay>
off():
    1d92:	84 e0       	ldi	r24, 0x04	; 4
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	0e 94 c1 05 	call	0xb82	; 0xb82 <LedCtrlClass::off(Led, bool) [clone .part.2] [clone .constprop.21]>
    1d9a:	e8 cf       	rjmp	.-48     	; 0x1d6c <main+0x318>
loop():
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:60
        Log.info("Pin PE1 trigger");
        LedCtrl.on(Led::USER);
        delay(3000);
        LedCtrl.off(Led::USER);
    }
    else if (digitalRead(PIN_PE2) == 1)
    1d9c:	80 e2       	ldi	r24, 0x20	; 32
    1d9e:	0e 94 c9 04 	call	0x992	; 0x992 <digitalRead>
    1da2:	81 30       	cpi	r24, 0x01	; 1
    1da4:	19 f7       	brne	.-58     	; 0x1d6c <main+0x318>
/Users/francis-hung/Documents/Code/avr-iot/Code/Code.ino:62
    {
        Log.info("Pin PE2 trigger");
    1da6:	8e e5       	ldi	r24, 0x5E	; 94
    1da8:	91 e4       	ldi	r25, 0x41	; 65
    1daa:	e7 cf       	rjmp	.-50     	; 0x1d7a <main+0x326>

00001dac <_GLOBAL__sub_D__Z12SMSMessaging6StringS_>:
__base_dtor ():
/Users/francis-hung/Library/Arduino15/packages/DxCore/hardware/megaavr/1.5.6/cores/dxcore/api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
    1dac:	80 91 d0 48 	lds	r24, 0x48D0	; 0x8048d0 <PHONE_NUMBER>
    1db0:	90 91 d1 48 	lds	r25, 0x48D1	; 0x8048d1 <PHONE_NUMBER+0x1>
    1db4:	3a c2       	rjmp	.+1140   	; 0x222a <free>

00001db6 <__ftoa_engine>:
__ftoa_engine():
    1db6:	28 30       	cpi	r18, 0x08	; 8
    1db8:	08 f0       	brcs	.+2      	; 0x1dbc <__ftoa_engine+0x6>
    1dba:	27 e0       	ldi	r18, 0x07	; 7
    1dbc:	33 27       	eor	r19, r19
    1dbe:	da 01       	movw	r26, r20
    1dc0:	99 0f       	add	r25, r25
    1dc2:	31 1d       	adc	r19, r1
    1dc4:	87 fd       	sbrc	r24, 7
    1dc6:	91 60       	ori	r25, 0x01	; 1
    1dc8:	00 96       	adiw	r24, 0x00	; 0
    1dca:	61 05       	cpc	r22, r1
    1dcc:	71 05       	cpc	r23, r1
    1dce:	39 f4       	brne	.+14     	; 0x1dde <__ftoa_engine+0x28>
    1dd0:	32 60       	ori	r19, 0x02	; 2
    1dd2:	2e 5f       	subi	r18, 0xFE	; 254
    1dd4:	3d 93       	st	X+, r19
    1dd6:	30 e3       	ldi	r19, 0x30	; 48
    1dd8:	2a 95       	dec	r18
    1dda:	e1 f7       	brne	.-8      	; 0x1dd4 <__ftoa_engine+0x1e>
    1ddc:	08 95       	ret
    1dde:	9f 3f       	cpi	r25, 0xFF	; 255
    1de0:	30 f0       	brcs	.+12     	; 0x1dee <__ftoa_engine+0x38>
    1de2:	80 38       	cpi	r24, 0x80	; 128
    1de4:	71 05       	cpc	r23, r1
    1de6:	61 05       	cpc	r22, r1
    1de8:	09 f0       	breq	.+2      	; 0x1dec <__ftoa_engine+0x36>
    1dea:	3c 5f       	subi	r19, 0xFC	; 252
    1dec:	3c 5f       	subi	r19, 0xFC	; 252
    1dee:	3d 93       	st	X+, r19
    1df0:	91 30       	cpi	r25, 0x01	; 1
    1df2:	08 f0       	brcs	.+2      	; 0x1df6 <__ftoa_engine+0x40>
    1df4:	80 68       	ori	r24, 0x80	; 128
    1df6:	91 1d       	adc	r25, r1
    1df8:	df 93       	push	r29
    1dfa:	cf 93       	push	r28
    1dfc:	1f 93       	push	r17
    1dfe:	0f 93       	push	r16
    1e00:	ff 92       	push	r15
    1e02:	ef 92       	push	r14
    1e04:	19 2f       	mov	r17, r25
    1e06:	98 7f       	andi	r25, 0xF8	; 248
    1e08:	96 95       	lsr	r25
    1e0a:	e9 2f       	mov	r30, r25
    1e0c:	96 95       	lsr	r25
    1e0e:	96 95       	lsr	r25
    1e10:	e9 0f       	add	r30, r25
    1e12:	ff 27       	eor	r31, r31
    1e14:	ea 5a       	subi	r30, 0xAA	; 170
    1e16:	fe 4f       	sbci	r31, 0xFE	; 254
    1e18:	99 27       	eor	r25, r25
    1e1a:	33 27       	eor	r19, r19
    1e1c:	ee 24       	eor	r14, r14
    1e1e:	ff 24       	eor	r15, r15
    1e20:	a7 01       	movw	r20, r14
    1e22:	e7 01       	movw	r28, r14
    1e24:	05 90       	lpm	r0, Z+
    1e26:	08 94       	sec
    1e28:	07 94       	ror	r0
    1e2a:	28 f4       	brcc	.+10     	; 0x1e36 <__ftoa_engine+0x80>
    1e2c:	36 0f       	add	r19, r22
    1e2e:	e7 1e       	adc	r14, r23
    1e30:	f8 1e       	adc	r15, r24
    1e32:	49 1f       	adc	r20, r25
    1e34:	51 1d       	adc	r21, r1
    1e36:	66 0f       	add	r22, r22
    1e38:	77 1f       	adc	r23, r23
    1e3a:	88 1f       	adc	r24, r24
    1e3c:	99 1f       	adc	r25, r25
    1e3e:	06 94       	lsr	r0
    1e40:	a1 f7       	brne	.-24     	; 0x1e2a <__ftoa_engine+0x74>
    1e42:	05 90       	lpm	r0, Z+
    1e44:	07 94       	ror	r0
    1e46:	28 f4       	brcc	.+10     	; 0x1e52 <__ftoa_engine+0x9c>
    1e48:	e7 0e       	add	r14, r23
    1e4a:	f8 1e       	adc	r15, r24
    1e4c:	49 1f       	adc	r20, r25
    1e4e:	56 1f       	adc	r21, r22
    1e50:	c1 1d       	adc	r28, r1
    1e52:	77 0f       	add	r23, r23
    1e54:	88 1f       	adc	r24, r24
    1e56:	99 1f       	adc	r25, r25
    1e58:	66 1f       	adc	r22, r22
    1e5a:	06 94       	lsr	r0
    1e5c:	a1 f7       	brne	.-24     	; 0x1e46 <__ftoa_engine+0x90>
    1e5e:	05 90       	lpm	r0, Z+
    1e60:	07 94       	ror	r0
    1e62:	28 f4       	brcc	.+10     	; 0x1e6e <__ftoa_engine+0xb8>
    1e64:	f8 0e       	add	r15, r24
    1e66:	49 1f       	adc	r20, r25
    1e68:	56 1f       	adc	r21, r22
    1e6a:	c7 1f       	adc	r28, r23
    1e6c:	d1 1d       	adc	r29, r1
    1e6e:	88 0f       	add	r24, r24
    1e70:	99 1f       	adc	r25, r25
    1e72:	66 1f       	adc	r22, r22
    1e74:	77 1f       	adc	r23, r23
    1e76:	06 94       	lsr	r0
    1e78:	a1 f7       	brne	.-24     	; 0x1e62 <__ftoa_engine+0xac>
    1e7a:	05 90       	lpm	r0, Z+
    1e7c:	07 94       	ror	r0
    1e7e:	20 f4       	brcc	.+8      	; 0x1e88 <__ftoa_engine+0xd2>
    1e80:	49 0f       	add	r20, r25
    1e82:	56 1f       	adc	r21, r22
    1e84:	c7 1f       	adc	r28, r23
    1e86:	d8 1f       	adc	r29, r24
    1e88:	99 0f       	add	r25, r25
    1e8a:	66 1f       	adc	r22, r22
    1e8c:	77 1f       	adc	r23, r23
    1e8e:	88 1f       	adc	r24, r24
    1e90:	06 94       	lsr	r0
    1e92:	a9 f7       	brne	.-22     	; 0x1e7e <__ftoa_engine+0xc8>
    1e94:	84 91       	lpm	r24, Z
    1e96:	10 95       	com	r17
    1e98:	17 70       	andi	r17, 0x07	; 7
    1e9a:	41 f0       	breq	.+16     	; 0x1eac <__ftoa_engine+0xf6>
    1e9c:	d6 95       	lsr	r29
    1e9e:	c7 95       	ror	r28
    1ea0:	57 95       	ror	r21
    1ea2:	47 95       	ror	r20
    1ea4:	f7 94       	ror	r15
    1ea6:	e7 94       	ror	r14
    1ea8:	1a 95       	dec	r17
    1eaa:	c1 f7       	brne	.-16     	; 0x1e9c <__ftoa_engine+0xe6>
    1eac:	ec ef       	ldi	r30, 0xFC	; 252
    1eae:	f0 e0       	ldi	r31, 0x00	; 0
    1eb0:	68 94       	set
    1eb2:	15 90       	lpm	r1, Z+
    1eb4:	15 91       	lpm	r17, Z+
    1eb6:	35 91       	lpm	r19, Z+
    1eb8:	65 91       	lpm	r22, Z+
    1eba:	95 91       	lpm	r25, Z+
    1ebc:	05 90       	lpm	r0, Z+
    1ebe:	7f e2       	ldi	r23, 0x2F	; 47
    1ec0:	73 95       	inc	r23
    1ec2:	e1 18       	sub	r14, r1
    1ec4:	f1 0a       	sbc	r15, r17
    1ec6:	43 0b       	sbc	r20, r19
    1ec8:	56 0b       	sbc	r21, r22
    1eca:	c9 0b       	sbc	r28, r25
    1ecc:	d0 09       	sbc	r29, r0
    1ece:	c0 f7       	brcc	.-16     	; 0x1ec0 <__ftoa_engine+0x10a>
    1ed0:	e1 0c       	add	r14, r1
    1ed2:	f1 1e       	adc	r15, r17
    1ed4:	43 1f       	adc	r20, r19
    1ed6:	56 1f       	adc	r21, r22
    1ed8:	c9 1f       	adc	r28, r25
    1eda:	d0 1d       	adc	r29, r0
    1edc:	7e f4       	brtc	.+30     	; 0x1efc <__ftoa_engine+0x146>
    1ede:	70 33       	cpi	r23, 0x30	; 48
    1ee0:	11 f4       	brne	.+4      	; 0x1ee6 <__ftoa_engine+0x130>
    1ee2:	8a 95       	dec	r24
    1ee4:	e6 cf       	rjmp	.-52     	; 0x1eb2 <__ftoa_engine+0xfc>
    1ee6:	e8 94       	clt
    1ee8:	01 50       	subi	r16, 0x01	; 1
    1eea:	30 f0       	brcs	.+12     	; 0x1ef8 <__ftoa_engine+0x142>
    1eec:	08 0f       	add	r16, r24
    1eee:	0a f4       	brpl	.+2      	; 0x1ef2 <__ftoa_engine+0x13c>
    1ef0:	00 27       	eor	r16, r16
    1ef2:	02 17       	cp	r16, r18
    1ef4:	08 f4       	brcc	.+2      	; 0x1ef8 <__ftoa_engine+0x142>
    1ef6:	20 2f       	mov	r18, r16
    1ef8:	23 95       	inc	r18
    1efa:	02 2f       	mov	r16, r18
    1efc:	7a 33       	cpi	r23, 0x3A	; 58
    1efe:	28 f0       	brcs	.+10     	; 0x1f0a <__ftoa_engine+0x154>
    1f00:	79 e3       	ldi	r23, 0x39	; 57
    1f02:	7d 93       	st	X+, r23
    1f04:	2a 95       	dec	r18
    1f06:	e9 f7       	brne	.-6      	; 0x1f02 <__ftoa_engine+0x14c>
    1f08:	10 c0       	rjmp	.+32     	; 0x1f2a <__ftoa_engine+0x174>
    1f0a:	7d 93       	st	X+, r23
    1f0c:	2a 95       	dec	r18
    1f0e:	89 f6       	brne	.-94     	; 0x1eb2 <__ftoa_engine+0xfc>
    1f10:	06 94       	lsr	r0
    1f12:	97 95       	ror	r25
    1f14:	67 95       	ror	r22
    1f16:	37 95       	ror	r19
    1f18:	17 95       	ror	r17
    1f1a:	17 94       	ror	r1
    1f1c:	e1 18       	sub	r14, r1
    1f1e:	f1 0a       	sbc	r15, r17
    1f20:	43 0b       	sbc	r20, r19
    1f22:	56 0b       	sbc	r21, r22
    1f24:	c9 0b       	sbc	r28, r25
    1f26:	d0 09       	sbc	r29, r0
    1f28:	98 f0       	brcs	.+38     	; 0x1f50 <__ftoa_engine+0x19a>
    1f2a:	23 95       	inc	r18
    1f2c:	7e 91       	ld	r23, -X
    1f2e:	73 95       	inc	r23
    1f30:	7a 33       	cpi	r23, 0x3A	; 58
    1f32:	08 f0       	brcs	.+2      	; 0x1f36 <__ftoa_engine+0x180>
    1f34:	70 e3       	ldi	r23, 0x30	; 48
    1f36:	7c 93       	st	X, r23
    1f38:	20 13       	cpse	r18, r16
    1f3a:	b8 f7       	brcc	.-18     	; 0x1f2a <__ftoa_engine+0x174>
    1f3c:	7e 91       	ld	r23, -X
    1f3e:	70 61       	ori	r23, 0x10	; 16
    1f40:	7d 93       	st	X+, r23
    1f42:	30 f0       	brcs	.+12     	; 0x1f50 <__ftoa_engine+0x19a>
    1f44:	83 95       	inc	r24
    1f46:	71 e3       	ldi	r23, 0x31	; 49
    1f48:	7d 93       	st	X+, r23
    1f4a:	70 e3       	ldi	r23, 0x30	; 48
    1f4c:	2a 95       	dec	r18
    1f4e:	e1 f7       	brne	.-8      	; 0x1f48 <__ftoa_engine+0x192>
    1f50:	11 24       	eor	r1, r1
    1f52:	ef 90       	pop	r14
    1f54:	ff 90       	pop	r15
    1f56:	0f 91       	pop	r16
    1f58:	1f 91       	pop	r17
    1f5a:	cf 91       	pop	r28
    1f5c:	df 91       	pop	r29
    1f5e:	99 27       	eor	r25, r25
    1f60:	87 fd       	sbrc	r24, 7
    1f62:	90 95       	com	r25
    1f64:	08 95       	ret

00001f66 <strnlen_P>:
strnlen_P():
    1f66:	fc 01       	movw	r30, r24
    1f68:	05 90       	lpm	r0, Z+
    1f6a:	61 50       	subi	r22, 0x01	; 1
    1f6c:	70 40       	sbci	r23, 0x00	; 0
    1f6e:	01 10       	cpse	r0, r1
    1f70:	d8 f7       	brcc	.-10     	; 0x1f68 <strnlen_P+0x2>
    1f72:	80 95       	com	r24
    1f74:	90 95       	com	r25
    1f76:	8e 0f       	add	r24, r30
    1f78:	9f 1f       	adc	r25, r31
    1f7a:	08 95       	ret

00001f7c <strnlen>:
strnlen():
    1f7c:	fc 01       	movw	r30, r24
    1f7e:	61 50       	subi	r22, 0x01	; 1
    1f80:	70 40       	sbci	r23, 0x00	; 0
    1f82:	01 90       	ld	r0, Z+
    1f84:	01 10       	cpse	r0, r1
    1f86:	d8 f7       	brcc	.-10     	; 0x1f7e <strnlen+0x2>
    1f88:	80 95       	com	r24
    1f8a:	90 95       	com	r25
    1f8c:	8e 0f       	add	r24, r30
    1f8e:	9f 1f       	adc	r25, r31
    1f90:	08 95       	ret

00001f92 <fputc>:
fputc():
    1f92:	0f 93       	push	r16
    1f94:	1f 93       	push	r17
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	18 2f       	mov	r17, r24
    1f9c:	09 2f       	mov	r16, r25
    1f9e:	eb 01       	movw	r28, r22
    1fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa2:	81 fd       	sbrc	r24, 1
    1fa4:	09 c0       	rjmp	.+18     	; 0x1fb8 <fputc+0x26>
    1fa6:	1f ef       	ldi	r17, 0xFF	; 255
    1fa8:	0f ef       	ldi	r16, 0xFF	; 255
    1faa:	81 2f       	mov	r24, r17
    1fac:	90 2f       	mov	r25, r16
    1fae:	df 91       	pop	r29
    1fb0:	cf 91       	pop	r28
    1fb2:	1f 91       	pop	r17
    1fb4:	0f 91       	pop	r16
    1fb6:	08 95       	ret
    1fb8:	82 ff       	sbrs	r24, 2
    1fba:	14 c0       	rjmp	.+40     	; 0x1fe4 <fputc+0x52>
    1fbc:	2e 81       	ldd	r18, Y+6	; 0x06
    1fbe:	3f 81       	ldd	r19, Y+7	; 0x07
    1fc0:	8c 81       	ldd	r24, Y+4	; 0x04
    1fc2:	9d 81       	ldd	r25, Y+5	; 0x05
    1fc4:	28 17       	cp	r18, r24
    1fc6:	39 07       	cpc	r19, r25
    1fc8:	3c f4       	brge	.+14     	; 0x1fd8 <fputc+0x46>
    1fca:	e8 81       	ld	r30, Y
    1fcc:	f9 81       	ldd	r31, Y+1	; 0x01
    1fce:	cf 01       	movw	r24, r30
    1fd0:	01 96       	adiw	r24, 0x01	; 1
    1fd2:	88 83       	st	Y, r24
    1fd4:	99 83       	std	Y+1, r25	; 0x01
    1fd6:	10 83       	st	Z, r17
    1fd8:	8e 81       	ldd	r24, Y+6	; 0x06
    1fda:	9f 81       	ldd	r25, Y+7	; 0x07
    1fdc:	01 96       	adiw	r24, 0x01	; 1
    1fde:	8e 83       	std	Y+6, r24	; 0x06
    1fe0:	9f 83       	std	Y+7, r25	; 0x07
    1fe2:	e3 cf       	rjmp	.-58     	; 0x1faa <fputc+0x18>
    1fe4:	e8 85       	ldd	r30, Y+8	; 0x08
    1fe6:	f9 85       	ldd	r31, Y+9	; 0x09
    1fe8:	81 2f       	mov	r24, r17
    1fea:	09 95       	icall
    1fec:	89 2b       	or	r24, r25
    1fee:	a1 f3       	breq	.-24     	; 0x1fd8 <fputc+0x46>
    1ff0:	da cf       	rjmp	.-76     	; 0x1fa6 <fputc+0x14>

00001ff2 <__ultoa_invert>:
__ultoa_invert():
    1ff2:	fa 01       	movw	r30, r20
    1ff4:	aa 27       	eor	r26, r26
    1ff6:	28 30       	cpi	r18, 0x08	; 8
    1ff8:	51 f1       	breq	.+84     	; 0x204e <__ultoa_invert+0x5c>
    1ffa:	20 31       	cpi	r18, 0x10	; 16
    1ffc:	81 f1       	breq	.+96     	; 0x205e <__ultoa_invert+0x6c>
    1ffe:	e8 94       	clt
    2000:	6f 93       	push	r22
    2002:	6e 7f       	andi	r22, 0xFE	; 254
    2004:	6e 5f       	subi	r22, 0xFE	; 254
    2006:	7f 4f       	sbci	r23, 0xFF	; 255
    2008:	8f 4f       	sbci	r24, 0xFF	; 255
    200a:	9f 4f       	sbci	r25, 0xFF	; 255
    200c:	af 4f       	sbci	r26, 0xFF	; 255
    200e:	b1 e0       	ldi	r27, 0x01	; 1
    2010:	3e d0       	rcall	.+124    	; 0x208e <__ultoa_invert+0x9c>
    2012:	b4 e0       	ldi	r27, 0x04	; 4
    2014:	3c d0       	rcall	.+120    	; 0x208e <__ultoa_invert+0x9c>
    2016:	67 0f       	add	r22, r23
    2018:	78 1f       	adc	r23, r24
    201a:	89 1f       	adc	r24, r25
    201c:	9a 1f       	adc	r25, r26
    201e:	a1 1d       	adc	r26, r1
    2020:	68 0f       	add	r22, r24
    2022:	79 1f       	adc	r23, r25
    2024:	8a 1f       	adc	r24, r26
    2026:	91 1d       	adc	r25, r1
    2028:	a1 1d       	adc	r26, r1
    202a:	6a 0f       	add	r22, r26
    202c:	71 1d       	adc	r23, r1
    202e:	81 1d       	adc	r24, r1
    2030:	91 1d       	adc	r25, r1
    2032:	a1 1d       	adc	r26, r1
    2034:	20 d0       	rcall	.+64     	; 0x2076 <__ultoa_invert+0x84>
    2036:	09 f4       	brne	.+2      	; 0x203a <__ultoa_invert+0x48>
    2038:	68 94       	set
    203a:	3f 91       	pop	r19
    203c:	2a e0       	ldi	r18, 0x0A	; 10
    203e:	26 9f       	mul	r18, r22
    2040:	11 24       	eor	r1, r1
    2042:	30 19       	sub	r19, r0
    2044:	30 5d       	subi	r19, 0xD0	; 208
    2046:	31 93       	st	Z+, r19
    2048:	de f6       	brtc	.-74     	; 0x2000 <__ultoa_invert+0xe>
    204a:	cf 01       	movw	r24, r30
    204c:	08 95       	ret
    204e:	46 2f       	mov	r20, r22
    2050:	47 70       	andi	r20, 0x07	; 7
    2052:	40 5d       	subi	r20, 0xD0	; 208
    2054:	41 93       	st	Z+, r20
    2056:	b3 e0       	ldi	r27, 0x03	; 3
    2058:	0f d0       	rcall	.+30     	; 0x2078 <__ultoa_invert+0x86>
    205a:	c9 f7       	brne	.-14     	; 0x204e <__ultoa_invert+0x5c>
    205c:	f6 cf       	rjmp	.-20     	; 0x204a <__ultoa_invert+0x58>
    205e:	46 2f       	mov	r20, r22
    2060:	4f 70       	andi	r20, 0x0F	; 15
    2062:	40 5d       	subi	r20, 0xD0	; 208
    2064:	4a 33       	cpi	r20, 0x3A	; 58
    2066:	18 f0       	brcs	.+6      	; 0x206e <__ultoa_invert+0x7c>
    2068:	49 5d       	subi	r20, 0xD9	; 217
    206a:	31 fd       	sbrc	r19, 1
    206c:	40 52       	subi	r20, 0x20	; 32
    206e:	41 93       	st	Z+, r20
    2070:	02 d0       	rcall	.+4      	; 0x2076 <__ultoa_invert+0x84>
    2072:	a9 f7       	brne	.-22     	; 0x205e <__ultoa_invert+0x6c>
    2074:	ea cf       	rjmp	.-44     	; 0x204a <__ultoa_invert+0x58>
    2076:	b4 e0       	ldi	r27, 0x04	; 4
    2078:	a6 95       	lsr	r26
    207a:	97 95       	ror	r25
    207c:	87 95       	ror	r24
    207e:	77 95       	ror	r23
    2080:	67 95       	ror	r22
    2082:	ba 95       	dec	r27
    2084:	c9 f7       	brne	.-14     	; 0x2078 <__ultoa_invert+0x86>
    2086:	00 97       	sbiw	r24, 0x00	; 0
    2088:	61 05       	cpc	r22, r1
    208a:	71 05       	cpc	r23, r1
    208c:	08 95       	ret
    208e:	9b 01       	movw	r18, r22
    2090:	ac 01       	movw	r20, r24
    2092:	0a 2e       	mov	r0, r26
    2094:	06 94       	lsr	r0
    2096:	57 95       	ror	r21
    2098:	47 95       	ror	r20
    209a:	37 95       	ror	r19
    209c:	27 95       	ror	r18
    209e:	ba 95       	dec	r27
    20a0:	c9 f7       	brne	.-14     	; 0x2094 <__ultoa_invert+0xa2>
    20a2:	62 0f       	add	r22, r18
    20a4:	73 1f       	adc	r23, r19
    20a6:	84 1f       	adc	r24, r20
    20a8:	95 1f       	adc	r25, r21
    20aa:	a0 1d       	adc	r26, r0
    20ac:	08 95       	ret

000020ae <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    20ae:	09 d0       	rcall	.+18     	; 0x20c2 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    20b0:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    20b2:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    20b4:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    20b6:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    20b8:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    20ba:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    20bc:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    20be:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    20c0:	08 95       	ret

000020c2 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    20c2:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    20c4:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    20c6:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    20c8:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    20ca:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    20cc:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    20ce:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    20d0:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    20d2:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    20d4:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    20d6:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    20d8:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    20da:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    20dc:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    20de:	08 95       	ret

000020e0 <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    20e0:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    20e2:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2304
    20e4:	00 24       	eor	r0, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2305
    20e6:	00 1c       	adc	r0, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2306
    20e8:	0b be       	out	0x3b, r0	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2312
    20ea:	07 90       	elpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2313
    20ec:	f6 91       	elpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2314
    20ee:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2319
    20f0:	09 94       	ijmp

000020f2 <malloc>:
malloc():
    20f2:	0f 93       	push	r16
    20f4:	1f 93       	push	r17
    20f6:	cf 93       	push	r28
    20f8:	df 93       	push	r29
    20fa:	82 30       	cpi	r24, 0x02	; 2
    20fc:	91 05       	cpc	r25, r1
    20fe:	10 f4       	brcc	.+4      	; 0x2104 <malloc+0x12>
    2100:	82 e0       	ldi	r24, 0x02	; 2
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	e0 91 d8 48 	lds	r30, 0x48D8	; 0x8048d8 <__flp>
    2108:	f0 91 d9 48 	lds	r31, 0x48D9	; 0x8048d9 <__flp+0x1>
    210c:	30 e0       	ldi	r19, 0x00	; 0
    210e:	20 e0       	ldi	r18, 0x00	; 0
    2110:	b0 e0       	ldi	r27, 0x00	; 0
    2112:	a0 e0       	ldi	r26, 0x00	; 0
    2114:	30 97       	sbiw	r30, 0x00	; 0
    2116:	99 f4       	brne	.+38     	; 0x213e <malloc+0x4c>
    2118:	21 15       	cp	r18, r1
    211a:	31 05       	cpc	r19, r1
    211c:	09 f4       	brne	.+2      	; 0x2120 <malloc+0x2e>
    211e:	4a c0       	rjmp	.+148    	; 0x21b4 <malloc+0xc2>
    2120:	28 1b       	sub	r18, r24
    2122:	39 0b       	sbc	r19, r25
    2124:	24 30       	cpi	r18, 0x04	; 4
    2126:	31 05       	cpc	r19, r1
    2128:	d8 f5       	brcc	.+118    	; 0x21a0 <malloc+0xae>
    212a:	8a 81       	ldd	r24, Y+2	; 0x02
    212c:	9b 81       	ldd	r25, Y+3	; 0x03
    212e:	61 15       	cp	r22, r1
    2130:	71 05       	cpc	r23, r1
    2132:	89 f1       	breq	.+98     	; 0x2196 <malloc+0xa4>
    2134:	fb 01       	movw	r30, r22
    2136:	82 83       	std	Z+2, r24	; 0x02
    2138:	93 83       	std	Z+3, r25	; 0x03
    213a:	fe 01       	movw	r30, r28
    213c:	11 c0       	rjmp	.+34     	; 0x2160 <malloc+0x6e>
    213e:	40 81       	ld	r20, Z
    2140:	51 81       	ldd	r21, Z+1	; 0x01
    2142:	02 81       	ldd	r16, Z+2	; 0x02
    2144:	13 81       	ldd	r17, Z+3	; 0x03
    2146:	48 17       	cp	r20, r24
    2148:	59 07       	cpc	r21, r25
    214a:	e0 f0       	brcs	.+56     	; 0x2184 <malloc+0x92>
    214c:	48 17       	cp	r20, r24
    214e:	59 07       	cpc	r21, r25
    2150:	99 f4       	brne	.+38     	; 0x2178 <malloc+0x86>
    2152:	10 97       	sbiw	r26, 0x00	; 0
    2154:	61 f0       	breq	.+24     	; 0x216e <malloc+0x7c>
    2156:	12 96       	adiw	r26, 0x02	; 2
    2158:	0c 93       	st	X, r16
    215a:	12 97       	sbiw	r26, 0x02	; 2
    215c:	13 96       	adiw	r26, 0x03	; 3
    215e:	1c 93       	st	X, r17
    2160:	32 96       	adiw	r30, 0x02	; 2
    2162:	cf 01       	movw	r24, r30
    2164:	df 91       	pop	r29
    2166:	cf 91       	pop	r28
    2168:	1f 91       	pop	r17
    216a:	0f 91       	pop	r16
    216c:	08 95       	ret
    216e:	00 93 d8 48 	sts	0x48D8, r16	; 0x8048d8 <__flp>
    2172:	10 93 d9 48 	sts	0x48D9, r17	; 0x8048d9 <__flp+0x1>
    2176:	f4 cf       	rjmp	.-24     	; 0x2160 <malloc+0x6e>
    2178:	21 15       	cp	r18, r1
    217a:	31 05       	cpc	r19, r1
    217c:	51 f0       	breq	.+20     	; 0x2192 <malloc+0xa0>
    217e:	42 17       	cp	r20, r18
    2180:	53 07       	cpc	r21, r19
    2182:	38 f0       	brcs	.+14     	; 0x2192 <malloc+0xa0>
    2184:	a9 01       	movw	r20, r18
    2186:	db 01       	movw	r26, r22
    2188:	9a 01       	movw	r18, r20
    218a:	bd 01       	movw	r22, r26
    218c:	df 01       	movw	r26, r30
    218e:	f8 01       	movw	r30, r16
    2190:	c1 cf       	rjmp	.-126    	; 0x2114 <malloc+0x22>
    2192:	ef 01       	movw	r28, r30
    2194:	f9 cf       	rjmp	.-14     	; 0x2188 <malloc+0x96>
    2196:	80 93 d8 48 	sts	0x48D8, r24	; 0x8048d8 <__flp>
    219a:	90 93 d9 48 	sts	0x48D9, r25	; 0x8048d9 <__flp+0x1>
    219e:	cd cf       	rjmp	.-102    	; 0x213a <malloc+0x48>
    21a0:	fe 01       	movw	r30, r28
    21a2:	e2 0f       	add	r30, r18
    21a4:	f3 1f       	adc	r31, r19
    21a6:	81 93       	st	Z+, r24
    21a8:	91 93       	st	Z+, r25
    21aa:	22 50       	subi	r18, 0x02	; 2
    21ac:	31 09       	sbc	r19, r1
    21ae:	28 83       	st	Y, r18
    21b0:	39 83       	std	Y+1, r19	; 0x01
    21b2:	d7 cf       	rjmp	.-82     	; 0x2162 <malloc+0x70>
    21b4:	20 91 d6 48 	lds	r18, 0x48D6	; 0x8048d6 <__brkval>
    21b8:	30 91 d7 48 	lds	r19, 0x48D7	; 0x8048d7 <__brkval+0x1>
    21bc:	23 2b       	or	r18, r19
    21be:	41 f4       	brne	.+16     	; 0x21d0 <malloc+0xde>
    21c0:	20 91 12 40 	lds	r18, 0x4012	; 0x804012 <__malloc_heap_start>
    21c4:	30 91 13 40 	lds	r19, 0x4013	; 0x804013 <__malloc_heap_start+0x1>
    21c8:	20 93 d6 48 	sts	0x48D6, r18	; 0x8048d6 <__brkval>
    21cc:	30 93 d7 48 	sts	0x48D7, r19	; 0x8048d7 <__brkval+0x1>
    21d0:	20 91 10 40 	lds	r18, 0x4010	; 0x804010 <__malloc_heap_end>
    21d4:	30 91 11 40 	lds	r19, 0x4011	; 0x804011 <__malloc_heap_end+0x1>
    21d8:	21 15       	cp	r18, r1
    21da:	31 05       	cpc	r19, r1
    21dc:	41 f4       	brne	.+16     	; 0x21ee <malloc+0xfc>
    21de:	2d b7       	in	r18, 0x3d	; 61
    21e0:	3e b7       	in	r19, 0x3e	; 62
    21e2:	40 91 14 40 	lds	r20, 0x4014	; 0x804014 <__malloc_margin>
    21e6:	50 91 15 40 	lds	r21, 0x4015	; 0x804015 <__malloc_margin+0x1>
    21ea:	24 1b       	sub	r18, r20
    21ec:	35 0b       	sbc	r19, r21
    21ee:	e0 91 d6 48 	lds	r30, 0x48D6	; 0x8048d6 <__brkval>
    21f2:	f0 91 d7 48 	lds	r31, 0x48D7	; 0x8048d7 <__brkval+0x1>
    21f6:	e2 17       	cp	r30, r18
    21f8:	f3 07       	cpc	r31, r19
    21fa:	a0 f4       	brcc	.+40     	; 0x2224 <malloc+0x132>
    21fc:	2e 1b       	sub	r18, r30
    21fe:	3f 0b       	sbc	r19, r31
    2200:	28 17       	cp	r18, r24
    2202:	39 07       	cpc	r19, r25
    2204:	78 f0       	brcs	.+30     	; 0x2224 <malloc+0x132>
    2206:	ac 01       	movw	r20, r24
    2208:	4e 5f       	subi	r20, 0xFE	; 254
    220a:	5f 4f       	sbci	r21, 0xFF	; 255
    220c:	24 17       	cp	r18, r20
    220e:	35 07       	cpc	r19, r21
    2210:	48 f0       	brcs	.+18     	; 0x2224 <malloc+0x132>
    2212:	4e 0f       	add	r20, r30
    2214:	5f 1f       	adc	r21, r31
    2216:	40 93 d6 48 	sts	0x48D6, r20	; 0x8048d6 <__brkval>
    221a:	50 93 d7 48 	sts	0x48D7, r21	; 0x8048d7 <__brkval+0x1>
    221e:	81 93       	st	Z+, r24
    2220:	91 93       	st	Z+, r25
    2222:	9f cf       	rjmp	.-194    	; 0x2162 <malloc+0x70>
    2224:	f0 e0       	ldi	r31, 0x00	; 0
    2226:	e0 e0       	ldi	r30, 0x00	; 0
    2228:	9c cf       	rjmp	.-200    	; 0x2162 <malloc+0x70>

0000222a <free>:
free():
    222a:	cf 93       	push	r28
    222c:	df 93       	push	r29
    222e:	00 97       	sbiw	r24, 0x00	; 0
    2230:	e9 f0       	breq	.+58     	; 0x226c <free+0x42>
    2232:	fc 01       	movw	r30, r24
    2234:	32 97       	sbiw	r30, 0x02	; 2
    2236:	12 82       	std	Z+2, r1	; 0x02
    2238:	13 82       	std	Z+3, r1	; 0x03
    223a:	a0 91 d8 48 	lds	r26, 0x48D8	; 0x8048d8 <__flp>
    223e:	b0 91 d9 48 	lds	r27, 0x48D9	; 0x8048d9 <__flp+0x1>
    2242:	ed 01       	movw	r28, r26
    2244:	30 e0       	ldi	r19, 0x00	; 0
    2246:	20 e0       	ldi	r18, 0x00	; 0
    2248:	10 97       	sbiw	r26, 0x00	; 0
    224a:	a1 f4       	brne	.+40     	; 0x2274 <free+0x4a>
    224c:	20 81       	ld	r18, Z
    224e:	31 81       	ldd	r19, Z+1	; 0x01
    2250:	82 0f       	add	r24, r18
    2252:	93 1f       	adc	r25, r19
    2254:	20 91 d6 48 	lds	r18, 0x48D6	; 0x8048d6 <__brkval>
    2258:	30 91 d7 48 	lds	r19, 0x48D7	; 0x8048d7 <__brkval+0x1>
    225c:	28 17       	cp	r18, r24
    225e:	39 07       	cpc	r19, r25
    2260:	09 f0       	breq	.+2      	; 0x2264 <free+0x3a>
    2262:	61 c0       	rjmp	.+194    	; 0x2326 <free+0xfc>
    2264:	e0 93 d6 48 	sts	0x48D6, r30	; 0x8048d6 <__brkval>
    2268:	f0 93 d7 48 	sts	0x48D7, r31	; 0x8048d7 <__brkval+0x1>
    226c:	df 91       	pop	r29
    226e:	cf 91       	pop	r28
    2270:	08 95       	ret
    2272:	ea 01       	movw	r28, r20
    2274:	ce 17       	cp	r28, r30
    2276:	df 07       	cpc	r29, r31
    2278:	e8 f5       	brcc	.+122    	; 0x22f4 <free+0xca>
    227a:	4a 81       	ldd	r20, Y+2	; 0x02
    227c:	5b 81       	ldd	r21, Y+3	; 0x03
    227e:	9e 01       	movw	r18, r28
    2280:	41 15       	cp	r20, r1
    2282:	51 05       	cpc	r21, r1
    2284:	b1 f7       	brne	.-20     	; 0x2272 <free+0x48>
    2286:	e9 01       	movw	r28, r18
    2288:	ea 83       	std	Y+2, r30	; 0x02
    228a:	fb 83       	std	Y+3, r31	; 0x03
    228c:	49 91       	ld	r20, Y+
    228e:	59 91       	ld	r21, Y+
    2290:	c4 0f       	add	r28, r20
    2292:	d5 1f       	adc	r29, r21
    2294:	ec 17       	cp	r30, r28
    2296:	fd 07       	cpc	r31, r29
    2298:	61 f4       	brne	.+24     	; 0x22b2 <free+0x88>
    229a:	80 81       	ld	r24, Z
    229c:	91 81       	ldd	r25, Z+1	; 0x01
    229e:	02 96       	adiw	r24, 0x02	; 2
    22a0:	84 0f       	add	r24, r20
    22a2:	95 1f       	adc	r25, r21
    22a4:	e9 01       	movw	r28, r18
    22a6:	88 83       	st	Y, r24
    22a8:	99 83       	std	Y+1, r25	; 0x01
    22aa:	82 81       	ldd	r24, Z+2	; 0x02
    22ac:	93 81       	ldd	r25, Z+3	; 0x03
    22ae:	8a 83       	std	Y+2, r24	; 0x02
    22b0:	9b 83       	std	Y+3, r25	; 0x03
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	e0 e0       	ldi	r30, 0x00	; 0
    22b6:	12 96       	adiw	r26, 0x02	; 2
    22b8:	8d 91       	ld	r24, X+
    22ba:	9c 91       	ld	r25, X
    22bc:	13 97       	sbiw	r26, 0x03	; 3
    22be:	00 97       	sbiw	r24, 0x00	; 0
    22c0:	b9 f5       	brne	.+110    	; 0x2330 <free+0x106>
    22c2:	2d 91       	ld	r18, X+
    22c4:	3c 91       	ld	r19, X
    22c6:	11 97       	sbiw	r26, 0x01	; 1
    22c8:	cd 01       	movw	r24, r26
    22ca:	02 96       	adiw	r24, 0x02	; 2
    22cc:	82 0f       	add	r24, r18
    22ce:	93 1f       	adc	r25, r19
    22d0:	20 91 d6 48 	lds	r18, 0x48D6	; 0x8048d6 <__brkval>
    22d4:	30 91 d7 48 	lds	r19, 0x48D7	; 0x8048d7 <__brkval+0x1>
    22d8:	28 17       	cp	r18, r24
    22da:	39 07       	cpc	r19, r25
    22dc:	39 f6       	brne	.-114    	; 0x226c <free+0x42>
    22de:	30 97       	sbiw	r30, 0x00	; 0
    22e0:	51 f5       	brne	.+84     	; 0x2336 <free+0x10c>
    22e2:	10 92 d8 48 	sts	0x48D8, r1	; 0x8048d8 <__flp>
    22e6:	10 92 d9 48 	sts	0x48D9, r1	; 0x8048d9 <__flp+0x1>
    22ea:	a0 93 d6 48 	sts	0x48D6, r26	; 0x8048d6 <__brkval>
    22ee:	b0 93 d7 48 	sts	0x48D7, r27	; 0x8048d7 <__brkval+0x1>
    22f2:	bc cf       	rjmp	.-136    	; 0x226c <free+0x42>
    22f4:	c2 83       	std	Z+2, r28	; 0x02
    22f6:	d3 83       	std	Z+3, r29	; 0x03
    22f8:	40 81       	ld	r20, Z
    22fa:	51 81       	ldd	r21, Z+1	; 0x01
    22fc:	84 0f       	add	r24, r20
    22fe:	95 1f       	adc	r25, r21
    2300:	c8 17       	cp	r28, r24
    2302:	d9 07       	cpc	r29, r25
    2304:	61 f4       	brne	.+24     	; 0x231e <free+0xf4>
    2306:	4e 5f       	subi	r20, 0xFE	; 254
    2308:	5f 4f       	sbci	r21, 0xFF	; 255
    230a:	88 81       	ld	r24, Y
    230c:	99 81       	ldd	r25, Y+1	; 0x01
    230e:	48 0f       	add	r20, r24
    2310:	59 1f       	adc	r21, r25
    2312:	40 83       	st	Z, r20
    2314:	51 83       	std	Z+1, r21	; 0x01
    2316:	8a 81       	ldd	r24, Y+2	; 0x02
    2318:	9b 81       	ldd	r25, Y+3	; 0x03
    231a:	82 83       	std	Z+2, r24	; 0x02
    231c:	93 83       	std	Z+3, r25	; 0x03
    231e:	21 15       	cp	r18, r1
    2320:	31 05       	cpc	r19, r1
    2322:	09 f0       	breq	.+2      	; 0x2326 <free+0xfc>
    2324:	b0 cf       	rjmp	.-160    	; 0x2286 <free+0x5c>
    2326:	e0 93 d8 48 	sts	0x48D8, r30	; 0x8048d8 <__flp>
    232a:	f0 93 d9 48 	sts	0x48D9, r31	; 0x8048d9 <__flp+0x1>
    232e:	9e cf       	rjmp	.-196    	; 0x226c <free+0x42>
    2330:	fd 01       	movw	r30, r26
    2332:	dc 01       	movw	r26, r24
    2334:	c0 cf       	rjmp	.-128    	; 0x22b6 <free+0x8c>
    2336:	12 82       	std	Z+2, r1	; 0x02
    2338:	13 82       	std	Z+3, r1	; 0x03
    233a:	d7 cf       	rjmp	.-82     	; 0x22ea <free+0xc0>

0000233c <realloc>:
realloc():
    233c:	4f 92       	push	r4
    233e:	5f 92       	push	r5
    2340:	6f 92       	push	r6
    2342:	7f 92       	push	r7
    2344:	8f 92       	push	r8
    2346:	9f 92       	push	r9
    2348:	af 92       	push	r10
    234a:	bf 92       	push	r11
    234c:	cf 92       	push	r12
    234e:	df 92       	push	r13
    2350:	ef 92       	push	r14
    2352:	ff 92       	push	r15
    2354:	0f 93       	push	r16
    2356:	1f 93       	push	r17
    2358:	cf 93       	push	r28
    235a:	df 93       	push	r29
    235c:	8c 01       	movw	r16, r24
    235e:	00 97       	sbiw	r24, 0x00	; 0
    2360:	91 f4       	brne	.+36     	; 0x2386 <realloc+0x4a>
    2362:	cb 01       	movw	r24, r22
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	1f 91       	pop	r17
    236a:	0f 91       	pop	r16
    236c:	ff 90       	pop	r15
    236e:	ef 90       	pop	r14
    2370:	df 90       	pop	r13
    2372:	cf 90       	pop	r12
    2374:	bf 90       	pop	r11
    2376:	af 90       	pop	r10
    2378:	9f 90       	pop	r9
    237a:	8f 90       	pop	r8
    237c:	7f 90       	pop	r7
    237e:	6f 90       	pop	r6
    2380:	5f 90       	pop	r5
    2382:	4f 90       	pop	r4
    2384:	b6 ce       	rjmp	.-660    	; 0x20f2 <malloc>
    2386:	fc 01       	movw	r30, r24
    2388:	e6 0f       	add	r30, r22
    238a:	f7 1f       	adc	r31, r23
    238c:	9c 01       	movw	r18, r24
    238e:	22 50       	subi	r18, 0x02	; 2
    2390:	31 09       	sbc	r19, r1
    2392:	e2 17       	cp	r30, r18
    2394:	f3 07       	cpc	r31, r19
    2396:	08 f4       	brcc	.+2      	; 0x239a <realloc+0x5e>
    2398:	aa c0       	rjmp	.+340    	; 0x24ee <realloc+0x1b2>
    239a:	d9 01       	movw	r26, r18
    239c:	cd 91       	ld	r28, X+
    239e:	dc 91       	ld	r29, X
    23a0:	11 97       	sbiw	r26, 0x01	; 1
    23a2:	c6 17       	cp	r28, r22
    23a4:	d7 07       	cpc	r29, r23
    23a6:	18 f1       	brcs	.+70     	; 0x23ee <realloc+0xb2>
    23a8:	c5 30       	cpi	r28, 0x05	; 5
    23aa:	d1 05       	cpc	r29, r1
    23ac:	70 f0       	brcs	.+28     	; 0x23ca <realloc+0x8e>
    23ae:	ce 01       	movw	r24, r28
    23b0:	04 97       	sbiw	r24, 0x04	; 4
    23b2:	86 17       	cp	r24, r22
    23b4:	97 07       	cpc	r25, r23
    23b6:	48 f0       	brcs	.+18     	; 0x23ca <realloc+0x8e>
    23b8:	c6 1b       	sub	r28, r22
    23ba:	d7 0b       	sbc	r29, r23
    23bc:	22 97       	sbiw	r28, 0x02	; 2
    23be:	c1 93       	st	Z+, r28
    23c0:	d1 93       	st	Z+, r29
    23c2:	6d 93       	st	X+, r22
    23c4:	7c 93       	st	X, r23
    23c6:	cf 01       	movw	r24, r30
    23c8:	30 df       	rcall	.-416    	; 0x222a <free>
    23ca:	c8 01       	movw	r24, r16
    23cc:	df 91       	pop	r29
    23ce:	cf 91       	pop	r28
    23d0:	1f 91       	pop	r17
    23d2:	0f 91       	pop	r16
    23d4:	ff 90       	pop	r15
    23d6:	ef 90       	pop	r14
    23d8:	df 90       	pop	r13
    23da:	cf 90       	pop	r12
    23dc:	bf 90       	pop	r11
    23de:	af 90       	pop	r10
    23e0:	9f 90       	pop	r9
    23e2:	8f 90       	pop	r8
    23e4:	7f 90       	pop	r7
    23e6:	6f 90       	pop	r6
    23e8:	5f 90       	pop	r5
    23ea:	4f 90       	pop	r4
    23ec:	08 95       	ret
    23ee:	5b 01       	movw	r10, r22
    23f0:	ac 1a       	sub	r10, r28
    23f2:	bd 0a       	sbc	r11, r29
    23f4:	4c 01       	movw	r8, r24
    23f6:	8c 0e       	add	r8, r28
    23f8:	9d 1e       	adc	r9, r29
    23fa:	a0 91 d8 48 	lds	r26, 0x48D8	; 0x8048d8 <__flp>
    23fe:	b0 91 d9 48 	lds	r27, 0x48D9	; 0x8048d9 <__flp+0x1>
    2402:	51 2c       	mov	r5, r1
    2404:	41 2c       	mov	r4, r1
    2406:	f1 2c       	mov	r15, r1
    2408:	e1 2c       	mov	r14, r1
    240a:	10 97       	sbiw	r26, 0x00	; 0
    240c:	31 f5       	brne	.+76     	; 0x245a <realloc+0x11e>
    240e:	80 91 d6 48 	lds	r24, 0x48D6	; 0x8048d6 <__brkval>
    2412:	90 91 d7 48 	lds	r25, 0x48D7	; 0x8048d7 <__brkval+0x1>
    2416:	88 15       	cp	r24, r8
    2418:	99 05       	cpc	r25, r9
    241a:	09 f0       	breq	.+2      	; 0x241e <realloc+0xe2>
    241c:	5c c0       	rjmp	.+184    	; 0x24d6 <realloc+0x19a>
    241e:	46 16       	cp	r4, r22
    2420:	57 06       	cpc	r5, r23
    2422:	08 f0       	brcs	.+2      	; 0x2426 <realloc+0xea>
    2424:	58 c0       	rjmp	.+176    	; 0x24d6 <realloc+0x19a>
    2426:	80 91 10 40 	lds	r24, 0x4010	; 0x804010 <__malloc_heap_end>
    242a:	90 91 11 40 	lds	r25, 0x4011	; 0x804011 <__malloc_heap_end+0x1>
    242e:	00 97       	sbiw	r24, 0x00	; 0
    2430:	41 f4       	brne	.+16     	; 0x2442 <realloc+0x106>
    2432:	8d b7       	in	r24, 0x3d	; 61
    2434:	9e b7       	in	r25, 0x3e	; 62
    2436:	40 91 14 40 	lds	r20, 0x4014	; 0x804014 <__malloc_margin>
    243a:	50 91 15 40 	lds	r21, 0x4015	; 0x804015 <__malloc_margin+0x1>
    243e:	84 1b       	sub	r24, r20
    2440:	95 0b       	sbc	r25, r21
    2442:	e8 17       	cp	r30, r24
    2444:	f9 07       	cpc	r31, r25
    2446:	08 f0       	brcs	.+2      	; 0x244a <realloc+0x10e>
    2448:	52 c0       	rjmp	.+164    	; 0x24ee <realloc+0x1b2>
    244a:	e0 93 d6 48 	sts	0x48D6, r30	; 0x8048d6 <__brkval>
    244e:	f0 93 d7 48 	sts	0x48D7, r31	; 0x8048d7 <__brkval+0x1>
    2452:	f9 01       	movw	r30, r18
    2454:	60 83       	st	Z, r22
    2456:	71 83       	std	Z+1, r23	; 0x01
    2458:	b8 cf       	rjmp	.-144    	; 0x23ca <realloc+0x8e>
    245a:	8d 91       	ld	r24, X+
    245c:	9c 91       	ld	r25, X
    245e:	11 97       	sbiw	r26, 0x01	; 1
    2460:	12 96       	adiw	r26, 0x02	; 2
    2462:	6c 90       	ld	r6, X
    2464:	12 97       	sbiw	r26, 0x02	; 2
    2466:	13 96       	adiw	r26, 0x03	; 3
    2468:	7c 90       	ld	r7, X
    246a:	13 97       	sbiw	r26, 0x03	; 3
    246c:	a8 15       	cp	r26, r8
    246e:	b9 05       	cpc	r27, r9
    2470:	59 f5       	brne	.+86     	; 0x24c8 <realloc+0x18c>
    2472:	6c 01       	movw	r12, r24
    2474:	42 e0       	ldi	r20, 0x02	; 2
    2476:	c4 0e       	add	r12, r20
    2478:	d1 1c       	adc	r13, r1
    247a:	ca 14       	cp	r12, r10
    247c:	db 04       	cpc	r13, r11
    247e:	20 f1       	brcs	.+72     	; 0x24c8 <realloc+0x18c>
    2480:	ac 01       	movw	r20, r24
    2482:	4a 19       	sub	r20, r10
    2484:	5b 09       	sbc	r21, r11
    2486:	da 01       	movw	r26, r20
    2488:	12 96       	adiw	r26, 0x02	; 2
    248a:	15 97       	sbiw	r26, 0x05	; 5
    248c:	80 f0       	brcs	.+32     	; 0x24ae <realloc+0x172>
    248e:	62 82       	std	Z+2, r6	; 0x02
    2490:	73 82       	std	Z+3, r7	; 0x03
    2492:	40 83       	st	Z, r20
    2494:	51 83       	std	Z+1, r21	; 0x01
    2496:	d9 01       	movw	r26, r18
    2498:	6d 93       	st	X+, r22
    249a:	7c 93       	st	X, r23
    249c:	e1 14       	cp	r14, r1
    249e:	f1 04       	cpc	r15, r1
    24a0:	71 f0       	breq	.+28     	; 0x24be <realloc+0x182>
    24a2:	d7 01       	movw	r26, r14
    24a4:	12 96       	adiw	r26, 0x02	; 2
    24a6:	ed 93       	st	X+, r30
    24a8:	fc 93       	st	X, r31
    24aa:	13 97       	sbiw	r26, 0x03	; 3
    24ac:	8e cf       	rjmp	.-228    	; 0x23ca <realloc+0x8e>
    24ae:	22 96       	adiw	r28, 0x02	; 2
    24b0:	8c 0f       	add	r24, r28
    24b2:	9d 1f       	adc	r25, r29
    24b4:	f9 01       	movw	r30, r18
    24b6:	80 83       	st	Z, r24
    24b8:	91 83       	std	Z+1, r25	; 0x01
    24ba:	f3 01       	movw	r30, r6
    24bc:	ef cf       	rjmp	.-34     	; 0x249c <realloc+0x160>
    24be:	e0 93 d8 48 	sts	0x48D8, r30	; 0x8048d8 <__flp>
    24c2:	f0 93 d9 48 	sts	0x48D9, r31	; 0x8048d9 <__flp+0x1>
    24c6:	81 cf       	rjmp	.-254    	; 0x23ca <realloc+0x8e>
    24c8:	48 16       	cp	r4, r24
    24ca:	59 06       	cpc	r5, r25
    24cc:	08 f4       	brcc	.+2      	; 0x24d0 <realloc+0x194>
    24ce:	2c 01       	movw	r4, r24
    24d0:	7d 01       	movw	r14, r26
    24d2:	d3 01       	movw	r26, r6
    24d4:	9a cf       	rjmp	.-204    	; 0x240a <realloc+0xce>
    24d6:	cb 01       	movw	r24, r22
    24d8:	0c de       	rcall	.-1000   	; 0x20f2 <malloc>
    24da:	7c 01       	movw	r14, r24
    24dc:	00 97       	sbiw	r24, 0x00	; 0
    24de:	39 f0       	breq	.+14     	; 0x24ee <realloc+0x1b2>
    24e0:	ae 01       	movw	r20, r28
    24e2:	b8 01       	movw	r22, r16
    24e4:	14 d0       	rcall	.+40     	; 0x250e <memcpy>
    24e6:	c8 01       	movw	r24, r16
    24e8:	a0 de       	rcall	.-704    	; 0x222a <free>
    24ea:	87 01       	movw	r16, r14
    24ec:	6e cf       	rjmp	.-292    	; 0x23ca <realloc+0x8e>
    24ee:	10 e0       	ldi	r17, 0x00	; 0
    24f0:	00 e0       	ldi	r16, 0x00	; 0
    24f2:	6b cf       	rjmp	.-298    	; 0x23ca <realloc+0x8e>

000024f4 <memcmp>:
memcmp():
    24f4:	fb 01       	movw	r30, r22
    24f6:	dc 01       	movw	r26, r24
    24f8:	04 c0       	rjmp	.+8      	; 0x2502 <memcmp+0xe>
    24fa:	8d 91       	ld	r24, X+
    24fc:	01 90       	ld	r0, Z+
    24fe:	80 19       	sub	r24, r0
    2500:	21 f4       	brne	.+8      	; 0x250a <memcmp+0x16>
    2502:	41 50       	subi	r20, 0x01	; 1
    2504:	50 40       	sbci	r21, 0x00	; 0
    2506:	c8 f7       	brcc	.-14     	; 0x24fa <memcmp+0x6>
    2508:	88 1b       	sub	r24, r24
    250a:	99 0b       	sbc	r25, r25
    250c:	08 95       	ret

0000250e <memcpy>:
memcpy():
    250e:	fb 01       	movw	r30, r22
    2510:	dc 01       	movw	r26, r24
    2512:	02 c0       	rjmp	.+4      	; 0x2518 <memcpy+0xa>
    2514:	01 90       	ld	r0, Z+
    2516:	0d 92       	st	X+, r0
    2518:	41 50       	subi	r20, 0x01	; 1
    251a:	50 40       	sbci	r21, 0x00	; 0
    251c:	d8 f7       	brcc	.-10     	; 0x2514 <memcpy+0x6>
    251e:	08 95       	ret

00002520 <strcpy>:
strcpy():
    2520:	fb 01       	movw	r30, r22
    2522:	dc 01       	movw	r26, r24
    2524:	01 90       	ld	r0, Z+
    2526:	0d 92       	st	X+, r0
    2528:	00 20       	and	r0, r0
    252a:	e1 f7       	brne	.-8      	; 0x2524 <strcpy+0x4>
    252c:	08 95       	ret

0000252e <__do_global_dtors>:
__do_global_dtors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
    252e:	11 e0       	ldi	r17, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
    2530:	c1 e0       	ldi	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
    2532:	d1 e0       	ldi	r29, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
    2534:	03 c0       	rjmp	.+6      	; 0x253c <__do_global_dtors+0xe>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
    2536:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
    2538:	d3 dd       	rcall	.-1114   	; 0x20e0 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
    253a:	21 96       	adiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
    253c:	c2 30       	cpi	r28, 0x02	; 2
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
    253e:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
    2540:	d1 f7       	brne	.-12     	; 0x2536 <__do_global_dtors+0x8>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    2542:	f8 94       	cli

00002544 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    2544:	ff cf       	rjmp	.-2      	; 0x2544 <__stop_program>
